<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>자바의 Thread | 내 맘대로 블로그</title>
<meta name="description" content="1. Thread의 기본  운영체제 레벨에서 Thread는 명령어 포인터(instruction pointer)와 스택 포인터(stack pointer) 두가지를 가지고 있다.      명령어 포인터 : 다음에 실행할 명령어를 가리킴   스택 포인터 : Thread의 독립적인 local data를 저장하는 메모리 영역을 가리킴.">


  <meta name="author" content="KIMSS">


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="내 맘대로 블로그">
<meta property="og:title" content="자바의 Thread">
<meta property="og:url" content="http://localhost:4000/java/thread">


  <meta property="og:description" content="1. Thread의 기본  운영체제 레벨에서 Thread는 명령어 포인터(instruction pointer)와 스택 포인터(stack pointer) 두가지를 가지고 있다.      명령어 포인터 : 다음에 실행할 명령어를 가리킴   스택 포인터 : Thread의 독립적인 local data를 저장하는 메모리 영역을 가리킴.">







  <meta property="article:published_time" content="2016-01-01T00:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/java/thread">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "안드로이드 개발 및 기타",
      "url": "http://localhost:4000/"
    
  }
</script>


  <meta name="google-site-verification" content="25fsY7AInJqIAdb8Vv-48IGkeV3PSkILUE6h6ovfdjQ" />





  <meta name="naver-site-verification" content="1ee74ce5d72ee1a7b21ffc798e9119fb03749830">

<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="내 맘대로 블로그 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->
<script data-ad-client="ca-pub-2766016066821722" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          내 맘대로 블로그
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/">Category</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tag</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/">Years</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">KIMSS</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>개인 개발 공부 Archive 입니다. 오래전 정리한 내용에는 일부 잘못된 내용이 포함되어 있을 수 있고 출처표기가 부족할 수 있습니다. 또한 포스팅된 글은 완성도를 위해 중간에 업데이트 될 수 있습니다.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">팔로우</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Republic of Korea</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
        
          
        
      

      

      
        <li>
          <a href="mailto:kssappmail@naver.com">
            <meta itemprop="email" content="kssappmail@naver.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">이메일</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">토글 메뉴</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Category</span>
        

        
        <ul>
          
            <li><a href="/categories/android">안드로이드</a></li>
          
            <li><a href="/categories/java">자바</a></li>
          
            <li><a href="/categories/designpattern">디자인패턴</a></li>
          
            <li><a href="/categories/security">보안</a></li>
          
            <li><a href="/categories/basic">개발 etc</a></li>
          
            <li><a href="/categories/blogging">블로깅</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="자바의 Thread">
    <meta itemprop="description" content="1. Thread의 기본운영체제 레벨에서 Thread는 명령어 포인터(instruction pointer)와 스택 포인터(stack pointer) 두가지를 가지고 있다.   명령어 포인터 : 다음에 실행할 명령어를 가리킴  스택 포인터 : Thread의 독립적인 local data를 저장하는 메모리 영역을 가리킴.">
    <meta itemprop="datePublished" content="2016-01-01T00:00:00+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">자바의 Thread
</h1>
          


  <p class="page__meta">

    
      
      <i class="far fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2016-01-01T00:00:00+09:00">January 1, 2016</time>
    

    
      
      <span class="post__meta-sep"></span>
      
    

    
      
      

      <i class="far fa-clock" aria-hidden="true"></i>
      
        7 분 소요
      
    

  </p>

        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2 id="1-thread의-기본">1. Thread의 기본</h2>

<p>운영체제 레벨에서 Thread는 명령어 포인터(instruction pointer)와 스택 포인터(stack pointer) 두가지를 가지고 있다. <br /></p>

<ul>
  <li>명령어 포인터 : 다음에 실행할 명령어를 가리킴</li>
  <li>스택 포인터 : Thread의 독립적인 local data를 저장하는 메모리 영역을 가리킴.</li>
</ul>

<p>CPU는 한번에 한 명령어만 처리할 수 있다. <br />
따라서 한 CPU를 통해 멀티쓰레드 동작을 위해서 CPU는 응용 프로그램 Thread 사이에 처리 시간을 공유해야 한다.</p>

<p>이러한 CPU 처리 시간 공유는 <strong>스케줄러(schedular)</strong>에 의해 처리된다. <br />
스케줄러는 CPU가 얼마나 한 Thread를 얼마동안 처리해야 하는지를 결정하는데 이런 스케줄링 전략은 다양한 방식에 의해 구현될수 있지만 보통은 우선순위 스케줄링 전략을 기반으로 한다.</p>

<p>자바에서 Thread 우선 순위는 <code class="language-plaintext highlighter-rouge">Thread.setPriority(int)</code> 를 통해 설정 할 수 있다. <br />
최저 1에서 최고 10까지 선택할 수 있고 명시적으로 설정하지 않을 경우 default는 5이다.</p>

<p>그런데 스케줄링이 우선순위를 기반으로만 동작하게 된다면 낮은 우선순위의 Thread는 작업을 수행할 충분한 시간을 얻지 못할 수 있다. 이러한 상태를 <strong>기아(starvation)</strong> 상태라 한다. 따라서 스케줄러는 이러한 경우에 대한 고려도 필요하다.</p>

<p>멀티 Thread 환경에서 처리할 Thread의 변경은 <strong>문맥 교환(context switch)</strong> 이라고 한다. <br />
문맥 교환은 여러 과정으로 구성된다.</p>

<ol>
  <li>현재 실행중인 thread를 나중에 다시 시작할 수 있도록 상태 저장.</li>
  <li>저장 이후 thread를 대기상태로 만듬.</li>
  <li>다른 thread 처리를 위해 대기 상태인 다른 thread를 복원</li>
</ol>

<h2 id="2-멀티-thread">2. 멀티 Thread</h2>
<p>멀티쓰레딩을 통해 동작이 동시에 실행되도록 할 수 있다. 만약 실행하는 Thread의 수가 프로세서의 수를 초과하게 되면 완벽한 동시성이 될 수 없다. 하지만 스케줄러는 Thread 사이를 빠르게 전환하며 여러 동작이 동시에 실행 되도록 한다.</p>

<p>멀티 Thread는 필수적이지만 아래와 같이 복잡성 증가, 자원 소비 증가 등이 동반된다.</p>

<h3 id="21-자원-소비-증가">2.1. 자원 소비 증가</h3>
<p>각 thread는 지역변수 및 매개변수를 저장하기 위해 전용 메모리 영역이 할당된다. <br />
 이 메모리 영역은 thread가 생성될대 할당되어 thread가 종료되면 회수된다. <br />
 프로세서 입장에서는 thread가 많으면 context switch를 해야 하기 때문에 오버헤드가 생긴다.</p>

<h3 id="22-복잡성-증가">2.2. 복잡성 증가</h3>
<p>멀티 thread는 실행의 불확식성을 동반한다. 이러한 불확실성으로 인해 디버깅이 어려워지고 멀티 thread 조절은 또 다른 버그를 만들 위험도 있다.</p>

<h3 id="23-데이터-불일치">2.3. 데이터 불일치</h3>
<p>2개 이상의 서로 다른 thread가 동일한 변수를 동시에 변경하려고 할때 이 변수는 <strong>경쟁조건(race condition)</strong>에 노출된다. <br />
 경쟁조건이란 코드 실행 순서가 일정하지 않기 때문에 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RaceCondition</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sharedResource</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startTwoThreads</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">sharedResource</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
		
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">sharedResource</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예에서 sharedResource는 경쟁조건에 노출된다. <br /></p>

<p>위의 또 다른 문제점은 <code class="language-plaintext highlighter-rouge">sharedResource++</code>, <code class="language-plaintext highlighter-rouge">sharedResource--</code> 연산이다. <br />
 context switch는 바이트코드 연산 사이에서도 발생할 수 있는데 위의 <code class="language-plaintext highlighter-rouge">--, ++</code> 연산의 경우 내부적으로 3가지 연산의 조합이기 때문에 더 예상할 수 없는 결과를 발생시킨다.</p>

<p>만약 위와같은 문제를 피하기 위해서는 코드가 각 thread에서 상호 배타적으로 동작해야 하고 이러한 영역을 <strong>원자 영역(atomic region)</strong> 이라 한다.</p>

<p>자바에서 원자 영역을 만들어주는 가장 기본적인 동기화 매커니즘으로 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드가 있다.</p>

<h2 id="3-thread-safe">3. Thread Safe</h2>
<p>여러 thread에서 객체에 접근할 때 <strong>객체가 항상 정확한 상태를 유지하는 것을 Thread safe</strong> 하다고 말한다. <br />
 즉, 객체의 상태가 경쟁조건에 빠지지 않는 것이다.</p>

<p>Thread safe는 여러방법이 있겠지만 기본적으로 객체 상태에 대한 접근을 제어할 수 있도록 객체를 동기화 함으로써 가능해진다.<br /></p>

<p>참고로 이렇게 두개 이상의 쓰레드가 특정 자원을 공유하고 있을 때 한번에 하나의 쓰레드에게만 접근을 허용하고자 하는 영역을 <strong>임계 영역(critical section)</strong> 이라고 한다.</p>

<p>동기화는 현재 임계 영역에서 실행되는 thread가 있는지 확인하는 잠금 매커니즘(locking machanism)으로 만들어 진다.</p>

<p>자바는 아래와 같은 암시적 잠금과 명시적 잠금 매커니즘을 가지고 있다.</p>

<ol>
  <li>암시적 잠금
    <ul>
      <li>synchronized 키워드</li>
    </ul>
  </li>
  <li>명시적 잠금
    <ul>
      <li>java.util.concurrent.locks.ReentrantLock</li>
      <li>java.util.concurrent.locks.ReentrantReadWriteLock</li>
    </ul>
  </li>
</ol>

<h3 id="31-암시적-잠금">3.1. 암시적 잠금</h3>
<p>synchronized 키워드에 의해 구현되며 자세한 내용은 <code class="language-plaintext highlighter-rouge">(Java)synchronized.md</code> 문서를 참고한다.</p>

<h3 id="32-명시적-잠금">3.2. 명시적 잠금</h3>
<p>좀 더 고급화된 잠금 전략으로 <code class="language-plaintext highlighter-rouge">ReentrantLock</code> 또는 <code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code> 클래스를 이용할 수 있다. <br />
 (try-catch로 묶여야 해서 코드가 조금 지저분해지는 단점이 있다.)</p>

<h4 id="321-reentrantlock">3.2.1. ReentrantLock</h4>
<p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>과 <code class="language-plaintext highlighter-rouge">synchronized</code>는 같은 의미를 가진다. <br />
 두 기법 모두 어느 한 thread가 임계영역에 들어온 경우 다른 thread의 접근을 차단한다. <br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sharedResource</span><span class="o">;</span>
<span class="kd">private</span> <span class="nc">ReentrantLock</span> <span class="n">mLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeState</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">mLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="n">sharedResource</span><span class="o">++;</span>
    <span class="o">}</span><span class="k">finally</span><span class="o">{</span>
        <span class="n">mLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="322-reentrantreadwritelock">3.2.2. ReentrantReadWriteLock</h4>
<p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>과 <code class="language-plaintext highlighter-rouge">synchronized</code>과 같은 기법은 다른 모든 thread가 공유 변수를 단순히 읽는 것조차 유해하다고 판단하는 방어적인 전략이다.</p>

<p><code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>의 경우 읽으려는 thread는 동시에 실행되게 두면서, 쓰기는 차단한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sharedResource</span><span class="o">;</span>
<span class="kd">private</span> <span class="nc">ReentrantReadWriteLock</span> <span class="n">mLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeState</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">mLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="n">sharedResource</span><span class="o">++;</span>
    <span class="o">}</span><span class="k">finally</span><span class="o">{</span>
        <span class="n">mLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">readState</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">mLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="k">return</span> <span class="n">sharedResource</span><span class="o">;</span>
    <span class="o">}</span><span class="k">finally</span><span class="o">{</span>
        <span class="n">mLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>참고로 <code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>은 thread가 허용 또는 차단되야 하는지 확인하기 때문에 상대적으로 복잡하고 성능이 떨어진다. <br />
 <code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code> 적용의 좋은 사례는 읽기 thread가 다수 있으면서 쓰기 thread는 적은 경우이다.</p>

<h2 id="4-소비자-생성자-패턴">4. 소비자-생성자 패턴</h2>
<p>멀티 thread의 흔한 사례로로 한 thread는 데이터를 생산하고, 한 thread는 데이터를 소비하는 <strong>소비자-생산자 패턴(consumer-producer pattern)</strong>이 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConsumerProducer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">LIMIT</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
	
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">produce</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="no">LIMIT</span><span class="o">){</span>
                    <span class="c1">// 생산 최대치면 wait를 걸어서 lock 사용 권한을 넘겨준다.</span>
                    <span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                    <span class="c1">// 나중에 consume()에서 lock을 풀어주면 여기 다음 구문이 실행된다.</span>
                <span class="o">}</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">value</span><span class="o">++);</span>
				
                <span class="c1">// notify는 굳이 필요없을 수도 있지만 lock을 바로 풀어줘서 좀 더 빠르게 실행되게 할 수 있는 효과가 있다.</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
	
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">consume</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="c1">// 전부 소비하고 없으면 wait를 걸어서 lock 사용 권한을 넘겨준다.</span>
                    <span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                    <span class="c1">// 나중에 produce()에서 lock을 풀어주면 여기 다음 구문이 실행된다.</span>
                <span class="o">}</span>
                <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
				
                <span class="c1">// notify는 굳이 필요없을 수도 있지만 lock을 바로 풀어줘서 좀 더 빠르게 실행되게 할 수 있는 효과가 있다.</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">ConsumerProducer</span> <span class="n">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConsumerProducer</span><span class="o">();</span>

<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="n">cp</span><span class="o">.</span><span class="na">produce</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">){</span>
			
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>

<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="n">cp</span><span class="o">.</span><span class="na">consume</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">){</span>
			
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>

</code></pre></div></div>

<h2 id="5-thread-통신">5. Thread 통신</h2>

<h3 id="51-파이프-pipe">5.1. 파이프 (Pipe)</h3>
<p>java.io 패키지의 하나로 같은 프로세스 내에서 두 쓰레드 간의 단방향 통신을 제공한다. <br />
 (생산자 쓰레드는 파이프에 데이터를 기록하고, 소비자 쓰레드는 데이터를 읽는다.)</p>

<p>자바의 파이프는 POSIX의 pipe operator(쉘에서 <code class="language-plaintext highlighter-rouge">|</code> 문자)와 비슷한 기능을 하지만 프로세스 간의 통신을 하는 POSIX pipe 와는 달리 VM 위 스레드 사이에서 출력을 리다이렉팅 한다.</p>

<p>파이프 자체는 두 개의 연결된 쓰레드(생산자, 소비자)에서 단방향으로만 접근할 수 있는 circular buffer(원형 버퍼)이다. <br />
 그리고 앞의 소비자-생산자 패턴에서 볼 수 있듯 파이프는 Thread safe 한 방법이다.</p>

<p><strong>파이프는 시간이 오래 걸리는 어떤 작업(task)에 대해 쓰레드를 나눠 분할할 수 있게 하고, 쓰레드로 나눠진 작업(task)이 있을때 하나의 task가 끝나면 다음 task로 데이터를 옮길 수 있게한다.</strong></p>

<p>파이프는 binary 데이터나 character 데이터를 전송할 수 있다.</p>

<ol>
  <li>PipedInputStream : binary 데이터 전송을 위한 생산자</li>
  <li>PipedOutputStream : binary 데이터 전송을 위한 소비자</li>
  <li>PipedWriter : character 전송을 위한 생산자</li>
  <li>PipedReader : character 전송을 위한 소비자</li>
</ol>

<p>파이프의 수명은 connection이 형성될때부터 닫힐때까지 작동한다. <br />
 이 과정을 크게 세 가지로 나누면 setup, data transfer, disconnection으로 나뉜다.</p>

<blockquote>
  <p>POSIX : portable operating system interface(이식 가능 운영체제 인터페이스)의 약자로써 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격이다. POSIX의 마지막 글자 X는 유닉스 호환 운영체제에 보통 X가 붙는 것에서 유래한다. 규격의 내용은 커널로의 C 언어 인터페이스인 시스템 콜 뿐 아니라, 프로세스 환경, 파일과 디렉터리, 시스템 데이터베이스(암호 파일 등), tar 압축 포맷 등 다양한 분야를 아우른다.</p>
</blockquote>

<h4 id="pipe-사용-예">pipe 사용 예</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PipedInputStream</span> <span class="n">pipedInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PipedInputStream</span><span class="o">();</span>
<span class="nc">PipedOutputStream</span> <span class="n">pipedOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PipedOutputStream</span><span class="o">();</span>
<span class="n">pipedInputStream</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">pipedInputStream</span><span class="o">);</span>

<span class="nc">Thread</span> <span class="n">inputThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span> 
    <span class="nd">@Override</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">try</span> <span class="o">{</span> 
            <span class="nc">String</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"Hello Pipe!"</span><span class="o">;</span>
            <span class="n">pipedOutputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span> 
        <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> 
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
<span class="o">});</span>

<span class="nc">Thread</span> <span class="n">outputThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span> 
    <span class="nd">@Override</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">try</span> <span class="o">{</span> 
            <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="n">pipedInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">();</span> 
            <span class="k">for</span><span class="o">(;</span> <span class="n">data</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">pipedInputStream</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">{</span> 
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">data</span><span class="o">);</span> 
            <span class="o">}</span> 
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> 
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span> 
        <span class="o">}</span> 
    <span class="o">}</span> 
<span class="o">});</span>

<span class="n">inputThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> 
<span class="n">outputThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> 

</code></pre></div></div>

<p>통신은 blocking 매커니즘을 가진 소비자-생산자 패턴이다. <br />
 파이프가 가득 차면 write()는 차단되고, 파이프가 비면 read()는 차단된다. <br /></p>

<p>통신 완료 후에는 아래 코드로 종료한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pipedInputStream.close(); 
pipedOutputStream.close();
</code></pre></div></div>

<p>둘 중 하나만 닫혀도 충분하다. <br />
 단, 쓰기를 닫으면 파이프는 분리되지만 버퍼안의 데이터는 읽을 수 있다. 읽기를 닫으면 퍼버는 즉시 지워진다.</p>

<h3 id="52-공유-메모리-shared-memory">5.2. 공유 메모리 (Shared memory)</h3>
<p>동일한 프로세스 내의 모든 스레드는 각각의 stack 영역을 제외한 모든 영역(Code, Data, Heap)을 공유한다. 이 중 Heap 영역(공유 메모리)을 이용하여 스레드간의 통신을 할 수 있다.</p>

<p>아래와 같이 공유메모리(heap)에 쓴 데이터는 같은 프로세스 내의 모든 쓰레드에서 접근이 가능하다.</p>

<p><img src="https://kimss1502.github.io/assets/images//shared_memory.jpeg" alt="shared_memory" /></p>

<p>객체 인스턴스의 경우 인스턴스는 각 쓰레드의 stack에 저장되지만 객체 자체는 heap에 저장되기 때문에 참조를 전달하여 다른 쓰레드에서 접근할 수 있다.</p>

<h4 id="521-시그널링">5.2.1. 시그널링</h4>
<p>만일 두 스레드가 순서대로 실행되야 하며, 두 스레드 간에 Shared Memory를 사용해 통신한다면 어떻게 해야 할까? 앞서 Pipe의 예시처럼 어떤 state를 polling하여 구현할 수 있다. <br />
 Shared Memory에 state를 나타내는 변수를 만들고, 무한 루프를 돌며 state 변수가 변하는 것을 체크하는 것이다.</p>

<p>이 방법도 물론 잘 동작하지만, 이러한 busy waiting은 성능 저하를 초래한다.</p>

<p>이런것보다 Java의 built-in signaling mechanism을 이용하면 더 효율적으로 작동하게 할 수 있는데, <code class="language-plaintext highlighter-rouge">java.lang.Object</code>에 정의되어 있는 <code class="language-plaintext highlighter-rouge">wait()</code>, <code class="language-plaintext highlighter-rouge">notify()</code>, <code class="language-plaintext highlighter-rouge">notifyAll()</code> 세 개의 메서드를 사용하는 것이다.</p>

<blockquote>
  <p>자세한 내용은 <a href="../java/thread_status_method">Thread 상태를 조절하는 메서드</a> 포스팅을 참고한다.</p>
</blockquote>

<h3 id="53-블로킹-큐-blocking-queue">5.3. 블로킹 큐 (Blocking Queue)</h3>
<p>쓰레드 시그널링은 정교한 설정이 가능한 low-level mechansim으로 다양하게 적용할 수 있지만 그만큼 고려해야 할 부분이 많아 버그를 만들기 쉽다.</p>

<p>자바에서는 이를 위해 단방향 통신에 대해 추상화된 high-level signaling mechansim을 제공하는데 그게 <code class="language-plaintext highlighter-rouge">java.util.concurrent.BlockingQueue</code> 이다. <br /></p>

<p><img src="https://kimss1502.github.io/assets/images/blocking_queue.jpeg" alt="blocking queue" /></p>

<p><code class="language-plaintext highlighter-rouge">java.util.concurrent.BlockingQueue</code> 인터페이스들의 구현체로는 여러 가지가 있는데, Array로 구현되어 고정 크기를 가지는 <code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>, Linked List로 구현된 <code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>, Priority를 가지는 <code class="language-plaintext highlighter-rouge">PriorityBlockingQueue</code>, insert와 remove가 동시에 이루어지는, 크기가 항상 0으로 유지되는 <code class="language-plaintext highlighter-rouge">SynchronousQueue</code> 등이 있다.</p>

<blockquote>
  <p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html">API 문서</a></p>
</blockquote>

<h4 id="blocking-queue-사용-예">Blocking queue 사용 예</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BlockingQueue</span> <span class="n">queue</span><span class="o">;</span>
    <span class="nc">Producer</span><span class="o">(</span><span class="nc">BlockingQueue</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span> <span class="n">queue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">produce</span><span class="o">());</span> <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="n">handle</span> <span class="o">...}</span>
    <span class="o">}</span>
    <span class="nc">Object</span> <span class="nf">produce</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BlockingQueue</span> <span class="n">queue</span><span class="o">;</span>
    <span class="nc">Consumer</span><span class="o">(</span><span class="nc">BlockingQueue</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">q</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span> <span class="n">consume</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">());</span> <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="n">handle</span> <span class="o">...}</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">consume</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Setup</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">BlockingQueue</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SomeQueueImplementation</span><span class="o">();</span>
        <span class="nc">Producer</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Producer</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="nc">Consumer</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Consumer</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="nc">Consumer</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Consumer</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">c1</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">c2</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Producer는 <code class="language-plaintext highlighter-rouge">BlockingQueue.put()</code>을 하고, Consumer는 <code class="language-plaintext highlighter-rouge">BlockingQueue.take()</code>를 하는 것만으로 Thread Safe한 통신을 구현할 수 있다. 내부적으로 atomical하게 작동하도록 lock을 컨트롤 해 주기 때문이다.</p>

<!-- 참조하는 링크
   - java/thread_status_method : 2016-01-01-Thread 상태를 조절하는 메서드 
참조되는 링크
   - 2016-01-01-안드로이드 Task stack 뜯어보기
   - 2016-01-01-Looper, MessageQueue, Handler
   - 2016-01-01-Concurrent 패키지
   - 2016-01-01-synchronized -->

        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#java" class="page__taxonomy-item" rel="tag">Java</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time datetime="2016-01-01T00:00:00+09:00">January 1, 2016</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">공유하기</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%EC%9E%90%EB%B0%94%EC%9D%98+Thread%20http%3A%2F%2Flocalhost%3A4000%2Fjava%2Fthread" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fjava%2Fthread" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fjava%2Fthread" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="공유하기 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/java/thread_status_method" class="pagination--pager" title="Thread 상태를 조절하는 메서드
">이전</a>
    
    
      <a href="/java/java_synchronized" class="pagination--pager" title="synchronized
">다음</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">참고</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/%EB%B8%94%EB%A1%9C%EA%B9%85/3.-GitHub-pages-%EA%B5%AC%EC%B6%95-%ED%9B%84-%EC%84%A4%EC%A0%95/" rel="permalink">GitHub pages 구축 후 설정 (3)
</a>
      
    </h2>
    


  <p class="page__meta">

    
      
      <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2020-09-17T00:00:00+09:00">September 17, 2020</time>
    

    
      
        <br \>
      
    

    
      
      

      <i class="far fa-fw fa-clock" aria-hidden="true"></i>
      
        1 분 소요
      
    

  </p>

    <p class="archive__item-excerpt" itemprop="description">블로그 구성을 위해 했던 History 관리차 기록합니다.

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/%EB%B8%94%EB%A1%9C%EA%B9%85/2.-GitHub-pages-%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="permalink">GitHub pages로 블로그 만들기 (2)
</a>
      
    </h2>
    


  <p class="page__meta">

    
      
      <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2020-09-16T00:00:00+09:00">September 16, 2020</time>
    

    
      
        <br \>
      
    

    
      
      

      <i class="far fa-fw fa-clock" aria-hidden="true"></i>
      
        5 분 소요
      
    

  </p>

    <p class="archive__item-excerpt" itemprop="description">1. 저장소(Repository) 생성 및 설정
Git repository를 이용하는 것인만큼 Git에 새로운 Repository를 만들어야 한다. 
 주의할 점은 이 때 Repository 이름에 따라서 블로그의 도메인 주소가 바뀐다. 
 https://id.github.io 형...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/%EB%B8%94%EB%A1%9C%EA%B9%85/1.-GitHub-pages-%EC%99%80-%ED%85%8C%EB%A7%88/" rel="permalink">GitHub pages와 테마에 대해서 (1)
</a>
      
    </h2>
    


  <p class="page__meta">

    
      
      <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2020-09-15T00:00:00+09:00">September 15, 2020</time>
    

    
      
        <br \>
      
    

    
      
      

      <i class="far fa-fw fa-clock" aria-hidden="true"></i>
      
        3 분 소요
      
    

  </p>

    <p class="archive__item-excerpt" itemprop="description">GitHub에서 제공하는 GitHub Pages 기능을 이용하면 간단한 사이트를 만들 수 있다. 
 이렇게 만들어진 사이트는 https://{my-github-id}.github.io 형태의 사이트가 된다.

  Github pages 공식 자료


여기서는 Jekyll 을 이용한...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/security/encryption_algorithm" rel="permalink">암호화 알고리즘의 분류
</a>
      
    </h2>
    


  <p class="page__meta">

    
      
      <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2016-01-01T00:00:00+09:00">January 1, 2016</time>
    

    
      
        <br \>
      
    

    
      
      

      <i class="far fa-fw fa-clock" aria-hidden="true"></i>
      
        3 분 소요
      
    

  </p>

    <p class="archive__item-excerpt" itemprop="description">0. Intro
암호화 알고리즘은 크게 대칭형와 비대칭형 2가지로 나뉘는데 이는 암호화에 사용하는 Key와 복호화에 사용하는 Key가 같은지 다른지를 기준으로 분류된다. 
 통상적으로 대칭형 암호는 비밀키 암호에 사용되며 비대칭형 암호는 공개키 암호에 사용된다. 따라서 각각  대칭...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 안드로이드 개발 및 기타. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5&appId=1759901007629019";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
  





  </body>
</html>
