var store = [{
        "title": "ActivityGroup에 대해서",
        "excerpt":"   ActivityGroup은 이미 오래전 deprecated 되었다.   ActivityGroup과 관련한 내용은 Fragment에 대해서 포스팅을 함께 참고할 것.    ActivityGroup은 하나의 Activity에 여러개의 Activity를 포함할 수 있게 해준다. ViewGroup이 View를 가질수 있듯 ActivityGroup은 Activity를 가질 수 있다. &lt;/br&gt;   참고로 ActivityGroup 역시  Activity이다. 여러 Activity를 포함할 상위 Activity는 ActivityGroup을 상속받는다. &lt;/br&gt;   ActivityGroup을 사용하면 하나의 화면에 전환해야할 뷰가 여러개 존재할 때 각각의 뷰를 별도의 액티비티 단위로 나눌 수 있기 때문에 코드 관리하기가 좋다.   1. ActivityGroup내에 Activity를 추가하는 방법  // 1. 액티비티그룹을 상속받음으로써 자식 액티비티를 관리할 수 있게 된다. public class MainActivityGroup extends ActivityGroup {   \tFrameLayout mListMenuLayout     = null; \tFrameLayout mViewerLayout   = null;     \t// 2. 액티비티그룹의 자식 액티비티를 관리하는 로컬 액티비티매니저를 참조한다. \tLocalActivityManager mLocalActivityMgr = getLocalActivityManager();     \t// 3. 액티비티그룹도 액티비티를 상속받았기 때문에 액티비티 생명주기 함수가 모두 존재한다.  \t//   따라서 액티비티그룹도 onCreate 생명주기 함수가 최초 호출된다. \tprotected void onCreate(Bundle savedInstanceState) \t{ \t    super.onCreate(savedInstanceState); \t    setContentView(R.layout.activity_group_layout); \t    \t    // 4. 액티비티가 들어갈 뷰 참조 \t    // 리스트 메뉴 영역의 레이아웃 참조 \t    mListMenuLayout = (FrameLayout)findViewById( R.id.list_menu_layout ); \t    // 뷰어 영역의 레이아웃 참조 \t    mViewerLayout = (FrameLayout)findViewById( R.id.viewer_layout ); \t    \t    // 5. 화면 좌측에 리스트 메뉴 액티비티 실행 \t    // 메뉴 리스트 액티비티를 실행한다. \t    Intent menuActivityIntent = new Intent( this, ListMenuActivity.class );  \t    Window menuWindow = mLocalActivityMgr.startActivity( \"ListMenuActivity\", menuActivityIntent ); \t    \t    // 실행된 메뉴 액티비티의 레이아웃을 참조하여 액티비티그룹 좌측영역에 추가한다. \t    View menuView = menuWindow.getDecorView(); \t    mListMenuLayout.addView( menuView ); \t \t    // 6. 리스트 메뉴 아이템이 클릭되었을 때 호출되는 리스너를 등록한다. \t    ListMenuActivity listActivity = (ListMenuActivity)mLocalActivityMgr.getActivity( \"ListMenuActivity\" ); \t    listActivity.setOnListItemClickListener( new ListMenuActivity.OnListItemClickListener() \t    { \t        @Override \t        public void onItemClick( Intent viewerIntent, String viewerId ) \t        { \t            // 클릭된 아이템의 해당하는 액티비티를 넘겨받은 인텐트로 실행한다. \t            Window viewerWindow = mLocalActivityMgr.startActivity( \t                                                viewerId, viewerIntent ); \t            \t            // 실행된 액티비티 레이아웃을 참조하여 액티비티그룹 우측영역에 추가한다. \t            View    viewerView  = viewerWindow.getDecorView(); \t            mViewerLayout.removeAllViews(); \t            mViewerLayout.addView( viewerView ); \t        } \t    }); \t} }       컨테이너격인 ActivityGroup을 상속받는 Activity에 추가할 액티비티의 View들이 보일 영역을 만든다.   추가할 Activity를 LocalActivityManager를 통해 실행한다.   생성된 Activity의 View를 얻어낸다.   해당 View를 원하는 위치에 Add한다.   추가한 액티비티에서 같은 화면상의 다른 액티비티를 실행 또는 조작하려면 컨테이너인 ActivityGroup을 상속받은 Activity에서 해야 하므로 Listener를 달아준다.      참고로 ActivityGroup에 Activity를 포함하여 보여주는것은 Activity라는 컴포넌트가 추가된 형태가 아니다. 그냥 액티비티의 뷰 영역을 가져와 현재 뷰컨테이너에 Add하는 것이다.    2. ActivityGroup의 장점  결국 ActivityGroup을 사용하고자 하는 것은 코드를 잘 분리하여 각각의 컴포넌트로 관리하기 위함일 것이다. ActivityGroup안에 Activity를 포함한다는 것은 이러한 점에서 매우 편리하다. &lt;/br&gt;  심지어 개별 Activity로 동작하면서 ActivityGroup안에도 넣을 수 있다는 점은 큰 장점이다.   3. ActivityManager 란.  원래 ActivityManager는 안드로이드 시스템 서비스이다. 안드로이드에서 모든 액티비티는 ActivityManager가 관리를 한다. 여기서 관리란 액티비티의 생명주기 및 테스크 관리 등을 말한다.  그리고 각 액티비티들은 서로 다른 프로세스이기 때문에 ActivityManager에서 Activity간의 데이터 통신에는 바인더 통신을 한다. &lt;/br&gt;   4. LocalActivityManager 란.  LocalActivityManager는 ActivityGroup이 가지고 있다. ActivityGroup내에 속한 액티비티들을 관리하는 내부 관리자인것이다. ActivityManager는 다른 프로세스에 있는 액티비티들을 관리하기 때문에 바인더 통신을 하는데, LocalActivityManager는 같은 프로세스 내부이기 때문에 바인더 통신을 하지 않는다.   5. ActivityGroup과 Activity의 문제  ActivityGroup은 API 13부터 deprecated 되었다. 그 이유는 여러가지가 있는데 간단하게 말하면 다음과 같다.      ActivityGroup역시 Activity인데 기존 Activity와 다르게 동작하는 부분이 생김.   ActivityGroup 내부에 포함되는 Activity의 개념이 모호해짐.   5.1. ActiityGroup의 문제  안드로이드의 모든 Activity는 시스템 서비스인 ActivityManager에 의해 관리된다. Activity의 일종인 ActivityGroup 역시 마찬가지다. &lt;/br&gt;   ActivityGroup은 내부의 액티비티를 관리하기 위한 LocalActivityManager를 가지고 있다. 따라서 ActivityGroup내에서 액티비티 관리는 안드로이드 서비스인 ActivityManager가 아닌 LocalActivityManager의 영향을 받는다. &lt;/br&gt;   원래 안드로이드에서는 타 앱(타 앱의 액티비티)를 실행시킬 수 있고, 이건 ActivityManager가 바인더 통신을 하기 때문에 가능한 것이다. 그런데 LocalActivityManager는 바인더 통신을 하지 않는다. 따라서 ActivityGroup은 다른 액티비티를 실행시키거나 포함할 수 없다.      만약 타 액티비티를 실행하거나 포함하려고 하면 java.lang.SecurityException 이 발생한다.    5.2. ActivityGroup안에 포함된 Activity 개념 문제  A라는 Activity 가 있는데 이 Activity가 ActivityGroup안에 포함되었을 때 과연 이것도 Activity라고 말을 할 수 가 있는가? &lt;/br&gt;  ActivityGroup내에 포함된 A는 그 안에서 레이아웃과 생명주기만을 지원하기에 완벽한 Activity라고 하기 모호하다. (기존 Activity의 속성은 모두 ActivityGroup에 귀속되어 버리기 때문에 ..)   예를 들어 여러 액티비티를 실행하면 하나의 테스크가 생성되고 내부에 순서대로 액티비티 스택이 형성된다.  그런데 ActivityGroup안에서 순서대로 Activity를 생성하여 추가한다고 해서 액티비티 스택이 형성되지 않는다. (테스크 자체를 관리하지 않는다.)   또한 액티비티 스택이 존재하지 않기 때문에 액티비티간 데이터 전달도 불가능 하다. (startActivitForResult 로 데이터 전달 못함)   6. Fragment 의 탄생 이유   사실 ActivityGroup안에 있는 Activity에게 바라는 것은 많지 않다!! &lt;/br&gt;  필요한 것은 별도의 소스로 분리된 액티비티의 레이아웃과 생명주기가 필요할 뿐!!   단지 이것을 위해 무거운 Activity를 ActivityGroup안에 넣는것은 효율적이지도 않고, 개념도 모호하다.   Fragment는 바로 이러한 요건을 충족시키기 위해서 탄생한 것이다.     ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/ActivityGroup/",
        "teaser": null
      },{
        "title": "Bundle과 Intent",
        "excerpt":"   프로세스간 통신에 대해서는 IPC, RPC, Binder에 대해서 포스팅을 참고할 것.    1. Bundle  Bundle은 IPC(Inter Process Communication)을 지원하기 위한 Android의 클래스이다.    Bundle은 Parcelable을 구현하고 있어 직렬화 할 수 있다.     1.1. 왜 Bundle이 필요한가.  서로 다른 Process간 객체를 전달하기 위해서는 두 프로세스 모두 해당 객체를 알고 있어야 한다.    또한, 객체가 수정이 되면 해당 클래스 파일을 다시 배포해 줘야 하는 문제도 생긴다     이에 반해 Bundle은 안드로이드 SDK에 포함되어 있는 직렬화 객체이다.    즉, 안드로이드에서 돌아가는 모든 서비스는 이미 Bundle을 알고있고, 수정에 따른 재배포 문제도 생기지 않는다.     1.2. Bundle의 특징  Bundle의 내부는 Map으로 구성되어 있다. 즉, 키와 값으로 되어 있어 다른 프로세스에 전달하려는 값을 map에 저장하는 방식으로 전달할 수 있다.   물론 키는 전달받는 프로세스에서 미리 알고 있어야 한다.   2. Intent  Bundle과 마찬가지로 Intent역시 Pacelable을 구현하고 있어 직렬화 할 수 있다.     Bundle과 Intent의 차이는 Bundle은 단순히 데이터 전달을 위한 직렬화 객체라면 Intent는 시스템 서비스간 약속된 데이터를 저장하여, 특정 컴포넌트를 실행하고 원하는 데이터를 전달하기 위한 “의도” 라는 점이다.    (기본적으로 Activity 실행, Service 실행, Broadcast 전달에 사용함)   Intent-filter란 앱의 Manifest파일에 들어 있는 표현으로, 해당 구성 요소가 수신하고자 하는 인텐트의 유형을 나타낸다. 인텐트 필터를 전혀 선언하지 않으면 명시적 인텐트로만 시작할 수 있다.   2.1. 명시적, 암시적 Intent   2.1.1. 명시적 Intent (implicit intent)  요청을 위한 안드로이드 component를 이름을 통해 명시적으로 지정함. 일반적으로 동일한 앱 내에서 다른 component를 실행할때 사용한다.   2.1.2. 암시적 Intent (explicit intent)  요청을 위한 component 이름을 명시하지 않고, 수행할 작업만을 명시하여 이 작업을 수행 할 component를 찾아서 수행하게 한다.    암시적 Intent를 수행하면 안드로이드 시스템은 모든 앱의 manifest파일을 뒤지고 각 component의 intent-filter를 찾는다.    만약 매칭되는 intent-filter를 찾으면 해당 component를 수행한다. 매칭되는 component가 여러개라면 어떤 component를 실행할지 사용자에게 묻는 dialog를 표시하고 사용자가 선택한 component를 수행한다.      주의     Service는 암시적 인텐트로 사용하지 않는것이 좋다. Service는 눈에 보이지 않기 때문에 암시적으로 수행하면 보안 위험이 있다. Android 5.0(api 21)부터는 암시적 인텐트로 서비스를 실행하면 exception이 발생한다.   2.2. Intent의 의미를 부여하는 정보                  분류       멤버변수       설명       설정을 위한 메서드                       컴포넌트 정보       String mPackage, ComponentName mComponent       요청을 위한 component의 이름으로 명시적 인텐트를 위한것. 즉 명식적으로 컴포넌트를 지정하고 이 정보가 없으면 암시적 인텐트이다.       Intent 생성자, setComponent(), setClass(), setClassName()                 액션       String mAction       수행할 작업으로 동작을 설명하기 위해 미리 정의한 문자열. 예를 들어 “전화를 건다”, “메일을 발송한다” 등으로 암시적 인텐트를 보낼때 해당 Action을 받을 수 있는 컴포넌트들이 응답한다.       Intent 생성자, setAction()                 카테고리       HashSet mCategories       component의 종류에 대한 추가정보를 담은 문자열. 예를 들어 런처에서 앱 아이콘을 클릭했을 때 실행되는 액티비티는 android.intent.category.LAUNCHER이라고 지정되어 있는 액티비티이다.   안드로이드의 기본 내장 앱(브라우저, 주소록, 달력, 이메일, 갤러리, 지도, 메시지, 음악)의 경우 별도로 지정된 카테고리가 있다.       addCategory()                 데이터 위치, 타입       Uri mData, String mType       URI는 실행될 컴포넌트가 특정 경로 데이터를 필요로 할 경우 사용된다. (예를 들어 음악실행시 음악파일의 경로)  때론 URI외에 데이터 타입을 지정하는게 유용할 수있다. 예를 들어 이미지표시와 오디오파일 재생은 URI 형식이 비슷하지만 서로 다른 작업을 하는 동작이다. 이 때 타입을 지정해두면 안드로이드 시스템이 최적의 component를 찾는데 도움이 된다.       URI만 설정 시 setData() , 타입만 설정 시 setType() , 둘다 설정시 setDataAndType()                 엑스트라       Bundle mExtras       각종 컴포넌트 실행시 데이터를 전달하기 위한 용도       putExtra(), putExtras()                 플래그       int mFlags       각종 컴포넌트를 제어하기 위한 플래그       setFlags(), addFlag()              setData(), setType()은 각각쓰면 안된다. 서로 덮어쓰기 때문에 함께 쓸때는 꼭 setDataAndType()을 쓰자.    2.3. 예제  아래 예제는 안드로이드 기본 계산기 앱을 실행한다.    (Action, Category를 이용한 암시적 인텐트)    // 아래는 앱을 실행했을때 제일 먼저 실행되는 액티비티를 보여달라는 것.  // 해당 앱의 카테고리가 LAUNCHER인 액티비티를 실행한다.  intent.setAction(Intent.ACTION_MAIN);    // 카테고리에 계산기를 지정했다.  intent.addCategory(Intent.CATEGORY_APP_CALCULATOR);    startActivity(intent);   아래 예제는 웹브라우저를 통해 사이트를 연다.     (Action, Uri를 이용한 암시적 인텐트)    // 어떤 데이터를 보여달라고 하는 Action으로 Data에 따라 다른 액티비티가 실행.  intent.setAction(Intent.ACTION_VIEW);  intent.setData(Uri.parse(\"http://naver.com\"));  startActivity(intent);   아래 예제는 MP3를 재생한다.    (Action, Uri, DataType을 이용한 암시적 인텐트)    intent.setAction(Intent.ACTION_VIEW);  // \"file:///\" 은 단말기 내부의 파일이라는 뜻.  String mp3Path = \"file:///\" + (mp3 파일 위치);  // \"audio/*\" 는 모든 포맷의 오디오 파일이라는 뜻.  intent.setDataAndType(Uri.parse(mp3Path), \"audio/*\");  startActivity(intent);   2.4. 암시 Intent로 실행되기 위한 컴포넌트 등록  Manifest에 &lt;intent-filter&gt;가 암시적 컴포넌트의 등록을 위한 부분이다.   2.4.1. action, category    &lt;intent-filter&gt;      &lt;!-- 이미지를 보여주는 기능을 함. --&gt;      &lt;!-- \"action.ACTION_IMAGE_VIEW\"는 사실 임의로 지정한 값이다. --&gt;         &lt;!-- 실제로는 android.intent.action.VIEW 를 사용하자. --&gt;      &lt;!-- 임의로 지정한 값은 외부에서도 알고있어야 하기 때문에 특정 용도에 쓴다.--&gt;         &lt;action android:name=\"action.ACTION_IMAGE_VIEW\" /&gt;            &lt;!-- DEFAULT 지정이 되어 있어야 암시적 Intent로 실행이 가능함. --&gt;         &lt;category android:name=\"action.intent.category.DEFAULT\" /&gt;  &lt;/intent-filter&gt;   DEFAULT 카테고리를 추가하는 이유는 Intent 객체에 default로 category가 DEFAULT로 지정이 되어있기 때문이다.  따라서 만약 DEFAULT 카테고리를 intent-filter에 추가하지 않으면 해당 Intent를 컴포넌트가 받을 수 없다.   안드로이드에서 DEFAULT 카테고리의 유무는 암시적 인텐트를 받을 수 있는 컴포넌트인지를 구별할 수 있기도 하다.   2.4.2. data  URI를 통해 어떤 암시적 Intent를 받았는데 URI에서도 특정 값에 해당하는 URI만 받고자 할 때 쓸 수 있다. (잘쓰지는 않는것 같다.)   예를 들어 A 라는 홈페이지를 열때만 내 앱의 컴포넌트를 활성화 시키고 다른 홈페이지는 무시하고 싶은 경우 활용 가능하다.    &lt;intent-filter&gt;      &lt;action android:name=\"action.ACTION_IMAGE_VIEW\" /&gt;      &lt;category android:name=\"action.intent.category.DEFAULT\" /&gt;            &lt;data           android:scheme=\"http\"           android:host=\"www.superdroid.com\"           android:port=\"80\"           android:path=\"/files/images/aaa.png\"           android:mimeType=\"image/png\" /&gt;  &lt;/intent-filter&gt;       위와같이 intent-filter가 등록되어 있을 경우 Uri가 위와 정확히 일치해야 암시적 인텐트에 대해 실행된다.  위와같이 정적인 path말고 pathPrefix나 pathPattern 속성을 이용하면 유연하게 대처할 수 있다.   2.5. 암시적 인텐트를 명시적으로 실행하기  암시적 인텐트로 던지면 안드로이드에서 해당 Action과 Category를 받을 수 있는 모든 컴포넌트가 반응하며, 이 때 다이얼로그를 통해 유저가 선택할 수 있다.   하지만 암시적 인텐트임에도 불구하고 내가 원하는 컴포넌트만 반응하길 원할 수 있는데 이를 위해 package 지정 방법이 있다.    intent.setPackage(\"com.superdroid.test\");  위와 같이 intent에 package를 지정하면 해당 패키지의 컴포넌트만 한정할 수 있다.   2.6. Intent의 Extra  Intent에서 Extra는 순수 데이터로 Bundle로 되어 있다.   따라서 primitive 데이터 및 직렬화된 객체를 저장할 수 있다.   2.7. Intent의 Flag  컴포넌트 실행 시 제어하거나 상태를 변경하는 등의 목적으로 사용된다.  예를 들어..   Intent.FLAG_ACTIVITY_NO_ANIMATION 는 액티비티 실행시 애니메이션을 사용하지 않는다.        [참고 문서]           안드로이드 가이드       도서 “이것이 안드로이드다”       ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/Bundle,-Intent/",
        "teaser": null
      },{
        "title": "Fragment에 대해서",
        "excerpt":"   Fragment를 사용해본적이 있으나 왜 Fragment를 사용하는지 잘 모르는 분들께 유용할것 같습니다.    안드로이드에서 프레그먼트는 액티비티와 마찬가지로 별도의 레이아웃을 가지며 독자적인 LifeCycle을 가진다. 프레그먼트는 액티비티보다 좀 더 유연하여 액티비티 내에 포함될 수 있다.   1. Fragment가 나오기 까지..  기기의 성능이 좋아지고, 화면이 커지면서 하나의 화면에 들어가는 앱 기능이 많아졌다.    그 결과 한 Activity나 View에 많은 코드가 들어가는 경우가 늘어났고, 코드상 이를 나누고자 하는 노력이 필요했다.   View와 ViewGroup &gt; include &gt; ActivityGroup &gt; Fragement           View와 ViewGroup     레이아웃을 만들때는 Java코드로 개발하지 않고 뷰와 뷰그룹만으로도 만들 수 있다.     때론 특별한 기능의 View는 개발자가 CustomView로 코드 분리하여 만들 수 있다.            include     include 속성을 이용하면 xml 코드도 분리할 수 있다.     하지만 include는 공통적인 레이아웃을 모아서 중복을 줄일 수 있다는 장점 이외에는 없다.            ActivityGroup     ActivityGroup을 이용하면 한 화면에 여러 액티비티를 보여줄 수 있어 기존보다 훨씬 강력한 방법으로 화면 구성이 가능하다.            Fragment     Fragment는 기존 ActivityGroup의 단점을 개선한 것이다. 보다 완벽하게 화면을 분리하고 유연하게 대처할 수 있다.       1.1. ActivityGroup  ActivityGroup은 하나의 Activity에 여러개의 Activity를 포함할 수 있게 해준다. ViewGroup이 View를 가질수 있듯 ActivityGroup은 Activity를 가질 수 있다.     참고로 ActivityGroup 역시 Activity이다. 여러 Activity를 포함할 상위 Activity는 ActivityGroup을 상속받는다.     ActivityGroup을 사용하면 하나의 화면에 전환해야할 뷰가 여러개 존재할 때 각각의 뷰를 별도의 액티비티 단위로 나눌 수 있기 때문에 관리하기가 좋다.   하지만 ActivityGroup은 자체가 Activity로의 기능을 제대로 수행하지 못하는 문제도 있고, 내부에 포함되는 Activity의 개념이 모호해 진다는 단점이 존재한다.      ActivityGroup은 Deprecated 되었다. 관련 내용은 ActivityGroup에 대해서 포스팅을 참고할 것.    2. Fragment 기초  최초 ActiityGroup이 필요했던 이유는 액티비티가 너무 커지면서 이를 분리하여 관리하고자 필요가 있었기 때문이다. Fragment는 이를 완벽하게 대체한다.   Fragment를 쉽게 설명하면 별도의 뷰그룹인데 액티비티처럼 일정부분 필요한 생명주기가 존재한다. 생명주기가 자체적으로 존재하기 때문에 액티비티가 모든 생명주기를 관리할 필요가 없다는 장점이 있다.   Fragment를 Activity에 포함한다는 것은 간단하게 Activity의 뷰컨테이너에 Fragment의 뷰를 포함한다는 의미다.   FragmentActivity는 기존 Activity의 생명주기뿐 아니라 포함된 Fragment의 생명주기도 같이 호출해준다는 점이 차이가 있다.   FragmentActivity내에는 FragmentManager가 존재하여 Fragment의 추가,삭제,변경 등을 담당한다.   참고로 Fragment를 중첩하여 사용할 수도 있다. 이 때는 Fragment가 Fragment를 관리해야 하는데 이 때문에 FragmentManager 뿐 아니라 ChildFragmentManager 가 존재한다.   2.1. Fragment 의 구조   public class TextViewerFragment extends Fragment {   \t// 텍스트 뷰어 프래그먼트 객체를 생성하는 함수다. \tpublic static TextViewerFragment newInstance() { \t    TextViewerFragment f = new TextViewerFragment(); \t    return f; \t} \t    \t// 부모 액티비티는 해당 프래그먼트를 구동하고, 액티비티에 추가될 프래그먼트의 레이아웃을 onCreateView 함수의 반환값으로 요구한다. \t// 따라서 해당 프래그먼트는 onCreateView 재정의 함수에서 자신의 레이아웃을 생성하고 반환한다. \t@Override \tpublic View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState ) { \t    return inflater.inflate( R.layout.fragment_text_viewer, container, false); \t} }   코드의 onCreateView()를 보면 알겠지만 결국 액티비티의 뷰그룹에 Fragment의 뷰를 포함하는 형태이기 때문에 Fragment에서 View를 리턴해 준다.   아래는 Activity의 XML 이다.   &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" \tandroid:layout_width=\"match_parent\" \tandroid:layout_height=\"match_parent\" \tandroid:orientation=\"horizontal\"&gt;    \t&lt;!-- ① 좌측 영역에 메뉴 리스트 프래그먼트를 설정한다. --&gt;  \t&lt;fragment class=\"com.superdroid.fragment.ListMenuFragment\" \t    android:id=\"@+id/menu_fragment\" \t    android:layout_width=\"0dp\" \t    android:layout_height=\"match_parent\" \t    android:layout_weight=\"1\"/&gt; \t    \t&lt;!-- ② 우측 영역에 텍스트뷰어 혹은 이미지뷰어 프래그먼트를 포함할 프래그먼트 컨테이너다. --&gt; \t&lt;FrameLayout android:id=\"@+id/viewer_fragment_container\" \t    android:layout_width=\"0dp\" \t    android:layout_height=\"match_parent\" \t    android:layout_weight=\"1\"/&gt;   &lt;/LinearLayout&gt;   좌측에는 고정된 Fragment를 배치하기에 그대로 Fragment를 배치하였고, 우측은 여러 Fragment를 교체할 것이기 때문에 FrameLaout을 둔것이다.   여기서 중요한점은 레이아웃 구조에 View나 ViewGroup이 아닌 fragment가 포함이 될 수 있는가를 봐야한다.    xml을 보면 마치 fragment가 view나 viewGroup처럼 레이아웃 구조에 포함이 된것처럼 보이는데 fragment는 view나 viewGroup이 아니다.    단지 안드로이드에서 xml을 해석하는 중 fragment 를 만나면 해당 fragment를 생성하고 fragment의 레이아웃을 view에 그리게 된다.    일종의 include 와 동일하다.   2.2. FragementActivity의 구조   public class MainActivity extends Activity {     @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);         // ② 액티비티 레이아웃 우측에 텍스트뷰어 프래그먼트를 추가한다.     // ====================================================================     TextViewerFragment textViewerFragment = TextViewerFragment.newInstance();     getFragmentManager().beginTransaction().add( R.id.viewer_fragment_container, textViewerFragment ).commit();      // ③ 액티비티 레이아웃 좌측에 리스트 메뉴 프래그먼트에서 아이템을 선택했을 때     // 이벤트를 처리하기 위한 리스너를 구현 및 등록한다.           ListMenuFragment listMenuFragment = (ListMenuFragment)getFragmentManager().findFragmentById(R.id.menu_fragment );       listMenuFragment.setOnListItemClickListener(new ListMenuFragment.OnListItemClickListener() {     \t@Override \t\tpublic void onItemClick( int itemType ) { \t\t\t// ④ 액티비티 우측 영역 프래그먼트 컨테이너에 현재 보여지고 있는 프래그먼트를 참조한다.  \t\t\t//    만일 선택된 아이템이 현재 보여지고 있는 프래그먼트라면 아무 처리도 하지 않고 끝내고,  \t\t\t//    아니라면 보여줘야 할 프래그먼트를 생성해둔다. \t\t\tFragment fragment = getFragmentManager().findFragmentById( R.id.viewer_fragment_container );                 \t\t\tif( itemType == ListMenuFragment.ITEM_TYPE_TEXT_VIEWER) { \t\t\t\tif( fragment instanceof TextViewerFragment == true ) { \t\t\t\t\treturn; \t\t\t\t}   \t\t\t\tfragment = TextViewerFragment.newInstance(); \t\t\t}else if( itemType == ListMenuFragment.ITEM_TYPE_IMAGE_VIEWER ) { \t\t\t\tif( fragment instanceof ImageViewerFragment == true ) { \t\t\t\t\treturn; \t\t\t\t}                 \t\t\t\tfragment = ImageViewerFragment.newInstance(); \t\t\t}    \t\t\t// ⑤ 선택된 아이템에 해당하는 프래그먼트를 액티비티 우측에 배치한다. \t\t\tgetFragmentManager().beginTransaction().replace( R.id.viewer_fragment_container, fragment ).commit();         }     }); }   xml에 포함되어 있으면 findViewById()로 인스턴스를 만들 수 있다. 그렇지 않고 동적인 경우면 그냥 인스턴스 만들면 된다.   3. FragmentTransaction  Fragment의 관리는 FragmentManager가 담당한다. 하지만 레이아웃에 Fragment를 추가, 제거, 교체하는데는 꼭  FragmentTransaction을 통하여 수행한다.      뷰의 동작을 transaction으로 관리하는 이유는 효율과 관련이 있다. 예를 들어 A, B fragment가 있는데 A를 생성하고, B를 생성하고 이중 A만 보여주기 위해 B를 숨긴다고 가정하자.   Transaction으로 관리되지 않으면 A를 보여주고, B를 보여주고, B를 숨기고 하는 일련의 과정에 대해 다 화면 업데이트를 해줘야 한다. 하지만 연속적인 화면 업데이트를 따로 하는것은 비 효율적이므로 Transaction으로 묶어 한번에 처리하는 것이다.   실제로 FragmentTransaction 내부에는 큐가 있다.   (주의) FragmentTransaction의 commit() 시점에 대해 주의하자!!       commit()을 한다고 바로 적용이 되는게 아니다. 예를 들어 다음 코드는 정상 작동하지 않는다.   // ① 프래그먼트를 프래그먼트매니저에 추가한다. getFragmentManager() \t.beginTransaction() \t.add(R.id.viewer_fragment_container,textViewerFragment, \"TEXT_VIEWER\") \t.commit();   // ② 프래그먼트매니저에 추가한 프래그먼트를 찾아 참조한다. TextViewerFragment textViewerFragment = (TextViewerFragment) getFragmentManager(). findFragmentByTag( \"TEXT_VIEWER\" );    이 코드에서 두번째 TextViewerFragment 는 null 을 리턴한다.   그 이유는 Transaction 처리를 메인스레드의 메시지큐에 추가하기 때문이다. 큐에 유입된 메시지는 메인스레드의 루퍼가 유입된 순서대로 처리한다. 따라서 메인스레드의 루퍼가 프래그먼트 트랜잭션을 처리해줄 때까지 기다려야한다.   참고로 그 시점은.. commit()한 생명주기 함수 다음 부터이다. 예를 들어 onCreate()에서 commit()을 했다면 이후인 onStart()부터 FragmenetManager에서 해당 fragment를 찾을 수 있다.   4. Fragment 제어를 위한 여러 함수들  Fragment를 다루기 위해 여러 함수가 존재하는데, 화면 보기에 비슷하지만 확실히 다르게 동작하기에 주의해야 한다.      add(int containerViewId, Fragment fragment)             프래그먼트 추가. (실제로 fragment를 추가하는 기능은 add 밖에 없다.)           remove(Fragment fragment)             추가된 프래그먼트 삭제. FragmentManager의 관리 목록에서 완전 지운다.           replace(int containerViewId, Fragment fragment)             추가된 프래그먼트를 새로운 프래그먼트와 교체(내부적으로 remove -&gt; add 가 순차적으로 호출)           detach(Fragment fragment)             추가된 프래그먼트의 레이아웃을 떼어냄 (fragment자체는 유지하면서 레이아웃만 지우는 방식이다.)           attach(Fragment fragment)             detach 함수로 떼어낸 프래그먼트 레이아웃을 다시 붙임 (이전 fragment의 상태는 유지하면서 화면을 다시 그리게 된다. 참고로 attach는 add와 다르다. 반드시 add 이후 detach된 fragment에 대해서만 attach가 가능하다)           hide(Fragment fragment)             프래그먼트의 레이아웃을 숨김 (fragment와 layout 모두 유지하면서 단순히 레이아웃을 숨기는 것이다.)           show(Fragment fragment)             hide 함수로 숨겨진 프래그먼트 레이아웃을 다시 보여줌.           setRetainInstance(boolean retain)            화면전환과 같이 Activity 다시 create 될때 fragment 인스턴스를 그대로 유지할지 여부이다. 설정되고 나면 Activity가 재생성될때의 프레그먼트의 lifecycle 메서드 콜백이 달라진다.       onDetach()는 호출되지만 onDestroy()는 호출되지 않는다.       액티비티가 재생성될때 onCreate()는 호출되지 않는다.       하지만 onAttach(), onActivityCreated() 는 호출된다.              각 함수별로 기능이 다르기 때문에 제대로 확인하고 써야 한다.    5. Fragment의 ID와 TAG  fragment를 다루려면 상황에 따라 FragmentManger가 관리하는 특정 fragment의 instance를 가져와야 하는데 원하는 fragment를 찾는데 id와 tag를 이용한다.   id는 일반적으로 xml에 명시된 @+id/~~~~ 이다. 정적으로 레이아웃에 포함된 fragment는 이렇게 ID를 가질 수 있으므로 다음 함수로 찾을 수 있다.     FragmentManger.findFragmentById(int id)    하지만 동적으로 추가되는 fragment는 별도의 ID를 가질 수 없다. 아니, id를 가질 수 있는데, fragment가 포함된 컨테이너의 ID를 가진다.(예를 들어 FrameLayout의 ID)    문제는 해당 컨테이너에 여러개의 Fragment가 포함되었다면 모두 같은 ID를 가져 구분을 할 수 없다. (물론 instanceOf로 찾을수는 있지만..)     이럴 때 TAG를 이용한다. add() 함수를 보면 parameter로 Tag를 줄 수 있는데. 이 때 등록한 Tag를 다음 함수로 찾을 수 있다.     FragmentManager.findFragmentByTag(String tag)    6. Fragment의 BackStack  ActivityGroup을 이용하면 backstack를 가질 수 없지만 fragment는 FragmentManagr에 의해 backstack를 가질 수 있다. (FragmentManager 내부에 별도의 backStack을 가지고 있다. 백스택에 등등록된 하나의 트랜잭션은 backStackRecord라 불린다.)   Fragment 백스택의 단위는 Transaction 실행 단위이다.   Fragment를 사용한다고 무조건 backStack를 사용할 수 있는것은 아니며 FragmentTransaction의 다음 함수를 사용해서 스택을 등록한다.     FragmentTransaction.addToBackStack(String tag)    예를 들어 다음과 같다.     getFragmentManager()  .beginTransaction()  .hide( imageViewerFragment )  .show( textViewerFragment )  // 백스택을 위해 해당 트랜잭션을 저장한다.  .addToBackStack( \"TEXT_VIEWER_BACKSTACK\" )  .commit();   BackStack에 등록된 후 “뒤로가기”를 하면 등록된 Transaction의 반대 동작을 한다. 각 함수별 반대 동작은 아래와 같다.        add() &lt;-&gt; remove()   attach() &lt;-&gt; detach()   show() &lt;-&gt; hide()   BackStatck에서 하나의 BackStackRecord를 꺼내는 동작은 popBackStack()를 통해 할 수 있다. 뒤로가기 버튼도 이걸 호출하는 것이다. 꺼낼때 특정 record를 꺼낼 수도 있는데, 이 때 parameter는 addToBackStack()를 할때 입력했던 이름이다. 참고로 별도로 pop하는 backStackRecord의 순서를 조작할 일이 없다면 add할때 이름을 null로 줘도 된다.   6.1 BackStack 사용시 주의할점  BackStack의 단위가 Transaction이라는 점을 유의해야 한다. 이걸 잘못 사용하면 예상하지 못한 결과가 나타난다.     예를 들어 다음과 같은 경우..      A fragment를 숨기고 B fragment를 보여준다.   한번더 실행 되어 마찬가지로 A fragment를 숨기고 B fragment 를 보여준다.        이 경우 화면은 그냥 B가 그대로 보이는 형태가 됨. 이 상태에서 뒤로가기를 누르면?? 정상적인 동작은 한번 뒤로가기 누르면 그대로 B가 보여지고, 한번 더 뒤로가기를 누르면 A가 보여져야 한다.     하지만 실제로는 2번째 transaction의 반대 동작이 A를 보여주고, B를 숨기는 것이기 때문에 예상했던것과 다르게 B가 보여지는게 아니라 A가 보여진다.     즉, 예상한 뒤로가기 동작은 B &gt; A 이지만 실제로는 A &gt; A 가 된다.    이러한 실수를 방지하기 위해서는 Fragment의 현재 상태를 확인해야 할 필요가 있다. 다음과 같이 확인이 가능하다.   if( itemType == ListMenuFragment.ITEM_TYPE_TEXT_VIEWER &amp;&amp; textViewerFragment.isVisible() == false ) { \tgetFragmentManager() \t.beginTransaction() \t.hide( imageViewerFragment ) \t.show( textViewerFragment ) \t.addToBackStack( \"TEXT_VIEWER_BACKSTACK\" ) \t.commit(); }      isVisible()과 같이 Fragmenet의 상태를 확인하는 다양한 함수가 있다.    6.2 BackStackChangeListener  BackStack에 변화가 일어날때를 감지하기 위한 BackStackChangeListener가 존재한다. 필요하면 다음과 같이 쓴다.   getFragmentManager().addOnBackStackChangedListener(this); getFragmentManager().removeOnBackStackChangedListener(this);   7. Fragment 의 LifeCycle  슈퍼드로이드                  lifeCycle       설명                       onAttach       프래그먼트가 액티비티 레이아웃에 추가될 때 호출된다. 그리고 이 함수가 호출되었다는 것은 프래그먼트매니저가 해당 프래그먼트의 관리를 시작한다는 의미다.                 onCreate       프래그먼트 객체가 최초 생성될 때 호출된다. 따라서 이 함수에서 프래그먼트 내부에 필요한 각종 클래스들을 생성 및 초기화하면 된다. 그리고 이 함수가 호출되었다는 것은 프래그먼트 객체가 새로 생성됨을 의미한다. 반대로 호출되지 않았다면 기존에 프래그먼트 객체가 존재하여 재사용된 것이다. 일반적으로 프래그먼트를 add하면 호출 되어야 하지만 기존 백스택에 해당 프래그먼트가 존재하면 호출되지 않는다.                 onCreateView       액티비티에서 프래그먼트의 레이아웃을 요청할 때 호출된다. 따라서 해당 함수에서 프래그먼트 레이아웃을 생성하여 반환해야 한다. 그리고 이 함수가 호출되었다는 것은 프래그먼트의 레이아웃이 새로 생성됨을 의미한다.                 onActivityCreated       프래그먼트를 포함하고 있는 액티비티 onCreate 생명주기 함수가 호출된 후 호출된다. 따라서 액티비티의 onCreate 과정 이후에 처리해야할 일이 있다면 이 함수에서 처리하면 된다.                 onStart       프래그먼트 레이아웃이 화면에 표시될 때 호출된다. 단 아직 사용자와 상호작용은 할 수 없는 상태다.                 onResume       사용자와 상호작용도 할 수 있는 상태다.                 onPause       사용자와 상호작용을 할 수 없는 상태다.                 onStop       프래그먼트 레이아웃이 화면에서 사라질 때 호출된다.                 onDestroyView       액티비티에서 프래그먼트의 레이아웃을 제거할 때 호출된다. 따라서 해당 함수가 호출되면 화면에는 프래그먼트 레이아웃이 존재하지 않는다.                 onDestory       프래그먼트 객체가 소멸될 때 호출되는 함수다.                 onDetach       프래그먼트가 액티비티 레이아웃에서 제거될 때 호출된다. 그리고 이 함수가 호출되었다는 것은 프래그먼트매니저가 더 이상 해당 프래그먼트를 관리하지 않는다는 의미다.              간단히 말하면.. Fragment라는게 원래 완벽히 분리된 뷰의 개념으로 볼 수 있다.   완벽히 분리가 가능하려면 스스로 상태를 관리할 수 있어야 하기에 생명주기가 있다. 그리고 이 생명주기는 결국 이 뷰를 관리할 액티비티에 영향을 받기 마련이다.   Fragment는 add상태, attach상태, show상태 등 액티비티보다 상태가 다양하기 때문에 좀더 많은 생명주기 함수가 존재한다. 하지만 결국 기본 개념은 뷰 자체로의 생명주기를 가지고 있고, 이 뷰가 포함된 액티비티의 생명주기에 영향을 받는다는 점은 다르지 않다.   물론 일반적인 View 는 생명주기를 따로 관리하지 않기 때문에 이렇게 생명주기를 Activity와 함께 맞춰줘야 하는 Fragment의 사용은 좀 더 어려운 측면이 있다.   7.1. 중요한 항목만 정리     Activity와 연계되어 Fragment가 생성될때는 Activity 라이프라이클이 먼저 호출되고 Fragment 라이프사이클이 호출된다.    (Activity의 onStart() -&gt; Fragment의 onStart(), Activity의 onResume() -&gt; Fragment의 onResume() )   하지만 제거될때는 Fragment의 라이프사이클이 먼저 호출된다.    (Fragment의 onPause() -&gt; Activity의 onPause(), Fragment의 onStop() -&gt; Activity의 onStop())           Activity가 동작중일때 Fragment를 add하거나 remove하면 Activity의 라이프사이클 변화 없이 Fragment 라이프사이클만 변화한다. 위 그림의 프레그먼트 add, remove 이다.              만약 Fragment를 add하거나 remove할때 백스텍에 추가한다면 위 그림에서 프레그먼트 attach, detach와 같아진다.    백스택에 추가하는 것이 fragment 자체를 없애는 것이 아니기 때문이다.            Activity, Fragment가 동작중일때 Fragment를 hide 시키면 생명주기 변화가 없다. 단, onHiddenChange() 메서드가 호출된다.       8. Fragment의 상태 복원  생명주기가 존재하는 Activity에서 상태를 복원하기 위해 Bundle savedInstanceState가 사용되는데, Fragment역시 마찬가지다.   Fragment 생명주기에서 onPuase()뒤에 무조건 onSavedInstanceState(Bundle outState)가 호출된다. 여기에 저장된 Bundle값은 Fragment 생명주기 3군대에서 호출된다. 3군대에 호출되는 내용은 모두 동일한데 개발자가 적당한 위치에서 가져다 쓰라는 것이다.      onCreate(Bundle savedInstanceState)   onCreateView(Bundle savedInstanceState)   onActivityCreated(Bundle savedInstanceState)   그리고 Activity도 마찬가지지만 저장하는 Bundle값은 시스템 프로세스에 저장한다. 상태 복원이라는것 자체가 이미 기존 상태를 잃어버린다는 것이기 때문에 해당 프로세스에 값을 보관할 수 없다. 다른 프로세스에 저장을 한다는 것은 바인더 통신을 한다는 의미다. 따라서 Bundle에 저장할 수 있는 값은 프리미티브 타입이거나 직렬화가 가능한 객체여야 한다.   8.1. Fragment의 추가시 주의해야 할 점과 savedInstanceState의 활용  보통 Activity의 onCreate()에서 Fragment를 add()하는데.. 이 때 주의할 점이 있다.  바로 화면 회전과 같이 onCreate()를 다시 탈때 Fragment를 중복으로 add()할 수도 있다는 점이다. 이를 방지하기 위해 Activity의 savedInstatnceState()를 활용한다.   @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     ...       // savedInstanceState 번들이 널이라는 것은 해당 앱이 강제 종료 후     // 재시작된 것이 아니라는 의미다. 따라서 이 경우 화면 좌측의 텍스트뷰어     // 프래그먼트를 추가해준다.     // 참고로 만일 savedInstanceState 번들이 널이 아니라면 강제 종료 후     // 재시작하는 과정이므로 텍스트뷰어 프래그먼트를 추가하면 안된다.     // 그 이유는 프래그먼트매니저가 자동으로 해당 프래그먼트를 생성 후 추가해주기     // 때문이다.     if( savedInstanceState == null ){         getFragmentManager()         .beginTransaction()         .add( R.id.viewer_fragment_container, mTextViewerFragment, \"TEXT_VIEWER\")         .commit();     }   9. Fragment 생성 시 주의할점  Fragment 생성시 넘겨야 하는 파라미터가 있을때 아래와 같은 방법들을 사용할 수 있을것이다.      팩토리 메서드를 사용하는 방법    MyFragment.newInstance(parameter);  class MyFragment { \tpublic static MyFragment newInstance(String parameter){ \t\tMyFragment instance = new MyFragment(); \t\tBundle bundle = new Bundle(); \t\tbundle.putExtra(\"PARAMETER\"M parameter); \t\tinstance.setArguments(bundle); \t\treturn instance; \t} }      생성자를 사용하거나 setter를 사용하는 방법   // 생성자를 통해 전달하는 방법 MyFragment myFragment = new MyFragment(parameter);  // setter 메서드를 사용하는 방법 MyFragment myFragment = new MyFragment(); myFragment.setParameter(parameter);  class MyFragment { \tprivate String mParam; \t \tpublic MyFragment(String parameter){ \t\tthis.mParam = parameter; \t} \t \tpublic void setParameter(String parameter){ \t\tthis.mParam = parameter; \t} }   위 내용중 2번째 방법(생성자를 이용, setter를 이용)은 조심해야 한다.    메모리 부족 시 LMK(Low Memory Killer)에 의해 Activity가 강제종료 될수 있는데 이후 재생성될때 해당 파라미터를 찾을 수 없기 때문이다.     물론 onSavedInstanceState()를 통해 명시적으로 저장할 수 있지만 애초에 Bundle에 저장해서 넘길 경우 굳이 onSavedInstanceState()에서 전달받은 파라미터를 저장하지 않아도 된다.    (당연히… 상태가 변한다면 변경된 값을 저장해야 겠지만..)   또 주의할 점은.. Fragment가 자동으로 재생성될때는 default 생성자가 호출된다.    만약 위의 예처럼 파라미터 없는 default 생성자가 없을 경우 런타임 에러가 발생한다.   아래는 구글 가이드에 적혀있는 내용이다.       All subclasses of Fragment must include a public empty constructor. The framework will often re-instantiate a fragment class when needed, in particular during state restore, and needs to be able to find this constructor to instantiate it. If the empty constructor is not available, a runtime exception will occur in some cases during state restore.    10. android-support-v4 라이브러리  Fragment 는 API 레벨이 11 이상이면 사용이 가능하지만 그 이하는 지원하지 않는다.  11 이상일때는 Activity에 이미 Fragment를 다루는 기능이 있지만 그 이상을 지원하기 위해서는 support-v4 라이브러리를 이용한다.   support-v4 라이브러리에서는 Activity가 아니라 FragmentActivity를 상속받아 사용하여야 한다.    ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/android/about_fragment",
        "teaser": null
      },{
        "title": "IPC, RPC, Binder에 대해서",
        "excerpt":"   Thread와 Process에 대해서는 안드로이드의 Thread와 Process 포스팅을 참고할 것.    리눅스는 서로 다른 프로세스의 메모리 영역에 접근할 수 없다. 따라서 직접적으로 함수를 불러오는 것이 불가능하다.     이것을 가능하게 하기 위해서는 커널의 공유메모리를 사용하여 프로세스간 통신을 해야 하는데 안드로이드는 이를 위해 바인더 프레임워크 (Binder framework)를 만들었다.   바인더에는 프로세스간 통신을 가능하게 하는 IPC(Inter Process Communication) 기술과 프로세스간 함수를 호출하는 RPC(Remote Procedure Call) 기술을 적용했다.   1. 안드로이드의 RPC  리눅스 OS에서는 IPC 기술을 지원하는 signal, pipe, message queue, semaphores, shared memory 이용해 IPC를 지원한다.     안드로이드의 변형 리눅스 커널에서 IPC는 RPC매커니즘을 수행하는 바인더 프레임워크로 대체되었다.     바인더 프레임워크를 이용하면 클라이언트 프로세스는 마치 로컬에서 메서드를 실행하듯이 서버 프로세스의 원격 메서드를 호출할 수 있다.   전체 과정은 아래와 같다.      Process A에서 Process B에 있는 method(int, int)를 호출   Process A에서 RPC 기술을 이용해 method(int,int)를 분해하여 직렬화(마샬링-marshalling)   IPC 기술을 이용해 커널의 공유메모리를 통해 프로세스간 통신   Process B에서 RPC 기술을 이용해 method(int,int)를 조립(언마샬링-unmarshalling)   Process B에 있는 method(int,int)를 실행   2. 바인더 프레임워크가 필요한 이유  안드로이드에서 리눅스 커널이 기본적으로 제공하는 소켓, Pipe 등과 같은 IPC를 사용하지 않고 바인더 메커니즘을 새로 만든 이유는 성능 때문이다.   모바일 기기를 지원하기 위한 안드로이드의 모든 시스템 기능은 프로세스로 제공된다.    예를 들어 내가 만든 응용프로그램에서 Android SDK가 제공하는 위치 정보를 얻는 API를 호출할 때 내부적으로는 Location 서비스를 제공하는 Linux 프로세스로 요청을 보내고 결과를 응답받아 처리한다. 카메라를 사용할 때도 마찬가지로 Camera 서비스와 상호 연동한다.      이렇게 Android의 모든 시스템 기능이 서버 프로세스로 제공되기 때문에 프로세스 사이에 최적화된 통신 방법이 필요하고 그 고민의 결과가 바인더이다.   3. 바인더  바인더는 앱이 다른 프로세스에서 실행되는 스레드들 사이에 메서드 호출을 보낼 수 있게 한다.     서버 프로세스는 android.os.Binder 클래스에서 지원되는 원격 인터페이스를 정의하고, 클라이언트 프로세스 안의 스레드는 원격 객체를 통해서 이 원격 인터페이스에 접근할 수 있다.         함수와 데이터를 모두 전송하는 원격 프로시저 호출을 트랜잭션 이라고 부른다.     위 그림과 같이 클라이언트 프로세스가 transact() 메서드를 호출하면 서버 프로세스는 onTransact() 메서드를 통해 호출을 받는다.   기본적으로 transact()를 호출하는 클라이언트 프로세스의 쓰레드는 메서드 호출 후 onTransact() 호출이 완료될때까지 차단되기 때문에 동기로 동작하게 된다.   3.1. Parcel 객체  트랜잭션 데이터는 android.os.Parcel 객체로 구성된다.   이 객체는 리터럴 파라미터와 android.os.Parcelable을 구현한 커스텀 객체를 포함할 수 있는데  Parcelable 인터페이스는 Serializable보다 효율적인 방법으로 마샬링, 언마샬링을 지원하게 한다.   3.2. Transaction Thread pool  서버 프로세스에서 onTransact() 메서드는 Binder Thread pool에 속한 스레드에서 실행된다.    이 바인더 쓰레드는 프로세스간 통신을 위해서만 사용하는 쓰레드이다. OS 버전에 따라 다를 수 있지만 풀은  최대 16개의 쓰레드를 가지고 있어 총 16개의 원격 호출이 동시 처리될 수 있다.   3.3. 비동기 Transaction  바인더 통신은 기본적으로는 동기로 동작하는데 IBinder.FLAG_ONEWAY flag를 설정하여 비동기로 호출할 수도 있다.     이 때 클라이언트 쓰레드는 tranact() 메서드 호출 시 즉시 반환받는다. 서버 프로세스의 쓰레드는 onTransact() 메서드 호출을 받지만 클라이언트 쓰레드에게 어떤 데이터를 동기적으로 반환해줄 수는 없다.   3.4. 같은 앱 내에서의 Bind 통신  만약 같은 앱 내부에서 bindService를 사용하게 되면 Binder Thread를 사용하지 않는다. Binder thread는 프로세스간 통신을 위한것인데 같은 프로세스 내라면 이와 같은 불필요한 작업 없이도 가능하기 때문이다.   이같은 경우 aidl 파일도 필요없고 그냥 LocalBinder를 만들어 주면 된다.   4. AIDL  앱에 바인더를 만드는것은 복잡한 작업인데 이를 쉽게 하기 위해 안드로이드는 인터페이스 정의 언어인 AIDL(Android Interface Definition Language)을 제공하고, 이 언어로 인터페이스를 작성하면 자동으로 바인더를 생성해준다.   즉, 앱에서 AIDL을 정의해두면 컴파일 시 바인더 프레임워크를 랩핑하는 자바 코드를 자동으로 생성한다.(gen 폴더에 생성됨)   aidl 파일은 Interface를 정의하는것처럼 서비스가 제공하는 함수를 정의하면 되고, 파일은 꼭 .aidl로 생성해야 한다.    참고로 aidl파일을 바인더 클래스로 생성해주는 작업은 Android SDK에 포함된 aidlTool이다.   4.1. Proxy, Stub을 통한 원격 프로시저 호출  AIDL로 바인더 클래스를 자동 생성하면 내부에 Inner클래스로 Stub과 Proxy 클래스가 존재한다.        Proxy : 클라이언트에서 실행되는 코드로 호출하려는 함수를 분해(마샬링)하여 전송한다.   Stub : 서버에서 실행되는 코드로 제공하려는 함수를 조립하여(언마샬링) 호출한다.      4.2. 동기식 RPC  간단한 예를 통해 동기식 RPC를 이해한다.           AIDL 정의         interface ISynchronous {       String getThreadNameFast();       String getThreadNameSlow(long sleep);       String getThreadNameBlocking();       String getThreadNameUnblock();   }                서버 프로세스에서 Stub 클래스 오버라이드         private final ISynchronous.Stub mBinder = new ISynchronous.Stub() {       CountDownLatch mLatch = new CountDownLatch(1); \t\t       @Override       public String getThreadNameFast() throws RemoteException {           return Thread.currentThread().getName();       } \t\t\t       @Override       public String getThreadNameSlow(long sleep) throws RemoteException {\t\t           SystemClock.sleep(sleep);           return Thread.currentThread().getName();       } \t\t       @Override       public String getThreadNameBlocking() throws RemoteException {           mLatch.await();           return Thread.currentThread().getName();       } \t\t       @Override       public String getThreadNameUnblock() throws RemoteException {           mLatch.countDown();           return Thread.currentThread().getName();       }   }                클라이언트 프로세스에서 원격 메서드 호출         ISynchronous mISynchronous = ISynchronous.Stub.asInterface(binder);   String remoteThreadName = mISynchronous.getThreadNameFast();   Log.d(TAG, \"Thread Name : \" + remoteThreadName);   // 결과는 \"Thread Name : Binder_1\" 출력됨.                          빨리 리턴하는 작업 호출    getThreadNameFast() 호출은 즉시 리턴되므로 호출하는 클라이언트는 아주 잠깐 block 되고 바인더 쓰레드는 효율적으로 재활용 될 수 있다.            시간이 오래걸리는 작업 호출    getThreadNameSlow(sleep) 호출은 요청받은 만큼 긴 시간동안 클라이언트가 block 된다. 이 때 오랫동안 하나의 바인더 쓰레드를 점유하게 되기 때문에 여러번 호출할 경우 쓰레드 풀이 한계에 이르게 된다.       쓰레드 풀이 한계에 다다르면 다음 원격 메서드 호출은 바인더 큐에 들어가게 되고 사용가능한 바인더 쓰레드가 있을때까지 실행을 기다리게 된다.      Block되는 메서드 호출     getThreadNameBlocking() 호출 시 바인더 쓰레드는 block 되고 클라이언트 쓰레드 역시 block된다.     이 호출만 여러번 되면 결국 쓰레드 풀이 한계에 다다르게 되는데 그러면 이 block을 풀어줄 getThreadNameUnblock()을 외부에서 호출해줄 수 없게 된다. 그럴 경우에는 block 된 쓰레드를 풀어주는 기능을 서버 프로세스 내부 쓰레드에 의존해야 한다.   그렇지 않으면 단말에서 원격 메서드를 호출하는 모든 클라이언트 쓰레드가 block된다.      원격 메서드 호출이 빠르게 리턴된다고 해서 클라이언트의 메인 쓰레드에서 호출하는것이 안전하다고 할 수는 없다. 서버 프로세스가 실행되는 시간을 단정지을 수 없기 때문이다.    4.3. 비동기식 RPC  동기식 RPC는 단순하고 구현하기 쉬운 장점이 있지만 호출하는 클라이언트 쓰레드가 차단될 수 있다는 위험이 있다.   비동기식 RPC를 사용하면 클라이언트가 자신의 비동기 정책을 구현하는 대신 원격 메서드 호출 자체를 비동기로 실행하도록 정의할 수 있다.   비동기로 실행 시 바인더는 서버 프로세스로 트랜잭션을 제공한 다음 클라이언트와 서버간의 연결을 닫는다.    즉, 서버 프로세스의 원격 메서드 호출 결과를 클라이언트에 전달할 수 없는데 이 때문에 원격 메서드는 반드시 void를 리턴해야 한다. 만약 결과를 전달하기 위해서는 콜백 구현을 사용해야 한다.   4.3.1. 비동기식 RPC 정의  비동기식 RPC는 oneway 키워드를 붙여 AIDL 안에 정의한다.    oneway는 인터페이스 단계에 정의할 수도 있고, 개별 메서드 단계에서 정의할 수도 있다.   oneway interface IAsynchronousInterface { \tvoid method1(); \tvoid method2(); }   interface IAsynchronousInterface { \toneway void method1(); \tvoid method2(); }   4.3.2. 비동기식 RPC의 콜백 구현  콜백을 보낸다는 것은 서버에서 클라이언트로 호출을 보내는 역방향 RPC를 의미한다.    이 역시 RPC이므로 콜백 인터페이스는 AIDL에 정의가 필요하다.           원격 메서드 AIDL 정의         interface IAsynchronous1 {       oneway void getThreadNameSlow(IAsynchronousCallback callback);   }                원격 메서드의 콜백 메서드 AIDL 정의         interface IAsynchronousCallback {       void handleResult(String name);\t   }                서버 프로세스에서 Stub 클래스 오버라이드         IAsynchronous1.Stub mIAsynchronous1 = new IAsynchronous1.Stub() {       @Override       public void getThreadNameSlow(IAsynchronousCallback callback) throws RemoteException {           SystemClock.sleep(10000);           String threadName = Thread.currentThread().getName();           callback.handleResult(threadName);       }   }                클라이언트 프로세스에서 콜백을 위한 Stub 클래스 오버라이드         IAsynchronousCallback.Stub mCallback = new IAsynchronousCallback.Stub() {       @Override       public void handleResult(String remoteThreadName) throws RemoteException {           Log.d(TAG, \"Remote thread Name : \" + remoteThreadName);           Log.d(TAG, \"Current thread Name : \" + Thread.currentThread().getName());       }   }           참고로 둘 다 동일한 쓰레드 이름이 출력될수 있지만 두 쓰레드는 각각 클라이언트 프로세스에 속한 바인더 쓰레드와 서버 프로세스에 속한 바인더 쓰레드이다.         바인더 콜백은 바인더 쓰레드에서 수신되니 콜백 구현이 클라이언트 프로세스의 다른 쓰레드와 데이터 공유가 필요하다면 thread safe에 주의해야 한다.         [참고 문서]           네이버 개발자 블로그       도서 “이것이 안드로이드다”      도서 “Efficient Android Threading”        ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/android/about_ipc_rpc_binder",
        "teaser": null
      },{
        "title": "안드로이드 LMK(Low Memory Killer)",
        "excerpt":"안드로이드는 메모리가 부족할 때 다른 앱의 프로세스를 죽임으로써 메모리를 확보한다.    LMK는 앱 상태에 따라 우선순위를 매기고 가장 우선순위가 높은 앱의 프로세스부터 메모리가 확보될 때까지 하나씩 죽인다.    우선순위가 높다는 것은 현재 죽여도 큰 문제가 발생하지 않는 앱이라고 판단된 앱이다.     LMK 우선순위          시스템(PackageManager, ActivityManager 처럼 시스템 자체 프로세스)            시스템 앱 (단말 제조사에서 선탑재한 앱중 AndroidManifest.xml 파일 내 의 android:persistent 속성이 true로 설정한 앱이다. 예를 들어 전화, 메시지, 카메라 앱 등이다.)            가장 앞에 보이는 앱 (현재 실행중인 앱이다.)            뒤에 보이는 앱 (현재 실행한 앱이 화면 전체를 가리지 않고 뒤에 보이는 앱이다)            Forground Service로 사용자에게 지각되는 서비스 앱.(음악재생처럼 사용자에게 보여지지 않아도 인지되는 서비스이다.)            서비스 앱(일반 서비스이다.)            Launcher 앱(Launcher는 홈키를 통해 빈번하게 사용자에게 보여지는데 만약 죽게 되면 홈키를 누른 이후 런처가 보일때까지의 반응이 느리다.)            완전히 가려진 앱(다른 앱의 Activity에 의해 완전히 가려진 앱이다. 눈에 보이지 않기 때문에 LMK의 우선순위가 높다.)            종료된 앱(안드로이드에서 뒤로가기로 종료해도 앱의 Process까지 종료되는 것은 아니다. 이유는 사용자가 다시 앱을 실행할 때 최대한 빨리 앱을 구동시켜 주기 위함이다.)          1~5까지는 강제 종료되면 사용자가 바로 인지할 수 있기 때문에 우선순위가 매우 낮다. 시스템에서는 이를 Forground Process라 부르고, LMK에 의해 왠만하면 죽지 않는다.    LMK와 OOM Killer  안드로이드는 기본적으로 리눅스 커널을 사용하는데 리눅스에서도 메모리 부족시 메모리 확보를 위한 Out Of Memory Killer가 존재한다.     하지만 리눅스 커널은 안드로이드에서 실행되는 앱 프로세스 중 어떤것이 중요한지에 대한 우선순위를 판단할 수 없어 안드로이드는 별도의 LMK를 개발하였고, 안드로이드 시스템 서비스인 ActivityService에서 동작한다.  ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/LMK(Low-Memory-Killer)/",
        "teaser": null
      },{
        "title": "Looper, MessageQueue, Handler",
        "excerpt":"   Thread, 프로세스간 통신에 대한 내용은 아래 포스팅을 참고할 것           Java의 Thread       안드로이드의 Thread와 Process      1. 안드로이드의 Message Handling  자바에서 Thread간 통신하는 방법에는 pipe, shared memory, blocking queue 등 여러가지가 있다.     이 방법들은 안드로이드에서 역시 그대로 사용할 수 있지만 모두 쓰레드가 block 될 수 있다는 문제가 있다. Work Thread는 상관 없지만 UI Thread가 block될 경우 사용자 반응성이 저하된다.    이러한 점 때문에 안드로이드에서 UI Thread에 대해서는 nonblocking 소비자-생산자 패턴 모델을 사용한다.     Message Handling은 thread간 메세지(데이터) 통신방법에 대한 것이고, 이는 안드로이드 플랫폼의 핵심 내용으로 android.os 패키지에서 제공하고 있다.   1.1 Message handling 매커니즘  안드로이드 message handling은 아래 4가지를 통해 이뤄진다.           android.os.Looper     Looper는 message dispatcher로서, 하나의 소비자 thread에서 동작한다.            android.os.Handler     Handler의 경우 소비자 thread의 message 처리역할 및 생산자 thread가 MessageQueue에 Message를 넣을 수 있도록 하는 interface를 제공한다.            android.os.MessageQueue     MessageQueue는 크기제한이 없는 Linked List이다. 모든 Looper는 하나의 MessageQueue만 가질 수 있다.            android.os.Message      Message는 임의의 데이터나 객체를 담는 객체로 소비자 쓰레드에서 실행될 내용을 담고있다.       1.2. 전체 과정 간략 정리 (중요)  우선 안드로이드의 제약 조건을 보자면 다음과 같다.      UI thread는 block 되면 안된다.   UI 변경은 UI thread에서만 할 수 있다.   안드로이드 메세지 핸들링 과정은 이러한 제약조건을 지키기 위한 nonblocking 소비자-생산자 패턴을 구현한 것이다.        원래 소비자-생산자 패턴에 따르면 생산자 thread는 데이터를 생산하기만 하고 소비자 thread는 만들어진 데이터를 소비하기만 한다. 그리고 생산자와 소비자 사이에 만들어진 데이터를 관리하기 위한 공유메모리 영역이 있는데 이 공유 메모리에 대한 생산자 thread와 소비자 thread의 점유 문제 때문에 thread가 block이 된다.    아래는 Work thread에서 메인 thread로 UI 변경을 요청하는 과정이다.         메인 thread 입장에서..            메인 thread는 소비자 thread이다.       소비자 thread는 내부에 Looper를 가지고 있는데 Looper는 MessageQueue를 가지고 있다.       MessageQueue는 말 그대로 Message를 가지고 있는 Queue이고 Message는 실행과 관련된 데이터 객체이다.       소비자 thread가 가지고 있는 Looper의 역할은 무한 루프를 돌면서 MessageQueue에 있는  Message를 하나씩 꺼내 dispatch한다.           Work thread 입장에서..            Work thread는 생산자 thread이다.       생산자는 요청 데이터(ui를 변경하겠다는 요청)를 만든 뒤 소비자에게 전달해줘야 한다.       이러한 요청이 Message 이다.       그리고 요청을 전달하는 역할은 Handler가 한다.       즉, 생산자 thread인 Work thread는 소비자 thread인 메인 thread에게 Message를 전달해야 하는데 이 때  Handler를 통해서 전달하는 것이다.       Handler의 경우 소비자 thread인 메인 thread에게서 얻어와야 한다.           Handler 입장에서..            핸들러는 내부에 멤버로 Looper를 참조하고 있다.       즉, 메인 thread로 부터 얻어온 Handler는 내부에 메인 Looper를 알고있다.       Work thread에서 Message를 전달받으면 Handler는 자기가 참조하고 있는 메인 Looper의 MessageQueue를 통해 Message를 추가한다.           메인 thread가 Message를 꺼내고 난 뒤..            메인 thread의 Looper에 의해서 Message가 꺼내지고 나면 아래의 dispatch 과정을 거친다.       참고로 Handler를 통해 MessageQueue에 Message를 넣는 과정은 생산자 thread인 Work thread에서 동작하지만, 자체적으로 무한루프를 도는 Looper에 의해 Message가 꺼내지고 dispatch되는  과정은 소비자 thread인 Main thread에서 동작한다.       Message는 내부에 멤버로 자기를 전달한 Handler를 참조하고 있다.       이 Handler의 handleMessage() 메서드를 호출한다.       이 동작은 이미 메인 thread에서 동작하고 있기 때문에 UI 변경을 정상적으로 할 수 있다.           2. MessageQueue  android.os.MessageQueue에 정의된 메시지큐는 단방향 Linked List로 구현되어 있다.    메세지큐는 생산자 Thread가 추가한 Message가 차례대로 dispatch되서 소비자 Thread에서 실행될수 있게 한다.   메세지큐에 추가되는 Message는 timestamp에 따라서 정렬된다.    만약 timestamp가 현재 시간 이전이라면 바로 dispatch되고, 미래라면 dispatch하지 않고 대기를 하게 된다.         t1은 dispatch 될 것이고, t2,t3는 대기할 것이다.    만약 더이상 처리할 Message가 없다면 thread는 block 되고, 다시 Message가 추가되면 실행된다. (단 UI thread는 block 되지 않는다.)   2.1. MessageQueue.IdleHandler  처리할 메세지가 없을때 Thread는 block되고 유휴 시간을 가지게 된다.    이 시간동안 MessageQueue.IdleHandler를 사용하면 다른 작업을 처리할 수 있다.   // 현재 Thread의 MessageQueue를 얻는다. MessageQueue msgQueue = Looper.myQueue(); // 리스너 드록 MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler(); msgQueue.addIdleHandler(idleHandler); // 리스너 해제 msgQueue.removeIdleHandler(idleHandler);   IdleHandler는 하나의 메서드만 가지는 interface이다.   interface IdleHandler { \tboolean queueIdle(); }      return true : IdleHandler를 계속 유효한 상태로 둬서 콜백을 받을 수 있다.   return false : IdleHandler를 해제한다. MessageQueue.removeIdleHandler() 와 동일한 역할을 한다.      IdleHandler는 딱히 어디서 쓰면 좋은지는 잘 모르겠다.    3. Message   android.os.Message 클래스는 컨테이너 객체로서, 데이터나 task를 전달하는데 사용된다. Message의 파라미터로는 여러 가지가 있는데, 정리하면 다음과 같다.                  Name       Type       Description                       what       int       메시지 식별자                 arg1, arg2       int       정수값을 전달하는 경우에 사용되는 간단한 데이터 값. 정수 데이터를 전달하는 경우 Bundle(data)을 전달하는것보다 효율적이다.                 obj       Object       임의의 객체. 다른 프로세스로 전달될 때는 반드시 Parcelable로 구현해야 한다.                 data       Bundle       임의의 데이터 값들을 가지는 컨테이너                 replyTo       Messenger       다른 프로세스의 핸들러를 참조한다. 프로세스간 통신을 가능하게 한다.                 callback       Runnable       스레드에서 실행할 task. Handler.post()에서 전달한 Runnable 객체를 담고있는 내부 인스턴스 변수이다.           3.1. 메세지의 두가지 형태  메세지는 두가지 형태가 있다.      어떤 동작 자체(Task)인 Runnable(파라미터로는 callback)을 가지는 테스크 메세지   데이터인 arg, obj, data를 가지는 데이터 메세지   테스크 메세지의 경우 동작 자체를 가지고 있기 때문에 다른 데이터 파라미터들은 아무 의미가 없다.     소비자 스레드에서 Looper에 의해 Message Queue에 있는 메세지가 처리될때 메세지가 테스크 메세지인 경우 Runnable 객체를 실행시키고, 데이터 메세지인 경우 Handler.handleMessage(Message msg)에서 처리할 수 있도록 한다.    (테스크 메시지인 경우 handleMessage가 호출되지 않는다.)   3.2. 메세지의 생명주기  메세지의 lifecycle은 간단하다.    생산자 스레드에서 메시지를 생성 및 초기화하고 소비자 스레드에서 처리된다.   참고로 메세지는 Message pool이 따로 있고 안드로이드 런타임에 의해 재활용된다.    따라서 매번 새로운 메세지 인스턴스를 생성하는 오버헤드를 피한다.      3.2.1. 초기화 상태  메세지 객체가 생성된 상태. 메세지 객체는 다양한 방법으로 생성할 수 있다. (3.3. 메세지의 생성 참고)   3.2.2. 대기 상태  메세지가 생산자 스레드에 의해 Message Queue에 삽입되었고, dispatch되기를 기다리고 있는 상태(pending 상태)   3.2.3. 전달 상태  메세지는 루퍼에 의해 Message Queue에서 가져와지고 Message 객체가 참조로 가지고 있는 Handler를 이용해 메세지를 전달한다.(dispatch 과정) 전달된 메세지들은 소비자 스레드에서 실행된다.     3.2.4. 재활용 상태  메세지 상태가 해제되고 Message pool에 인스턴스가 반환된다. 메세지 객체의 재활용은 런타임에 의해 제어되므로 앱이 명시적으로 수행할 수는 없다.   3.3. 메세지의 생성           명시적인 생성      Message m = new Message();            empty 메세지      Message m = Message.obtain();            데이터 메세지      Message m = Message.obtain(Handler h);      Message m = Message.obtain(Handler h, int what);      Message m = Message.obtain(Handler h, int what, Object o);      Message m = Message.obtain(Handler h, int what, int arg1, int arg2);      Message m = Message.obtain(Handler h, int what, int arg1, int arg2, Object o);              테스크 메세지      Message m = Message.obtain(Handler h, Runnable task);            복사 생성자      Message m = Message.obtain(Message originMsg);       4. Looper  루퍼는 내부적으로 무한루프를 돌면서 Message Queue에 있는 메세지를 관련된 Handler로 발송하는 일을 한다.      일반적으로 쓰레드는 무한루프를 돌고있지 않는 한 내부 작업이 끝나면 종료된다. 안드로이드에서 앱을 실행했을때 아무 동작을 하지 않아도 종료되지 않는 이유는 메인 쓰레드의 메인루퍼에 의해 무한루프를 돌고 있기 때문이다. 메인 쓰레드 외에 다른 쓰레드 역시 루퍼를 사용할 경우 루퍼를 종료하지 않는다면 쓰레드가 종료되지 않는다.       아래는 루퍼의 구현 코드이다.   public class Looper{      private Looper(boolean quitAllowed) {         mQueue = new MessageQueue(quitAllowed);         mRun = true;         mThread = Thread.currentThread();     } \t \tprivate static void prepare(boolean quitAllowed) { \t\t// 쓰레드는 오직 하나의 루퍼만 가질 수 있다.  \t\tif (sThreadLocal.get() != null) { \t\t\tthrow new RuntimeException(\"Only one Looper may be created per thread\"); \t\t} \t\tsThreadLocal.set(new Looper(quitAllowed)); \t}      public static void loop() {         final MesssageQueue queue = me.mQueue;         for(;;) {             Message msg = queue.next();             ...             // target은 메세지 객체가 참조하고 있는 Handler 이다.             msg.target.dispatchMessage(msg);             ...         }     } }   참고로 쓰레드는 오직 하나의 루퍼만 가질 수 있다. 만약 쓰레드에 이미 루퍼가 설정되어 있는데 다시 설정하려고 하면 RuntimeException이 발생한다.    위 코드를 보면 메세지큐를 루퍼가 생성하기 때문에 결국 한 쓰레드에는 메세지 큐 역시 하나만 가진다는걸 알 수 있다.   msg.target.dispatchMessage(msg)가 호출될때 메세지가 dispatch되는데 만약 전달 경계(dispatch barrier)를 넘은 메세지가 없다면 blocking이 되고 기다리게 된다.      이게 이해가 안된다.. 안드로이드는 nonblocking 소비자-생산자 패턴이라고 했다. 그런데 여기서 block 된다는게 무슨 의미인가.. 그럼 UI 쓰레드도 block 되는건가? 아니면 UI 쓰레드만 별게인가?    4.1. Looper의 설정   class ConsumerThread extends Thread{ \tpublic void run() { \t\tLooper.prepare(); \t\t... \t\tLooper.loop(); \t} }   Looper.prepare()를 통해 현재 쓰레드의 루퍼와 메세지큐가 생성된다.    Looper.loop()가 호출되면 무한루프를 돌면서 메세지를 처리한다.   4.2. Looper의 종료  아래 두 메서드를 통해 종료할 수 있다.           quit()     전달 경계(dispatch barrier)를 통과한 Message를 포함, MessageQueue의 모든 pending 메시지를 삭제한다.            quitSafely (api 18)     전달 경계를 넘지 않은 메세지만 삭제한다.       Looper를 제거한다고 thread가 제거되는 것은 아니다. 하지만 무한 루프를 멈추기 때문에 그 스레드에서 더 이상의 작업이 없으면 자연스럽게 제거된다.   루퍼 종료 후에는 기존 루퍼나 새로운 루퍼를 다시 설정할 수 없다. 즉, 해당 쓰레드에서는 더이상 메세지를 처리할 수 없다.   4.2. UI 쓰레드의 Looper  메인 쓰레드의 경우 처음 생성될때 기본적으로 Main Looper를 함께 생성하기 때문에 별도로 설정하는 과정이 필요없다.    UI 쓰레드의 Looper는 다른 쓰레드의 Looper와 차이가 있다.      Looper.getMainLooper()를 통해 어디서든 접근할 수 있다.   종료시킬 수 없으며 Looper.quit()가 호출되면 RuntimeException이 발생한다.   런타임은 Looper.prepareMainLooper()를 통해 메인쓰레드에 루퍼를 연결하는데 이 메서드는 단 한번만 호출될 수 있다. 따라서 메인 루퍼를 다른 쓰레드에 부착하려 하면 Exception이 발생한다.   5. Handler  핸들러는 안드로이드 쓰레드 통신에서 핵심 요소로 메세지의 추가(insertion)와 처리(processing)를 모두 담당한다.     5.1. Handler의 설정  핸들러는 항상 특정 쓰레드와 연결되어 있어야 하고, 해당 쓰레드에는 메세지를 담을 수 있는 MessageQueue와 메세지를 전달해줄 Looper가 존재해야 한다.     만약 루퍼가 없는 상태에서 핸들러 객체를 생성하면 RuntimeException이 발생한다.     아래는 Handler의 코드 일부이다.   // 루퍼를 받지 않는 생성자. public Handler() { this(null, false); } public Handler(Callback callback) { this(callback, false); } public Handler(boolean async) { this(null, async); }  public Handler(Callback callback, boolean async) { \tif (FIND_POTENTIAL_LEAKS) { \t\tfinal Class&lt;? extends Handler&gt; klass = getClass(); \t\tif ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { \t\t\tLog.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); \t\t}     } \t \t// 핸들러 생성시 루퍼를 명시적으로 받는것이 아니라면 현재 쓰레드의 루퍼와 연결된다. \tmLooper = Looper.myLooper(); \tif (mLooper == null) { \t\tthrow new RuntimeException(\"Can't create handler inside thread that has not called Looper.prepare()\"); \t} \tmQueue = mLooper.mQueue; \tmCallback = callback; \tmAsynchronous = async; }  // 루퍼를 명시적으로 받는 생성자. public Handler(Looper looper) { this(looper, null, false); } public Handler(Looper looper, Callback callback) { this(looper, callback, false); } public Handler(Looper looper, Callback callback, boolean async) {     mLooper = looper;     mQueue = looper.mQueue;     mCallback = callback;     mAsynchronous = async; }    위 코드를 보면 알수있듯 루퍼를 명시적으로 설정하지 않는 경우 Looper.myLooper() 를 통해 현재 쓰레드의 루퍼를 연결하려고 하는데 루퍼가 없으면 RuntimeException이 발생한다.     즉, 메세지큐와 루퍼를 생성하는 Looper.prepare() 호출 이전에 핸들러를 생성하려 하면안된다.   final MessageQueue mQueue; final Looper mLooper;   핸들러 class에서 Looper와 MessageQueue는 final로 선언되어 있다.    즉, 한번 설정된 루퍼가 다른 루퍼로 변경될 수 없다.   5.2. Handler와 쓰레드의 관계  하나의 쓰레드에 루퍼와 메세지큐는 하나만 가질 수 있지만 Handler는 여러개를 가질 수 있다.    서로 다른 Handler를 참조하고 있는 메세지들이 같은 메세지큐안에 있을 수 있는데, dispatch될때 자신의 Handler 객체를 통해 처리된다.      5.3. 메세지의 생성  Message를 설명할때(3.3. 메세지의 생성) 메세지 객체를 생성하는 여러가지 팩토리 메서드가 있다고 했는데, Handler 클래스에는 이를 랩핑하는 메서드가 있다.    이를 통해 좀 더 간결하게 메세지 객체를 생성할 수 있다. (메세지의 Handler가 자동으로 연결됨)   Message obtainMessage() Message obtainMessage(int what) Message obtainMessage(int what, Object obj) Message obtainMessage(int what, int arg1, int arg2) Message obtainMessage(int what, int arg1, int arg2, Object obj)   5.4. 메세지의 삽입  핸들러는 메세지 유형(Data 메세지, Task 메세지)에 따라 여러 방식으로 MessageQueue에 메세지를 추가한다.   Task 메세지는 접두사로 post가 붙은 메서드를 통해 삽입되고, Data 메세지는 접두사로 send가 붙은 메서드를 통해 삽입된다.           MessageQueue에 Task 메세지 추가     boolean post(Runnable r)     boolean postAtFrontOfQueue(Runnable r)     boolean postAtTime(Runnable r, Object token ,long uptimeMillis)     boolean postAtTime(Runnable r, long uptimeMillis)     boolean postDelayed(Runnable r, long delayMillis)              MessageQueue에 Data 메세지 추가   boolean sendMessage(Message msg)     boolean sendMessageAtFrontOfQueue(Message msg)     boolean sendMessageAtTime(Message msg, long uptimeMillis)     boolean sendMessageDelayed(Message msg, long delayMillis)              MessageQueue에 간단한 Data 메세지 추가    boolean sendEmptyMessage(int what)      boolean sendEmptyMessageAtTime(int what, long uptimeMillis)      boolean sendEmptyMessageDelayed(int what, long delayMillis)         참고로 명시적인 uptime이나 delaytime이 설정되어 있어도 각 메세지 처리시간은 여전히 불명확하다.   처리 시간은 먼저 처리해야 하는 기존 메세지들과 운영체제의 스케줄링에 좌우된다.   5.5. 메세지 dispatch  핸들러가 메세지를 처리할때는 메세지의 유형이나 Callback여부에 따라서 다르게 처리된다.    아래는 Handler에 있는 dispatchMessage메서드이다.      Looper.loop() 코드 중 msg.target.dispatchMessage(msg)에 의해 호출됨.    // 이 메서드는 루퍼에 의해 호출된다. public void dispatchMessage(Message msg) { \t \t// Task 메세지인 경우 \tif (msg.callback != null) { \t\thandleCallback(msg); \t} else { \t\t// Handler 생성시 Callback 인터페이스를 설정한 경우 \t\tif (mCallback != null) { \t\t\tif (mCallback.handleMessage(msg)) { \t\t\t\treturn; \t\t\t} \t\t} \t\t// 일반적인 Handler의 handleMessage() 메서드 호출됨. \t\thandleMessage(msg); \t} }  private static void handleCallback(Message message) { \tmessage.callback.run(); }  public interface Callback { \tpublic boolean handleMessage(Message msg); }      public void handleMessage(Message msg) { }   위 코드를 보면 메세지 dispatch 과정을 직관적으로 알 수 있다.    참고로 mCallback은 메세지가 아니라 Handler에 설정된 Callback interface인데 만약 callback이 설정된 경우 이 interface를 통해서도 메세지를 받을 수 있다.    이를 이용하면 아래와 같이 Handler 객체의 구현 없이 메세지를 받을 수 있다.   public class HandlerCallbackActivity extends Activity implements Handler.Callback { \tHandler mUiHandler; \t \t@Override \tpublic void onCreate(Bundle savedInstance) { \t\tsuper.onCreate(savedInstance); \t\tmUiHandler = new Handler(this); \t} \t \t@Override \tpublic boolean handleMessage(Message msg) { \t\t//메세지 처리 \t\t \t\t// return 값에 따라서 Handler.handleMessage(msg) 메서드의 호출 여부가 결정된다.  \t\treturn true; \t} }    이 방법말고 일반적으로 Handler의 handleMessage(msg)를 이용한 예는 아래와 같다.   public class MyActivity extends Activity{ \tprivate TextView mTv; \t \tprotected void onCreate(Bundle savedInstanceState) { \t\tsuper.onCreate(savedInstanceState); \t\tsetContentView(R.layout.my_activity); \t\tmTv = (TextView)findViewById(R.id.mTv); \t\t \t\tLog.i(\"Test\", \"Thread ID &gt; \" + Thread.currentThread().getId()); \t\tWorkThread workThread = new WorkThread(mHandler); \t\tworkThread.start(); \t} \t \t// 실제로는 이렇게 하면 memory leak이 발생할 수 있으니 다른 방식으로 구현. \tHandler mHandler = new Handler() { \t    public void handleMessage(Message msg) { \t        // UI 작업 가능  \t        mTv.setText(\"가능\"); \t        Log.i(\"Test\", \"Thread ID &gt; \" + Thread.currentThread().getId()); \t    } \t} \t \tclass WorkThread extends Thread() { \t    Handler handler; \t\t public WorkThred(Handler handler) { \t\t     this.handler = handler; \t\t } \t\t  \t    public void run() { \t    \t Log.i(\"Test\", \"Thread ID &gt; \" + Thread.currentThread().getId()); \t        Message msg = Message.obtain(handler); \t        handler.sendMessage(msg); \t    } \t} }    5.6. MessageQueue에서 메세지 제거  메세지큐에 삽입된 메세지는 루퍼에 의해 처리되기 전에 Handler를 통해서 제거할 수 있다.             Task 메세지 제거     removeCallback(Runnable r)     removeCallback(Runnable r, Object token)              Data 메세지 제거      removeMessages(int what)     removeMessages(int what, Object object)              Task 메세지, Data 메세지 모두 제거      removeCallbacksAndMessages(Object token)       Object를 이용하면 일종의 태그 형식으로 메세지큐에 삽입된 여러 메세지를 동시에 삭제할 수 있다.   5.7. View와 Activity가 가지는 Handler  View와 Activity는 자체적으로 하나의 Handler를 가지고 있다. 따라서 별도로 Handler 생성 없이 MessageQueue 에 메세지를 추가할 수 있다.     단, Handler의 handleMessage() 처리 방식은 Handler 생성 시에 override하여 정의하기 때문에 이 방법은 사용할 수 없고, Runnalbe 객체를 사용하는 Task 메세지만 사용할 수 있다.   5.7.1. View의 Handler  View에 사용하는 아래 두가지 메서드가 View의 Handler를 이용해 MessageQueue에 메세지를 추가하는 메서드이다.      View.post(Runnable action)   View.postDelayed(Urnnable action, long delayMillis)   이를 이용해서 다음과 같은 코드를 만들 수 있다.   TextView mTextView; Thread thread = new Thread() {     public void run() {              mTextView.post(new Runnable() {             public void run() {                 mTextView.setText(\"텍스트\");             }         });              } }    위와 같이 MainThread가 아닌 WorkThread에서 마치 View를 바로 수정하는 것처럼 코딩할 수 있다.   이런 경우 좀 더 직관적이라는 점에서 장점이 있는데 만약 위와 같이 하나의 View에 대한 수정이 아니라 여러 View를 수정하는 경우라면 별도의 Handler를 만들어 처리하거나 Activity의 Handler를 이용하는 것이 좋다.      View.getHandler()를 통해 Handler를 직접 참조할 수도 있다.    (주의) View의 Handler 사용 시 주의사항  View의 Handler는 Activity lifeCycle에서 onCreate(), onStart(), onResume() 이 모두 호출 된 이후에 참조가 가능하다. 그 이전에 사용하게 되면 에러가 발생하거나 동작하지 않을 수 있다.   5.7.2. Activity의 Handler  Activity에서 사용하는 아래 메서드는 Activity의 Handler를 이용해 MessageQueue에 메세지를 추가하는 메서드이다.   Activity.runOnUiThread(Runnable action)   이를 이용해 아래와 같은 코드를 만들 수 있다.   TextView mTextView, mTextView2; Thread thread = new Thread() {     public void run() {              MyActivity.this.runOnUiThread(new Runnable() {             public void run() {                 mTextView.setText(\"텍스트\");                 mTextView2.setText(\"텍스트2\");             }         });     } }   View의 Handler와 달리 액티비티에서 사용하는 여러 View를 갱신하고자 할때 직관적이다.   5.8. Handler의 Memory leak 이슈  아래와 같은 코드는 Memory leak 을 발생시킬 수 있다. 실제 개발 툴에서도 Android lint는 “In Android, Handler classes should be static or leaks might occur.” 와 같은 warning을 보여준다.   public class SampleActivity extends Activity {     private final Handler mLeakyHandler = new Handler() {     @Override     public void handleMessage(Message msg) {       // ...     }   }     @Override   protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);       // Post a message and delay its execution for 10 minutes.     mLeakyHandler.postDelayed(new Runnable() {       @Override       public void run() { }     }, 600000);       // Go back to the previous Activity.     finish();   } }   이 코드는 Handler와 Looper, MessageQueue, Message 의 구조상 Memory leak 이 발생할 수 있다.   Memory leak이 발생하는 재현 과정은 Looper의 MessageQueue에 처리할 Message가 들어가있는데 Activity가 종료될 때이다.   (위 코드와 같이 Handler에게 Message를 보낼때 지연(postDelayed)시켜 보내는 경우도 있고, MessageQueue에 많은 메세지가 들어가있어 아직 처리가 되지 않았을 수도 있다.)   MessageQueue에 들어있는 Message는 자신을 전달한 Handler에 대한 reference를 갖고 있고, 현재 위 코드에서 Handler는 Activity 아래 non-static Inner class로 선언되어 있어 Activity에 대한 reference를 가지고 있다.    따라서 Activity를 종료했음에도 불구하고, Looper의 MessageQueue에 있는 Message가 처리되기 전까지는 Activity Context가 Gargage Collect 될 수 없다.   5.9. Handler의 Memory leak을 방지하는 방법  위 예제에서 Handler는 Activity안에 non-static inner class로 선언되어 있는데, 이를 static inner class로 변경하면 leak을 방지할 수 있다.    (static class는 결국 별도로 존재하는 클래스 이기 때문에 Outer class인 Activity의 reference를 가지고 있지 않음)   하지만, Handler를  static class로 만들면 Handler 내부에서 접근할 수 있는 멤버가 Activity의 static 멤버 밖에 없으므로 문제가 된다.   이를 위해 Activity에 대한 참조를 WeakReference를 갖도록 하는 방식으로 수정한다.   public class SampleActivity extends Activity {     private static class MyHandler extends Handler {     private final WeakReference&lt;SampleActivity&gt; mActivity;       public MyHandler(SampleActivity activity) {       mActivity = new WeakReference&lt;SampleActivity&gt;(activity);     }       @Override     public void handleMessage(Message msg) {       SampleActivity activity = mActivity.get();       if (activity != null) {         // ...       }     }   }     private final MyHandler mHandler = new MyHandler(this);     /**    * Instances of anonymous classes do not hold an implicit    * reference to their outer class when they are \"static\".    */   private static final Runnable sRunnable = new Runnable() {       @Override       public void run() { }   };     @Override   protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);       // Post a message and delay its execution for 10 minutes.     mHandler.postDelayed(sRunnable, 600000);       // Go back to the previous Activity.     finish();   } }     [참고 문서]           참고 사이트       참고 사이트2 (Good)       도서 “이것이 안드로이드다”       도서 “Efficient Android Threading”       ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/Looper,-MessageQueue,-Handler/",
        "teaser": null
      },{
        "title": "Process와 Application Lifecycle",
        "excerpt":"   구글 문서 번역 입니다.    안드로이드 App은 리눅스 프로세스 위에서 구동된다.    프로세스는 실행이 필요한 Application의 코드가 있을때 생성되고 더 이상 필요하지 않으면서 다른 앱의 실행을 위해 메모리가 회수되어야 하기 전까지 유지된다.   안드로이드의 특징은 Application Process의 생명주기가 Application 자체에 의해 제어되지 않는다는 것이다.    Application의 생명주기는 시스템이 결정하는데 이 때 현재 실행중인 다른 Application Process와의 조합, Process가 사용자에게 얼마나 중요한지에 대한 정도, 시스템에서 사용할 수 있는 전체 메모리양에 따라 결정된다.   개발자는 Android 구성요소가 process 생명주기에 미치는 영향을 이해하는 것이 중요하다. 구성요소를 올바르게 사용하지 않으면 중요한 작업을 진행하는 도중 시스템에 의해 process가 죽어버릴 수 있다.   1. BroadcastReceiver와 Process lifecycle  Receiver가 Broadcast를 수신받았을때 시간이 오래걸리는 동작을 하려고 별도 Thread를 만드는 경우가 있다.    하지만 BroadcastReceiver의 onReceive() 메서드가 리턴되고 나면 시스템은 더 이상 Receiver가 더이상 Active 상태가 아니라고 판단한다.   이 때 Process에 active한 Component가 더이상 없다면 process는 더이상 필요하지 않은걸로 간주되고 시스템에 의해서 process가 kill 될 수 있다.   만약 이런 현상을 피하고 싶으면 BroadcastReceiver에서 JobService 를 써야 한다. 그러면 안드로이드 시스템은 process 내에서 active한 작업이 있다고 간주한다.   2. process 우선순위  메모리가 부족한 상황에서 어떤 프로세스를 종료해야 하는지 결정하기 위해 안드로이드는 실행중인 구성요소 및 구성요소의 상태에 따라 프로세스 우선순위가 주어진다.   우선순위가 높은 순서대로 아래와 같다.   2.1. foreground process  foreground process는 사용자가 현재 수행중인 작업에 필요한 process 이다.    아래와 같은 상황은 foreground process로 간주된다.           Activity가 화면의 Top에 위치하여 유저와 인터렉션 하고 있음. (onResume()이 호출된 Activity이다.)            BroadcastReceiver의 onReceive() 가 실행중인 경우.            Service의 onCreate(),onStart(), onDestroy()가 실행중인 경우.       foreground process는 왠만해선 죽지 않는다. 하지만 현재 시스템에 실행중인 process 수가 몇 개 없는데도 메모리가 부족한 경우 죽을 수 있다.   2.2. visible process  visible process는 현재 사용자가 알고있는 작업을 수행하고 있는 process 이다. 따라서, 이러한 단계의 process가 죽으면 사용자 경험에 좋지 않은 영향을 준다.    아래와 같은 상황은 visible process로 간주된다.           사용자가 화면에서 볼 수 있지만 foreground 상태는 아닌 경우. onPause()가 호출된 상태로 예를 들면 다이얼로그가 떠있는데 그 뒤에 있는 Activity의 process 이다.            Service.startForeground() 로 호출된 foregroud service            live wallpaper나 입력 서비스 등과 같이 유저가 인식할 수 있는 시스템의 특정 기능.       visible process는 foreground process 보다 제한적이지만 여전히 사용자에 의해 제어되는 process이다.    이 process 또한 매우 중요하게 여겨지며 foreground process 때문에 죽어야 하는 경우가 아니라면 계속 유지된다.   2.3. service process  service process는 startService() 에 의해 실행된 하나의 service가 돌아가는 process 이다.    이 process는 사용자에게 바로 보이지 않지만 background 네트워크 업로드/다운로드와 같이 사용자가 염두에 두고 있는 작업을 수행한다. 따라서 foreground process 나 visible process 를 구동시키는데 메모리가 부족한 상황이 아니라면 service process 는 유지된다.   장시간(ex- 30분 이상) service가 돌고있으면 process의 우선순위가 낮아져서 cache된 LRU 리스트에 들어갈 수 있다.    이를 통해 memeory leak이나 다른 문제가 있는 service가 오래동안 메모리를 잡아먹으면서 이 때문에 cached process 를 효율적으로 사용하지 못하게 되는 상황을 방지할 수 있다.   2.4. cached process  cached process 는 현재 중요하지 않은 프로세스로 메모리가 필요할때 언제든 시스템에 의해 죽을 수 있다.     시스템상에서 application 간 효율적인 전환을 위해 여러개의 cached process가 존재하고 정기적으로 오래된 process를 종료시킨다. 심각한 상황에서는 모든 cached process를 종료시키게 되고 cached process가 모두 종료된 상태라면 service process를 죽이기 시작한다.   이 프로세스는 유저가 볼 수 없는 상태의 Activity(onStop()이 불린 이후)를 하나 이상 보유한 process이다.    Activity를 life-cycle에 따라 정상적으로 구현했다면 이 프로세스는 유저 경험에 영향을 미치지 않는다.   이 프로세스는 내부적으로 종료시킬 프로세스 우선순위를 위해 LRU list를 가지고 있다.    LRU list를 관리하는 정확한 정책은 플랫폼 구현 세부사항에 따라 다르지만 일반적으로 다른 유형의 프로세스보다 유용한 프로세스를 오래 유지하려고 한다. (ex- 런처, 마지막으로 본 Activity의 process 등)   2.5. 정리  시스템이 프로세스 우선순위를 결정할때 이 process내부에 있는 요소 중 가장 높은 level의 우선순위를 적용한다. 안드로이드의 component가 프로세스 우선순위에 어떻게 영향을 미치는지는 각 component 상세 내용을 참고하자.   프로세스의 우선순위는 dependency가 있는 다른 프로세스에 의해 상승할 수 있다.    예를 들어 process A가 Servie Binding을 통해 process B와 바인딩한 경우.. 또는 process B가 ContentProvider를 제공하고 process A가 이를 통해 접근한 경우.. B process의 우선순위는 A process 만큼 상승한다.   ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/Process%EC%99%80-Application-Lifecycle/",
        "teaser": null
      },{
        "title": "TouchEvent에 대해서",
        "excerpt":"안드로이드에서 터치 이벤트는 3가지의 이벤트(Down, Move, Up)를 감지한다.    이 3가지는 정확히 순서대로 일어나며 하나의 프로세스로 간주한다. 사용자가 한번 터치했다고 하는 것은 이 프로세스를 한번 거쳤다는 것이기 때문이다.   1. TouchEvent 전달 과정  유저의 터치로부터 실제 터치이벤트를 처리할 Activity나 View에 전달되는 과정은 아래와 같다.      사용자가 화면을 터치   터치 디바이스 드라이버가 이벤트를 감지하고 시스템 서비스인 WindowManager에게 전달   WindowManager는 화면에 떠 있는 현재 앱의 Activity에게 이벤트 전달   Activity의 터치 영역에 View가 있다면 해당 View에 이벤트 전달   이벤트 소모   특히 해당 앱의 Activity에서 View로 이벤트가 전달되는 과정은 아래와 같다.      터치가 발생된 View를 찾기 위해 View의 root부터 하위로 탐색한다.   터치 영역에 해당하는 View를 찾으면 전달된 이벤트를 소모한다.   만약 터치 영역의 View가 해당 이벤트를 소모하지 않으면 그 View를 parent view에게 넘긴다.   2. 주요 메서드  이벤트 전달 과정에서 Activity나 View가 이벤트를 전달받는 메서드는 2개가 있다.    아래 두개의 메서드는 Activity와 View(View와 ViewGroup)에 모두 있다.   2.1. dispatchTouchEvent   @Override public boolean dispatchTouchEvent(MotionEvent ev) { \treturn super.dispatchTouchEvent(ev); }   Activity나 View가 이벤트를 제일 처음 전달받는 곳이자 이벤트를 하위 View에 전달하는 역할을 한다.     2.2. onTouchEvent   @Override public boolean onTouchEvent(MotionEvent ev) { \treturn super.onTouchEvent(ev); }   실제 전달된 이벤트를 처리하여 소비하는 곳이다.    true를 리턴하면 해당 View가 이벤트를 소모한 것이고, false를 리턴하면 해당 View의 parent View나 Activity가 이벤트를 소모할 수 있도록 권한을 넘겨준다.    만약 현재 View에서 이벤트를 소모하면 parent view나 Activity는 onTouchEvent가 호출되지 않는다.      dispatchTouchEvent 는 부모 메서드 super.dispatchTouchEvent(ev) 를 호출해주어야 한다. 그렇지 않으면 자식 View는 super.dispatchTouchEvent 와 onTouchEvent 를 받을 수 없다.   3. MotionEvent                  메서드       설명                       getAction()       터치 이벤트의 액션값.  ACTION_DOWN = 0, ACTION_UP = 1, ACTION_MOVE = 2, ACTION_CANCEL = 3                 getX()       이벤트 발생 x 좌표                 getX()       이벤트 발생 y 좌표                 getEventTime()       이벤트 발생 시간 ms                 getDownTime()       Down 이벤트가 발생한 시간 ms           4. Touch Down Event  터치 이벤트는 3가지(Down, Move, Up)가 있고 하나의 프로세스라고 했다.    이 중 첫번째 동작인 Down 이벤트는 이벤트 전달 목적지를 결정하는 역할을 한다.      위와 같이 onTouchEvent를 소비하는 곳이 ViewGroup이라고 가정하자.    그러면 Down 다음 동작인 Move와 Up의 경우 View까지 가지도 않는다.    즉, Down이후 Move와 Up의 동작에서는 View의 dispatchTouchEvent와 onTouchEvent가 아예 호출되지 않는다.   5. TouchEvent Intercept  onInterceptTouchEvent 메서드는 자식 View로 전달되는 이벤트를 부모 ViewGroup이 가로챌 수 있도록 한다.    그리고 만약 가로채진 경우 이를 자식 View가 알 수 있도록 ACTION_CANCEL 이라는 이벤트를 onTouchEvent 메서드를 통해 전달해준다.   사용하고자 하는 경우 이 메서드를 Override하면 되는데 Activity는 사용할 수 없다.    당연한게.. 액티비티가 이벤트를 가로채버리면 밑에 View가 할 수 있는게 아무것도 없기 때문이다.   이벤트를 부모가 인터셉트 하는 경우는 아래와 같은 경우 필요하다.      그림과 같이 ScrollView를 꽉채우는 Button이 있을때 Button이 터치를 잡게 되는데 이 때문에 스크롤을 할 수 없는 상황이 발생할 수 있다.   5.1. TouchEvent Intercept 방지  부모 View는 onInterceptTouchEvent를 통해 자식 View에게 전달될 이벤트를 가로챌 수 있다.    반대로 자식 View는 requestDisallowInterceptTouchEvent 메서드를 통해 부모 View가 이벤트를 가로채지 못하도록 요청 할 수 있다.    단, 주의할 점은 한번의 터치 프로세스에서만 유효하다는 것이다. 계속 필요하다면 매 터치가 발생할때마다 메서드를 호출해 줘야 한다.   6. 이벤트 리스너  View의 이벤트를 받기 위해 모든 View를 CustomView로 만들어 onTouchEvent를 상속받을 수는 없다.     View가 전달받는 이벤트를 위해 OnTouchListener 가 존재하는데 View에 리스너가 설정되 있을 경우 onTouchEvent를 호출하지 않고, OnTouchListener.onTouch(View v, MotionEvent ev) 를 호출해준다.      참고로 dispatchTouchEvent, onIntercepptTouchEvent 를 위한 리스너는 없음. 이를 사용하기 위해서는 무조건 View/ViewGroup을 상속받아 커스텀으로 만들어야 한다.         [참고 문서]            도서 “이것이 안드로이드다”      ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/TouchEvent/",
        "teaser": null
      },{
        "title": "View가 그려지는 과정",
        "excerpt":"1. flow 간단정리     view는 Tree 구조를 가지며 Activity는 반드시 Root view가 있어야 한다.   view가 그렬질때 tree의 부모에서 자식 순서로 그려지도록 호출된다.   그리는 과정은 크게 measure(크기 측정), layout(배치), draw(그리기) 단계로 이루어진다.   부모 view가 measure될때 자식 view도 measure되며, 부모의 measure과정이 끝났다는 것은 자식의 measure 과정 역시 끝났다는 것이다.   layout 과정에서 부모 view는 measure가 완료된 자식 view의 크기를 이용해서 배치한다.   크기를 조절하는 과정에서 measure()와 layout()은 여러번 호출될 수 있다.   자식 view가 부모 view에게 자신의 크기를 전달할때 LayoutParams 가 사용된다.   부모 view가 자식 view에게 요구사항을 전달할때 MeasureSpec 이 사용된다.   measure와 layout 단계가 끝났으면 draw 과정을 통해 실제 View 의 모습을 화면에 그린다.   2. View drawing 상세   2.1. View drawing을 위한 기본   2.1.1. Activity는 Root Node(View)를 제공해야 한다.  Activity가 focus를 받으면 레이아웃을 그리도록 요청된다.    안드로이드 프레임워크가 그리는 과정을 처리하는데 이때 Activity는 반드시 레이아웃 Hierarchy의 Root Node(View)를 제공해야 한다.     setContentView() 가 이 과정이라 할 수 있다.    2.1.2. 안드로이드에서 View는 Tree 구조로 구성된다.  Root View 아래에 다수의 자식 View가 존재할 수 있고, 각 자식 View 아래에 또 다른 자식 View들이 존재할 수 있다. 모든 View는 이렇게 Root View로부터 Tree 구조로 구성된다.     Tree 구조로 구성되므로 Root View로부터 모든 View에 대한 탐색이 가능하다.   2.1.3. Drawaing 3단계 과정 (Measure, Layout, Draw)   Drawaing은 크게 3단계로 구성되고 Drawaing cycle 상 순서는 아래와 같다.        Measure - View 크기 측정 단계   Layout - View 배치 단계   Draw - View 그리기 단계   이 과정은 Tree 순서대로 진행된다.   즉, Root View로부터 시작하여 자식 View 순서대로 진행되는데 만약 자식이 여러개 (형제 관계)라면 순서대로 그려진다.      RelativeLayout이나 ConstraintLayout에서 자식 View를 정의할때 보면 코드 순서상 뒤에 있는 View가 앞에 있는 View를 덮을 수 있음. 형제 관계에서는 순서대로 그려지는데 코드상 뒤에 있기 때문이다.    2.1.4. Measure, Layout은 여러번 호출될 수 있다.  경우에 따라 View drawing 과정에서 크기측정(measure)과 배치과정(layout)은 여러번 호출 될 수 있다.   예를 들어 부모 View는 정확한 크기가 명시되어 있지 않은 자식 View에 대해 해당 자식 View가 얼마만큼의 크기를 원하는지 알아내기 위해 measure()를 호출할 수 있다.    이후 모든 자식의 크기 합이 너무 크거나 작으면 실제 명시적인 숫자로 measure()를 한번 더 호출할 수 있다.     즉, 자식 view가 차지하는 공간에 대해 동의하지 않아 두번째 과정에서 부모가 강제로 규칙을 설정하는 것이다.   2.2. Measure 단계     크기를 측정하는 단계로 이 단계가 끝나면 View에는 측정된 값에 대한 정보가 저장되어 있어야 한다.   Measure 단게에서 부모 View와 자식 View간에 치수 정보를 주고받기 위해 2개의 Class(LayoutParams, MeasureSpec)가 사용된다.   2.2.1. onMeasure(Int, Int)     void onMeasure(int widthMeasureSpec, int heightMeasureSpec)    부모 레이아웃이 자식 레이아웃을 배치하기전 자식의 크기를 알아내기 위해 measure() 메서드를 호출한다. 그런데 measure()에는 강제 레이아웃, 크기 변경 빈도 최소화, 치명적인 에러 처리등의 중요한 역할을 담당하기 때문에 직접 override하지 않는다. 이 대신 measure()에서 크기 결정시 onMeasure()를 호출하기 때문에 보통 onMeasure()를 override하여 View의 크기를 결정하도록 한다.   2.2.2. LayoutParams  자식 View가 자신이 그려지길 원하는 크기나 위치를 부모 View에게 전달할때 ViewGroup.LayoutParams를 사용한다.     이 클래스의 기본 생성자를 통해서 얼마만큼의 width와 height를 가지길 원하는지에 대해서 전달할 수 있는데 아래 3가지가 가능하다.      명시적인 크기   MATCH_PARENT : 부모 크기만큼 원함.   WRAP_CONTENT : 자신의 content 공간이 끝나는 크기만큼을 원함.   ViewGroup에 따라서 각각 다른 ViewGroup.LayoutParams의 서브 클래스가 존재한다. 예를 들어 RelativeLayout은 RelativeLayout.LayoutParams 클래스가 있다.   (참고) LayoutParams 역할 생각해보기  LayoutParams 는 ViewGroup에 따라 각각 다른 subClass가 있는데, 이는 LayoutParams의 역할을 생각해보면 당연하다.     LayoutParams의 역할이 자식 View의 요구사항을 부모 View에게 전달하는 역할이라고 했다.    이 요구사항을 받아들이는건 부모 View이므로 당연히 부모 View가 들어줄 수 있는 요구사항이어야 한다.   부모 View란 ViewGroup을 말하는 것이고, 각 ViewGroup은 자신의 특성에 따라 들어줄 수 있는 요구사항이 달라지므로 각 ViewGroup 마다 LayoutParams가 따로 존재한다.   참고로 ViewGroup에서는 자식 View가 설정한 LayoutParams를 아래와 같이 읽어올 수 있다. 요구사항을 전달한다는 뜻은 이렇게 ViewGroup이 View의 설정을 읽을 수 있기 때문이다.   for(int i=0; i &lt; getChildCount(); i++) { \t// Tree 순서에 따라 자신 하위에 있는 자식 View를 찾을 수 있음. \tView childView = getChildAt(i); \t \t// 자식 View의 getLayoutParams() 호출을 통해 자식 View가 설정한 요구사항을 볼 수 있음. \tLayoutParams params = childView.getLayoutParams(); }   2.2.3. MeasureSpec  부모 View는 자식 View에게 자식이 그려질 수 있는 여유 공간의 폭과 높이에 대한 정보를 제공하는데 이 때 사용하는 것이 MeasureSpec 이다.     즉, 부모가 자식에게 알려주면서 이 안에 그리라는 요구사항을 전달하는 것이다.   이 값은 두개의 값이 묶여있는데 하나는 Mode이며 다른 하나는 크기값이다. 값을 읽거나 다시 합칠때 View.MeasureSpec의 다음 메서드를 사용한다.      int getMode(int measureSpec)   int getSize(int measureSpec)   makeMeasureSpec(int size, int mode)   (참고) MeasureSpec Mode 3가지                  Mode       설명                       UNSPECIFIED       부모 view가 자식 view를 제약하지 않는다. 자식 view가 희망하는 size로 그려질 수 있다.                 EXACTLY       자식 view가 어느정도의 크기를 원하는지에 상관없이 부모 view가 자식 view의 size를 지정한다. 자식 view는 이 사이즈를 사용해야 하고 자식의 자식들 모두 이 범위 안에 있어야 한다.                 AT_MOST       자식 view가 가질 수 있는 최대 size를 부과하는데 사용된다. 자식 view는 이 사이즈 이하로 크기를 결정해야 한다.           예를 들어 width는 AT_MOST 200이고 height는 EXACTLY 100으로 전달되었다면 View는 width에 대해 최대 200 픽셀 이하로 그려져야하고, height는 가급적 100 픽셀로 그려져야 한다.   2.2.4. onMeasure()의 결과  measure 단계가 끝나면 getMeasuredWidth(), getMeasuredHeight() 의 호출 결과로 측정된 값을 리턴할 수 있어야 한다.     즉, View에서 onMeasure() 의 결과값을 세팅하여 부모가 자식의 getMeasuredWidth(), getMeasuredHeight() 을 호출할때 값을 리턴해 줄 수 있어야 한다는 것이다.   이 때문에 onMeasure() 의 마지막에는 반드시 void setMeasureDimension(int measuredWidth, int measuredHeight) 메서드를 호출해줘야 한다.   만약 호출하지 않으면 runtime 중에 IllegalStateException이 발생한다. 측정 이후 배치를 하는 단계에서 부모가 자식에게 크기를 물었는데 자식이 이를 알려주지 않기 때문이다.   이 값은 당연히 View의 부모에 의해 설정된 제약사항(measureSpec)을 따라야 한다.   2.3. Layout 단계  두번째 과정은 크기가 측정된 View를 배치하는 단계이다.    이 과정은 보통 View가 ViewGroup 일 때 많은 역할을 수행한다. 즉, 부모 View는 크기 측정단계(Measure)에서 계산된 자식 View의 사이즈를 이용하여 자식 View를 배치하게 된다.   2.4. Draw 단계  세번째 단계는 크기가 측정되고 위치가 확정된 View를 그리는 단계이다.     3. View의 draw cycle 살펴보기                     카테고리       메서드       설명                       Creation       생성자       생성자로 code에 의해서 호출되거나 layout file에 의해 view가 inflate 될때 호출된다.                         onFinishInflate()       View 및 자기 자식 View가 XML로 부터 inflate 완료되었을때 호출된다.                 Layout       onMeasure(int, int)       View 및 자기 자식 View의 사이즈 결정을 위해 호출된다.                         onLayout(boolean, int, int, int, int)       View가 자기 자식들에게 크기와 위치를 할당할때 호출된다.                         onSizeChanged(int, int, int, int)       view의 크기가 변경되었을때 호출된다.                 Drawing       onDraw(Canvas)       view가 자기 content를 렌더링 할때 호출된다.                 Event processing       onKeyDown(int, KeyEvent)       하드웨어 키 down이 발생했을때 호출된다.                         onKeyUp(int, KeyEvent)       하드웨어 키 up이 발생했을 때 호출된다.                         onTrackballEvent(MotionEvent)       trackball 모션 이벤트가 발생했을 때 호출된다.                         onTouchEvent(MotionEvent)       screen 모션 이벤트가 발생했을때 호출된다.                 Focus       onFocusChanged(boolean, int, Rect)       View가 focus를 획득하거나 잃었을때 호출된다.                         onWindowFocusChanged(boolean)       View를 가지고 있는 Window가 focus를 획득하거나 잃었을때 호출된다.                 Attaching       onAttachedToWindow()       view가 window에 attach에 되었을때 호출된다.                         onDetachedFromWindow()       view가 window에 detached 되었을때 호출된다.                         onWindowVisibilityChanged(int)       view를 가지고 있는 window의 visibility가 변경되었을때 호출된다.           4. View의 생성자  View의 생성자로 총 4개가 있는데 각각이 어떤걸 의미하는지, 왜 4개로 나누져 있는지, 각 파라미터가 어떤것인지, 어떤 생성자를 구현해야 하는지 알아본다.   4.1 View의 생성자   View(Context)  View(Context, AttributeSet)  View(Context, AttributeSet, defStyleAttr)  View(Context, AttributeSet, defStyleAttr, defStyleRes)    마지막 생성자는 API 21에서 추가되었다. 만약 하위버전에서 defStyleRes를 사용하고자 한다면 obtainStyledAttributes() 를 통해 얻을 수 있다.   생성자는 cacade하게 호출되므로 하나를 부르면 결국 super를 통해 나머지 생성자가 호출된다. 즉, 일반적으로는 위 4개중 2개의 생성자 (View(Context), View(Context, AttributeSet)) 만 재정의해서 사용하면 된다. 첫번째는 code에서 직접 View를 생성할때이고 두번째는 XML에서 inflate 될때이다.   4.2. 생성자 Parameter                  Parameter       설명                       Context       -                 AttributeSet       XML 속성이다.(XML에서 inflating 될 때)                 int defStyleAttr       view에 설정된 default style 이다.(theme에서 설정되어 있음)                 int defStyleResource       view에 설정된 default style 이다.(defStyleAttr이 사용중이지 않을때)           4.2.1. Attributes  아래와 같이 layout_width, layout_height, src 등이 XML Attribute 이다.   &lt;ImageView     android:layout_width=\"wrap_content\"   android:layout_height=\"wrap_content\"   android:src=\"@drawable/icon\" /&gt;   이러한 속성을 사용할 수 있도록 &lt;declare-styleable&gt; 에 정의되어 있어야 한다.  예를 들어 아래와 같다.   &lt;declare-styleable name=\"ImageView\"&gt;     &lt;!-- Sets a drawable as the content of this ImageView. --&gt;   &lt;attr name=\"src\" format=\"reference|color\" /&gt;  &lt;/declare-styleable&gt;     각 &lt;declare-styleable&gt;는 하나의 R.styleable.[name]와 함께 개별속성에 따라 R.styleable.[name]_[attribute] 를 생성한다.    예를 들어 위 예제에서는 R.styleable.ImageView 와 R.styleable.ImageView_src 가 생성된다.   R.styleable.[name]는 모든 attribute 리소스의 배열로 시스템이 attribute를 찾는데 사용된다. 각 R.styleable.[name]_[attribute]는 배열 속에 있는 각 아이템이다. 그렇기 때문에 모든 attribute를 한번에 검색한 다음 각 상세 값을 개별 조회할 수 있다.   4.2.2. AttributeSet  위에서 사용한 Attribute는 View의 AttributeSet을 통해 제공된다.   AttributeSet에서 속성값을 읽을 수 있긴하지만 보통 바로 사용하지 않고 Resources.Theme.obtainStyledAttributes()에 파라미터로 넘겨준뒤 전달받은 결과값인 TypedArray를 사용한다.   init {     context.theme.obtainStyledAttributes(         attrs,         R.styleable.PieChart,         0, 0     ).apply { \t    try { \t        mShowText = getBoolean(R.styleable.PieChart_showText, false) \t        textPos = getInteger(R.styleable.PieChart_labelPosition, 0) \t    } finally { \t    \t// TypedArray는 반드시 recycle 해줘야 함. \t    \trecycle() \t    }     } }      TypedArray obejct는 공유되는 resoure이므로 반드시 recycle 해줘야 한다.    AttributesSet을 바로 사용하지 않는 것은 아래 두가지 문제가 있기 때문이다.      속성값이 resource 참조로 되어있는 경우 해당 resourece의 값을 가져올 수 없다.   Theme과 Style이 적용되어 있지 않다.   (ex1) string resource  참조값으로 @string/my_label 가 정의되있을때 my_label 에 정의된 string 값으로 변환해준다. 만약 AttributeSet을 직접 사용하게 된다면 AttributeSet.getAttributeResourceValue(int, int) 을 이용하여 리소스 참조값을 직접 찾아야 한다.    (ex2) style  XML에서 style=@style/MyStyle 와 같이 스타일 적용을 한 경우 Theme.obtainStyledAttributes() 메서드는 MyStyle을 찾아 적용을 한다.   4.2.3. Default Style Attribute  이전 예에서 obtainStyledAttributes() 를 사용할때 마지막 2개의 parameter로 0을 넘겼다. 실제로 이 두개는 defStyleAttr, defStyleRes 이다.   defStyleAttr의 경우 쉽게 말하면 이 View에 기본 설정되는 default style을 말한다.    view를 쓸때마다 매번 이 view가 가져야 하는 기본 style을 지정해주기는 귀찮으니 default를 지정하는 것이다.    (default style을 theme에 만들어두고 사용하는 방식으로 쓴다.)   4.2.4. Defalt Style Resource  defStyleRes 는 간단하다. 단지 스타일 리소스(ex- @style/Widget.TextView)를 가리킨다.   defStyleRes 스타일 속성은 defStyleAttr이 정의되지 않은 경우에만 적용된다. (0으로 설정되거나 테마에 설정되어 있지 않음)      좀 더 찾아봐야 함.    4.2.5. 파라미터 관련 우선순위  다음 순서로 적용된다.      AttributeSet에 정의된 설정 값.   AttributeSet에 정의된 style resource (ex-style=@style/blah)   defStyleAttr로 명시된 default style attribute.   defStyleResource로 명시된 default style resource. (defStyleAttr이 없는 경우)   Theme에 있는 값   즉, XML에서 직접 설정한 Attribute는 우선적으로 적용되고 설정하지 않았을 경우 이러한 속성을 검색할 수 있는 다양한 요소가 있다.        [참고 문서]            View의 생성자       view 라이프사이클       안드로이드 문서        ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/View%EA%B0%80-%EA%B7%B8%EB%A0%A4%EC%A7%80%EB%8A%94-%EA%B3%BC%EC%A0%95/",
        "teaser": null
      },{
        "title": "안드로이드 Task stack 뜯어보기",
        "excerpt":"   안드로이드 Task에 대한 내용은 안드로이드 Task 포스팅을 참고할 것.    아래 ADB 명령을 통해 현재 기기에 생성된 Task를 확인할 수 있다.   adb shell dumpsys activity activities &gt; result.txt      Activity의 상태를 보여달라는 명령으로 Activity에 Task 정보가 포함되어 있다.    아래는 현재 단말에 아무것도 실행된 앱이 없는 상태에서 kimss.app.tasktest 앱의 A Activity가 B Activity를 실행시킨 경우에 대한 예이다. (갤럭시 노트5로 테스트)   ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities) Display #0 (activities from top to bottom):   Stack #1:     Task id #2374     * TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}       userId=0 effectiveUid=u0a755 mCallingUid=2000 mCallingPackage=null       affinity=kimss.app.tasktest       intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=kimss.app.tasktest/.A}       realActivity=kimss.app.tasktest/.A       autoRemoveRecents=false isPersistable=true numFullscreen=2 taskType=0 mTaskToReturnTo=1       rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE       Activities=[ActivityRecord{522ec94 u0 kimss.app.tasktest/.A t2374}, ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}]       askedCompatMode=false inRecents=true isAvailable=true       lastThumbnail=android.graphics.Bitmap@ae180d1 lastThumbnailFile=/data/system/recent_images/2374_task_thumbnail.png       stackId=1       hasBeenVisible=true mResizeable=false firstActiveTime=1475299182857 lastActiveTime=1475299210659 lastActiveElapsedTime=1290568837 (inactive for 5s)       multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1}       bHidden=false       isSecretMode=false       * Hist #1: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}           packageName=kimss.app.tasktest processName=kimss.app.tasktest           launchedFromUid=10755 launchedFromPackage=kimss.app.tasktest userId=0           app=ProcessRecord{9e9b736 11970:kimss.app.tasktest/u0a755}           Intent { cmp=kimss.app.tasktest/.B bnds=[102,473][1337,1708] }           frontOfTask=false task=TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}           taskAffinity=kimss.app.tasktest           realActivity=kimss.app.tasktest/.B           baseDir=/data/app/kimss.app.tasktest-1/base.apk           dataDir=/data/user/0/kimss.app.tasktest           stateNotNeeded=false componentSpecified=true mActivityType=0           compat={560dpi} labelRes=0x7f060020 icon=0x7f030000 theme=0x7f08008e           config={1 1.0 themeSeq = 0 showBtnBg = 0 450mcc5mnc ko_KR ldltr sw411dp w411dp h707dp 560dpi nrml long port finger -keyb/v/h -nav/h mkbd/h s.263}           stackConfigOverride={0 1.0 themeSeq = 0 showBtnBg = -1 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? mkbd/?}           taskDescription: iconFilename=null label=\"null\" color=ff3f51b5           launchFailed=false launchCount=0 lastLaunchTime=-32s982ms           haveState=false icicle=null           state=RESUMED stopped=false delayedResume=false finishing=false           keysPaused=false inHistory=true visible=true sleeping=false idle=true           fullscreen=true noDisplay=false immersive=false launchMode=0           frozenBeforeDestroy=false forceNewConfig=false           mActivityType=APPLICATION_ACTIVITY_TYPE           waitingVisible=false nowVisible=true lastVisibleTime=-5s241ms           multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1}           bMultiInstance=false           mIsLastShownWhenLocked=false       * Hist #0: ActivityRecord{522ec94 u0 kimss.app.tasktest/.A t2374}           packageName=kimss.app.tasktest processName=kimss.app.tasktest           launchedFromUid=2000 launchedFromPackage=null userId=0           app=ProcessRecord{9e9b736 11970:kimss.app.tasktest/u0a755}           Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=kimss.app.tasktest/.A }           frontOfTask=true task=TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}           taskAffinity=kimss.app.tasktest           realActivity=kimss.app.tasktest/.A           baseDir=/data/app/kimss.app.tasktest-1/base.apk           dataDir=/data/user/0/kimss.app.tasktest           stateNotNeeded=false componentSpecified=false mActivityType=0           compat={560dpi} labelRes=0x7f060020 icon=0x7f030000 theme=0x7f08008e           config={1 1.0 themeSeq = 0 showBtnBg = 0 450mcc5mnc ko_KR ldltr sw411dp w411dp h707dp 560dpi nrml long port finger -keyb/v/h -nav/h mkbd/h s.263}           stackConfigOverride={0 1.0 themeSeq = 0 showBtnBg = -1 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? mkbd/?}           taskDescription: iconFilename=null label=\"null\" color=ff3f51b5           launchFailed=false launchCount=0 lastLaunchTime=-33s556ms           haveState=true icicle=Bundle[mParcelledData.dataSize=680]           state=STOPPED stopped=true delayedResume=false finishing=false           keysPaused=false inHistory=true visible=false sleeping=false idle=true           fullscreen=true noDisplay=false immersive=false launchMode=0           frozenBeforeDestroy=false forceNewConfig=false           mActivityType=APPLICATION_ACTIVITY_TYPE           displayStartTime=-33s231ms startTime=0           multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1}           bMultiInstance=false           mIsLastShownWhenLocked=false      Running activities (most recent first):       TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}         Run #1: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}         Run #0: ActivityRecord{522ec94 u0 kimss.app.tasktest/.A t2374}      mResumedActivity: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}     mLastPausedActivity: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}    Stack #0:     Task id #176     * TaskRecord{deafbac #176 A=com.android.systemui U=0 sz=1}       userId=0 effectiveUid=u0a528 mCallingUid=u0a528 mCallingPackage=com.android.systemui       affinity=com.android.systemui       intent={flg=0x10800000 cmp=com.android.systemui/.recents.SeparatedRecentsActivity bnds=[83,1670][1358,2945]}       realActivity=com.android.systemui/.recents.SeparatedRecentsActivity       autoRemoveRecents=false isPersistable=false numFullscreen=1 taskType=2 mTaskToReturnTo=0       rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE       Activities=[ActivityRecord{487ad68 u0 com.android.systemui/.recents.SeparatedRecentsActivity t176}]       askedCompatMode=false inRecents=true isAvailable=true       lastThumbnail=null lastThumbnailFile=/data/system/recent_images/176_task_thumbnail.png       stackId=0       hasBeenVisible=true mResizeable=false firstActiveTime=1474085921036 lastActiveTime=1475299210647 lastActiveElapsedTime=1290568825 (inactive for 5s)       multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x01000002, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1, or=3}       bHidden=false       isSecretMode=false       * Hist #0: ActivityRecord{487ad68 u0 com.android.systemui/.recents.SeparatedRecentsActivity t176}           packageName=com.android.systemui processName=com.android.systemui.recents           launchedFromUid=10528 launchedFromPackage=com.android.systemui userId=0           app=ProcessRecord{8c3c075 4366:com.android.systemui.recents/u0a528}           Intent { flg=0x10800000 cmp=com.android.systemui/.recents.SeparatedRecentsActivity bnds=[83,1670][1358,2945] }           frontOfTask=true task=TaskRecord{deafbac #176 A=com.android.systemui U=0 sz=1}           taskAffinity=com.android.systemui           realActivity=com.android.systemui/.recents.SeparatedRecentsActivity           baseDir=/system/priv-app/SystemUI/SystemUI.apk           dataDir=/data/user/0/com.android.systemui           stateNotNeeded=true componentSpecified=false mActivityType=2           compat={560dpi} labelRes=0x7f0d024e icon=0x7f020247 theme=0x7f100015           config={1 1.0 themeSeq = 0 showBtnBg = 0 450mcc5mnc ko_KR ldltr sw411dp w411dp h707dp 560dpi nrml long port finger -keyb/v/h -nav/h mkbd/h s.263}           stackConfigOverride={0 1.0 themeSeq = 0 showBtnBg = -1 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? mkbd/?}           taskDescription: iconFilename=null label=\"null\" color=fff5f5f5           launchFailed=false launchCount=0 lastLaunchTime=-13d19h3m31s799ms           haveState=true icicle=Bundle[mParcelledData.dataSize=2324]           state=STOPPED stopped=true delayedResume=false finishing=false           keysPaused=false inHistory=true visible=false sleeping=false idle=true           fullscreen=true noDisplay=false immersive=false launchMode=3           frozenBeforeDestroy=false forceNewConfig=false           mActivityType=RECENTS_ACTIVITY_TYPE           waitingVisible=false nowVisible=false lastVisibleTime=-6s268ms           multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x01000002, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1, or=3}           bMultiInstance=false           mIsLastShownWhenLocked=false      Task id #102     * TaskRecord{67fd55f #102 A=com.sec.android.app.launcher U=0 sz=1}       userId=0 effectiveUid=u0a63 mCallingUid=u0a528 mCallingPackage=com.android.systemui       affinity=com.sec.android.app.launcher       intent={act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10800000 cmp=com.sec.android.app.launcher/com.android.launcher2.Launcher}       origActivity=com.sec.android.app.launcher/.activities.LauncherActivity       realActivity=com.sec.android.app.launcher/com.android.launcher2.Launcher       autoRemoveRecents=false isPersistable=false numFullscreen=1 taskType=1 mTaskToReturnTo=1       rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE       Activities=[ActivityRecord{f248222 u0 com.sec.android.app.launcher/.activities.LauncherActivity t102}]       askedCompatMode=false inRecents=true isAvailable=true       lastThumbnail=null lastThumbnailFile=/data/system/recent_images/102_task_thumbnail.png       stackId=0       hasBeenVisible=true mResizeable=false firstActiveTime=1474008635870 lastActiveTime=1475298860659 lastActiveElapsedTime=1290218836 (inactive for 355s)       multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1, or=1}       bHidden=false       isSecretMode=false       * Hist #0: ActivityRecord{f248222 u0 com.sec.android.app.launcher/.activities.LauncherActivity t102}           packageName=com.sec.android.app.launcher processName=com.sec.android.app.launcher           launchedFromUid=0 launchedFromPackage=null userId=0           app=ProcessRecord{590c70f 4655:com.sec.android.app.launcher/u0a63}           Intent { act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10800000 cmp=com.sec.android.app.launcher/.activities.LauncherActivity }           frontOfTask=true task=TaskRecord{67fd55f #102 A=com.sec.android.app.launcher U=0 sz=1}           taskAffinity=com.sec.android.app.launcher           realActivity=com.sec.android.app.launcher/com.android.launcher2.Launcher           baseDir=/system/priv-app/TouchWizHome_2016/TouchWizHome_2016.apk           dataDir=/data/user/0/com.sec.android.app.launcher           stateNotNeeded=true componentSpecified=false mActivityType=1           compat={560dpi} labelRes=0x7f070002 icon=0x7f02006f theme=0x7f0d0010           config={1 1.0 themeSeq = 0 showBtnBg = 0 450mcc5mnc ko_KR ldltr sw411dp w411dp h707dp 560dpi nrml long port finger -keyb/v/h -nav/h mkbd/h s.263}           stackConfigOverride={0 1.0 themeSeq = 0 showBtnBg = -1 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? mkbd/?}           taskDescription: iconFilename=null label=\"null\" color=ff51b0d3           launchFailed=false launchCount=0 lastLaunchTime=-14d2h8m28s114ms           haveState=true icicle=Bundle[mParcelledData.dataSize=24324]           state=STOPPED stopped=true delayedResume=false finishing=false           keysPaused=false inHistory=true visible=false sleeping=false idle=true           fullscreen=true noDisplay=false immersive=false launchMode=2           frozenBeforeDestroy=false forceNewConfig=false           mActivityType=HOME_ACTIVITY_TYPE           waitingVisible=false nowVisible=false lastVisibleTime=-7m54s674ms           multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1, or=1}           bMultiInstance=false           mIsLastShownWhenLocked=false      Running activities (most recent first):       TaskRecord{deafbac #176 A=com.android.systemui U=0 sz=1}         Run #1: ActivityRecord{487ad68 u0 com.android.systemui/.recents.SeparatedRecentsActivity t176}       TaskRecord{67fd55f #102 A=com.sec.android.app.launcher U=0 sz=1}         Run #0: ActivityRecord{f248222 u0 com.sec.android.app.launcher/.activities.LauncherActivity t102}      mLastPausedActivity: ActivityRecord{487ad68 u0 com.android.systemui/.recents.SeparatedRecentsActivity t176}      mLastPausedActivity: ActivityRecord{d1b2128 u0 com.android.systemui/.multiwindow.RecentsMultiWindowActivity t2059 f}    mFocusedActivity: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}   mPersistDownloadablePkgs:     com.android.systemui   mFocusedStack=ActivityStack{fb0ae96 stackId=1, 1 tasks} mLastFocusedStack=ActivityStack{fb0ae96 stackId=1, 1 tasks}   mSleepTimeout=false   mCurTaskId=2374   mUserStackInFront={}   mActivityContainers={0=ActivtyContainer{0}A zone=0, 1=ActivtyContainer{1}A zone=0, 2=ActivtyContainer{2}A zone=12, 3=ActivtyContainer{3}A zone=3}   mLockTaskModeState=NONE mLockTaskPackages (userId:packages)=     0:[]  mLockTaskModeTasks[]   mCurrentUser=0  GlobalTaskHistory   ActivityDisplay #0 (1440x2560)     TASK id #2374\tu0\t(Stack #1)\tkimss.app.tasktest     TASK id #176\tu0\t(Stack #0)\tcom.android.systemui     TASK id #102\tu0\t(Stack #0)\tcom.sec.android.app.launcher  MultiWindow setting   current    history     u0 history[0] - mobile_keyboard : true reason : prev    1. 전체적인 구조  현재 전체 구조가 아래와 같다.    Stack #1:    Task id #2374      TaskRecord(#2374)        Hist #1: ActivityRecord(...)        Hist #0: ActivityRecord(...)            Running activities (most recent first):      TaskRecord(#2374)        Run #1: ActivityRecord(...)        Run #0: ActivityRecord(...)            Stack #0:    Task id #176      TaskRecord(#176)        Hist #0: ActivityRecord(...)            Task id #102      TaskRecord(#102)        Hist #0: ActivityRecord(...)            Running activities (most recent first):      TaskRecord(#176)        Run #1: ActivityRecord(...)      TaskRecord(#102)        Run #0: ActivityRecord(...)    1.1 Stack #..  여기서 나타나는 Stack은 어떤 기준으로 나오는 것인지 잘 모르겠다.    구조상 Stack 아래에 여러개의 Task가 올 수 있다.     현재 “Stack #1” 에는 실행시킨 테스트앱의 Task가 들어가있고, “Stack #0” 은 런처앱의 Task가 있다.    런처앱에는 2개의 Task가 있는데 각각 “최근앱 목록” 에 해당하는 Task와 “런처 홈”에 해당하는 Task 이다.   현재는 테스트 앱 하나만 띄운 경우인데 여러앱을 띄우고 dump 데이터를 다시 뽑으니 “Stack #1” 에 여러개의 Task가 들어가게 된다.    정확히 어떤 기준으로 Stack이 나뉘어지고 Task들이 자리잡는지 모르겠으나 개발자가 임의로 설정할 수 있고 어떠한 의미를 가진다 라는 내용은 보지 못하였다.   1.2. Task id #…  Stack 아래에 있는 Task가 Activity Task의 정보이다.    하나의 Task는 별도의 Task ID를 가지고 분류된다.   Task의 순서도 안드로이드에서 의미가 있는 정보이다.    상위에 있는 Task가 최근에 실행한 Task이고, 이건 최근 앱 목록에 나오는 순서이기도 하다.   1.3. TaskRecord의 Hist #…  해당 Task의 Activity Stack 정보이다.    “Hist #0 &gt; Hist #1 &gt; Hist #2” 와 같이 순서대로 Stack 구조로 쌓인다.    최상위에 있는 Hist 정보가 Top Activity이고, 최하단에 있는 Hist #0 이 Root Activity 이다.   1.4. Running activities  해당 Stack 아래에 있는 각 Task에서 실행되고 있는 Activity 정보를 보여준다.    그냥 요약해서 보여주는 정보로 큰 의미는 없는것 같다.   2. Task 정보  Task 아래에 있는 정보는 아래와 같다.   Task id #2374 * TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}   userId=0 effectiveUid=u0a755 mCallingUid=2000 mCallingPackage=null   affinity=kimss.app.tasktest   intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=kimss.app.tasktest/.A}   realActivity=kimss.app.tasktest/.A   autoRemoveRecents=false isPersistable=true numFullscreen=2 taskType=0 mTaskToReturnTo=1   rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE   Activities=[ActivityRecord{522ec94 u0 kimss.app.tasktest/.A t2374}, ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}]   askedCompatMode=false inRecents=true isAvailable=true   lastThumbnail=android.graphics.Bitmap@ae180d1 lastThumbnailFile=/data/system/recent_images/2374_task_thumbnail.png   stackId=1   hasBeenVisible=true mResizeable=false firstActiveTime=1475299182857 lastActiveTime=1475299210659 lastActiveElapsedTime=1290568837 (inactive for 5s)   multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1}   bHidden=false   isSecretMode=false      Task 내용은 TaskRecord.java 코드를 참고하면 된다.    2.1. taskId  Task를 구분하는 유일 값. (Unique identifier for this task.)   2.2. affinity  Task 친밀도를 나타내는 정보.    (The affinity name for this task, or null; may change identity.)   2.3. rootAffinity  Initial base affinity. or null; does not change from initial root.   2.4. intent  이 Task에서 가장 먼저 실행된 Root Activity를 실행시킨 Intent 정보이다.  (The original intent that started the task.)   2.5. affinityIntent  Intent of affinity-moved activity that started this task.   2.6. realActivity  The actual activity component that started the daytask.   2.7. origActivity  The non-alias activity component of the intent.   3. Activity History 정보  Task 아래 Activity Stack의 각 History가 가지는 정보는 아래와 같다.   * Hist #1: ActivityRecord{e1bd371 u0 kimss.app.tasktest/.B t2374}   packageName=kimss.app.tasktest processName=kimss.app.tasktest   launchedFromUid=10755 launchedFromPackage=kimss.app.tasktest userId=0   app=ProcessRecord{9e9b736 11970:kimss.app.tasktest/u0a755}   Intent { cmp=kimss.app.tasktest/.B bnds=[102,473][1337,1708] }   frontOfTask=false task=TaskRecord{db853f8 #2374 A=kimss.app.tasktest U=0 sz=2}   taskAffinity=kimss.app.tasktest   realActivity=kimss.app.tasktest/.B   baseDir=/data/app/kimss.app.tasktest-1/base.apk   dataDir=/data/user/0/kimss.app.tasktest   stateNotNeeded=false componentSpecified=true mActivityType=0   compat={560dpi} labelRes=0x7f060020 icon=0x7f030000 theme=0x7f08008e   config={1 1.0 themeSeq = 0 showBtnBg = 0 450mcc5mnc ko_KR ldltr sw411dp w411dp h707dp 560dpi nrml long port finger -keyb/v/h -nav/h mkbd/h s.263}   stackConfigOverride={0 1.0 themeSeq = 0 showBtnBg = -1 ?mcc?mnc ?locale ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? mkbd/?}   taskDescription: iconFilename=null label=\"null\" color=ff3f51b5   launchFailed=false launchCount=0 lastLaunchTime=-32s982ms   haveState=false icicle=null   state=RESUMED stopped=false delayedResume=false finishing=false   keysPaused=false inHistory=true visible=true sleeping=false idle=true   fullscreen=true noDisplay=false immersive=false launchMode=0   frozenBeforeDestroy=false forceNewConfig=false   mActivityType=APPLICATION_ACTIVITY_TYPE   waitingVisible=false nowVisible=true lastVisibleTime=-5s241ms   multiWindowStyle=MultiWindowStyle{type=0, zone=ZONE_UNKNOWN, option=0x00000000, bounds=null, isNull=false, isolatedCenterPoint=Point(0, 0), scale=0.0, specificTaskId=-1}   bMultiInstance=false   mIsLastShownWhenLocked=false             Activity 내용은 ActivityRecord.java 코드를 참고하면 된다.    3.1. packageName  the package implementing intent’s component   3.2. processName  process where this component wants to run   3.3. launchedFromPackage  always the package who started the activity.   3.4. app  if non-null, hosting application   3.5. intent  the original intent that generated us   3.6. frontOfTask  is this the root activity of its task?   3.7. task  the task this is in.   3.8. taskAffinity  as per ActivityInfo.taskAffinity   3.9. realActivity  the intent component, or target of an alias.    ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Task-stack-%EB%9C%AF%EC%96%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "안드로이드의 Thread와 Process",
        "excerpt":"   Java Thread에 대한 기본은 아래 포스팅을 참고할 것           Java의 Thread       Thread 상태를 조절하는 메서드      1. Process와 Thread           Process     프로세스는 운영체제로부터 주소공간, 파일, 메모리와 같은 자원을 할당받는 하나의 작업 단위이다.    프로세스는 자신만의 고유 공간과 자원을 할당 받기때문에 서로 다른 프로세스간 직접적인 공유가 불가능 하다.            Thread    스레드는 한 프로세스 내에서 실제 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 대부분 공유하면서 실행된다.       # 안드로이드는 Multi Process, Multi Thread 이다.  안드로이드에서 앱을 하나 실행시키면 하나의 프로세스(리눅스 프로세스)가 생성된다. 또한 하나의 프로세스에서는 여러개의 쓰레드를 생성할 수 있다.    즉, 안드로이드는 멀티프로세스, 멀티쓰레드 환경이다.   다른 프로세스간에는 자원을 공유할 수 없고, 하나의 프로세스에 있는 스레드간에는 공유가 가능하다.    따라서 하나의 앱이 잘못되어 프로세스가 죽으면 해당 프로세스에 있는 모든 스레드 역시 죽게되지만, 다른 프로세스에서 동작하는 다른 앱은 죽지않는다.     2. 리눅스 기반의 Process  안드로이드는 리눅스 커널을 사용하고 있기에 프로세스 역시 리눅스 프로세스 모델을 기반으로 한다.   리눅스는 모든 사용자에게 기본적으로 OS에 의해 추적되는 고유 번호인 UserID(UID)를 할당한다.    Root가 아닌 각 사용자는 권한으로 보호되는 개인 리소스에는 접근할 수 있으나 다른 사용자의 리소스에는 접근할 수 없다.   안드로이드에서 각 앱은 고유한 UserID를 가진다. 그렇기 때문에 각 앱의 고유 영역을 다른 앱이 접근할 수 없는 것이다.      UserID라고 해서 사용자를 뜻하는것 같지만 안드로이드 레벨에서 볼때 User는 각 앱이라고 볼 수 있다.    2.1. 프로세스, 런타임, 앱 간의 관계  보통 앱과 프로세스는 1:1의 관계지만 필요에 따라 하나의 앱이 여러 프로세스에서 각각 동작하거나 여러 앱을 하나의 프로세스에서 실행할 수도 있다.         하나의 런타임 위에서 모든 앱이 돌아가는것이 아니다. 런타임도 각 프로세스마다 독립적이다.    2.2. 앱의 시작 과정  안드로이드의 주요 컴포넌트(Activity, Service, BroadcastReceiver, ContentProvider)는 앱 시작에 대한 진입점이 될 수 있다.    앱 시작 시 아래와 같은 과정을 거친다.      리눅스 프로세스 생성   런타임 생성   Application 인스턴스 생성   요청된 앱의 진입점 컴포넌트를 생성   새로운 리눅스 프로세스를 생성하는 것과 런타임을 생성하는 것은 부하가 큰 작업이다.    따라서 안드로이드 시스템은 시스템 부트에 Zygote 라는 특별한 프로세스를 만들어 둔다. Zygote는 미리 로드된 핵심라이브러리 전체 세트를 가지고 있다.   새로운 앱 실행시 생성되는 프로세스는 바로 미리 만들어둔 Zygote 프로세스를 복제(fork)하여 만드는 방식을 사용하여 프로세스 생성 시간을 단축한다.      fork : 프로세스의 복제. fork로 자식 프로세스를 생성할 경우 데이터, heap, stack 영역이 모두 독립적으로 복제된다.    2.3. 프로세스 관련 기본 용어           사용자 ID(UID)    리눅스는 멀티유저 시스템으로 각 앱은 시스템 입장에서 별도의 사용자이다.    따라서 앱이 설치되면 고유의 사용자 ID가 할당된다.            Process ID(PID)    프로세스 고유의 식별자            부모 Process ID(PPID)    각 프로세스는 다른 프로세스에 의해서 생성되고, 프로세스끼리는 트리 계층 구조를 형성한다.    따라서 각 프로세스는 부모 프로세스를 가지게된다.    안드로이드의 경우 모든 프로세스는 Zygote를 fork하여 생성되므로 모든 프로세스 부모는 Zygote 이다.       2.4. 앱의 프로세스 정보 찾기  실행중인 모든 앱의 프로세스 정보는 ADB쉘에서 ps(process status) 명령어로 알아낼 수 있다.    참고로 안드로이드의 ps명령은 리눅스 ps와 같지만 옵션에서는 차이가 있다.   &gt; adb shell ps | grep com.skt.skaf.A000Z00040  USER      PID   PPID  VSIZE   RSS    WCHAN      PC           NAME u0_a1     11995 3187  3752432 307836 SyS_epoll_ 0000000000 S com.skt.skaf.A000Z00040   모든 Thread 정보는 -t 옵션으로 확인할 수 있다. 앱의 work Thread는 모두 UI thread로부터 만들어지기 때문에 이 thread들의 PPID는 UI thread의 PID와 동일하다.   &gt; adb shell ps -t | grep u0_a1  u0_a1     11995 3187  3971920 228360 SyS_epoll_ 0000000000 S com.skt.skaf.A000Z00040 u0_a1     12000 11995 3971920 228360 do_sigtime 0000000000 S Signal Catcher u0_a1     12001 11995 3971920 228360 futex_wait 0000000000 S ReferenceQueueD u0_a1     12002 11995 3971920 228360 futex_wait 0000000000 S FinalizerDaemon u0_a1     12003 11995 3971920 228360 futex_wait 0000000000 S FinalizerWatchd u0_a1     12004 11995 3971920 228360 futex_wait 0000000000 S HeapTaskDaemon u0_a1     12005 11995 3971920 228360 binder_thr 0000000000 S Binder_1 u0_a1     12006 11995 3971920 228360 binder_thr 0000000000 S Binder_2 u0_a1     12019 11995 3971920 228360 futex_wait 0000000000 S Thread-41486 u0_a1     12037 11995 3971920 228360 futex_wait 0000000000 S Answers Events u0_a1     12040 11995 3971920 228360 futex_wait 0000000000 S Crashlytics Exc u0_a1     12044 11995 3971920 228360 futex_wait 0000000000 S measurement-1 u0_a1     12045 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #1 u0_a1     12046 11995 3971920 228360 futex_wait 0000000000 S pool-5-thread-1 u0_a1     12059 11995 3971920 228360 futex_wait 0000000000 S Timer-0 u0_a1     12060 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #1 u0_a1     12061 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #2 u0_a1     19342 11995 3971920 228360 SyS_epoll_ 0000000000 S RenderThread u0_a1     19343 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #6 u0_a1     21386 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #4 u0_a1     21425 11995 3971920 228360 SyS_epoll_ 0000000000 S JavaBridge u0_a1     21451 11995 3971920 228360 futex_wait 0000000000 S AsyncTask #5 u0_a1     21457 11995 3971920 228360 futex_wait 0000000000 S Timer-5 ....   앱이 구동될때 많은 thread가 생성되는데 이 과정에서 리눅스 프로세스와 안드로이드 런타임을 관리하는 thread도 함께 생성된다.     앱에서 관심있게 봐야할 thread는 Main thread(UI thread), Binder thread, Background thread(work thread) 이다.     3. 안드로이드의 Thread  안드로이드에서 Thread는 기본적으로 자바의 Thread를 사용하며 이는 Linux native pthread(POSIX Thread)의 자바 구현체이다.    하지만 안드로이드 플랫폼은 여기에 특별한 속성 3가지를 더 추가하였는데 앱 관점에서 UI thread, Binder thread, Background thread 가 있다.   3.1. UI Thread(메인 Thread)  하나의 프로세스는 반드시 하나 이상의 쓰레드를 가진다.   안드로이드에서 프로세스 생성시 함께 생성되는 쓰레드를 메인쓰레드라 부른다.   DDMS에서 PID와 TID가 동일한게 메인쓰레드이다.   메인 쓰레드는 UI 쓰레드라고도 불리는데 안드로이드에서 유일하게 UI elements에 접근할 수 있는 쓰레드이기 때문이다.    안드로이드는 메인쓰레드 이외의 쓰레드가 GUI를 수정하는 것을 허용하지 않고 만약 이를 위반하면 CalledFromWrongThread Exception이 발생한다.    (메인 쓰레드만 UI 변경을 허용하게 강제로 제약함으로써 UI변경에 대한 동기화 이슈를 차단함.)   UI elements의 이벤트 처리는 순차적으로 처리되는데 만약 처리 시간이 긴 작업을 메인 thread에서 하게 될 경우 UI 전체가 block 되어 반응성이 떨어진다.    또한 안드로이드 플랫폼 자체에서 사용자 경험(사용성)을 떨어트리는 작업을 막기위해 5초이상 응답을 하지 않으면 ANR을 발생시킨다.      예제로 메인쓰레드에서 5초이상 하는 작업을 돌리면 죽지않는다. 하지만 화면을 터치하거나 하면 5초 뒤 죽는다. 메인쓰레드가 죽게되는 ANR은 메인쓰레드가 응답을 받지 않을 경우인데 화면을 터치하면 시스템이 전달한 터치이벤트를 메인쓰레드가 받지 못하게 되어 5초 뒤 죽는것이다.    3.2. Binder Thread  바인더는 안드로이드에서 서로 다른 process간 통신을 위해 사용된다.     각 프로세스는 바인더 통신을 위한 Thread pool을 가지고 있고, 프로세스간 통신시 이 thread pool을 이용해 별도의 thread에서 바인더 통신을 한다.   3.3. Background Thread(Work thread)  앱이 명시적으로 생성하는 모든 Thread는 Background Thread이다.    Background thread는 앱의 main thread(UI thread)에서 파생되기 때문에 UI thread의 속성(우선순위)들을 상속받는다.   앱에서 UI thread와 Background thread는 다르게 사용되지만 리눅스 입장에서 두 thread는 모두 평범한 네이티브 thread이며 동일하게 취급된다.     모든 UI 변경이 UI thread에서만 발생하도록 하는 제약 사항은 리눅스의 제약사항이 아니라 안드로이드 프레임워크의 WindowManager에 의해서 강제되는 것이다.   4. 리눅스의 Thread 스케줄링   리눅스에서 실행을 위한 기본 단위는 프로세스가 아니라 쓰레드로 스케줄링은 쓰레드의 스케줄링에 대한 것이다.   프로세서는 멀티 쓰레드를 위해 각 쓰레드가 실행될 실행시간을 할당받는데 그 시간을 할당해주는 역할은 스케줄러가 한다.   안드로이드의 경우 쓰레드는 리눅스 커널의 표준 스케줄러에 의해 스케줄링된다.   즉, 앱의 각 쓰레드는 프로세서로부터 실행시간을 할당받기 위해 단말 모든 앱의 모든 쓰레드와 경쟁함을 의미한다.   리눅스 커널 스케줄러는 완전히 공정한 스케줄러(completely fair scheduler-CFS)이다. ‘완전히 공정하다’는 뜻은 쓰레드의 우선순위 뿐 아니라 각 쓰레드에 부여된 실행시간을 추적하여 실행이 균형을 유지하려 한다는 것을 말한다.   참고로 쓰레드 스케줄링에 영향을 미치는 방법은 쓰레드 우선순위 와 쓰레드 컨트롤 그룹 이 있다.   4.1. 우선순위  스케줄러는 각 쓰레드의 우선순위 값을 보고 실행 시간 할당에 참고한다.   리눅스에서 쓰레드의 우선순위는 niceness value 또는 nice value 이라고 불린다.   이 값이 낮을수록 높은 우선순위에 해당한다.   안드로이드에서 리눅스 쓰레드는 -19 ~ 20 까지의 niceness 값을 가지며 default는 0이다.    쓰레드의 우선순위는 그 쓰레드를 생성한 부모 쓰레드의 값을 그대로 상속받는다.   앱은 아래 두가지 방법으로 우선순위를 변경할 수 있다.   # java.lang.Thread  Thread.setPriority(int priority) 를 사용한다.    자바의 우선순위값을 기반으로 0~10까지 할당할 수 있다.     자바는 플랫폼 독립적이기 때문에 리눅스가 할당하는 값과 다르다. 이 값은 높을수록 우선순위가 높게되는데 실제 리눅스에 맵핑되는 값(-19~20)은 필요시 찾아서 쓰자. (거의 변경되지 않지만 안드로이드 버전마다 다를 수도 있음)   # android.os.Process  Process.setThreadPriority(int priority)   Process.setThreadPriority(int threadId, int priority)    리눅스의 niceness 값을 사용하여 우선순위를 변경한다.   4.2. 컨트롤 그룹  안드로이드는 쓰레드 스케줄링을 위해 일반적인 리눅스 CFS뿐 아니라 별도의 그룹을 만들어 나누어 관리한다. (리눅스에서는 cgroups에 해당함)   컨트롤 그룹은 여러개가 있지만 앱에서 중요한 것은 foreground group과 background group 이다.     기본적으로 포그라운드 그룹이 백그라운드 그룹보다 더 많은 실행시간을 할당받는다.   앱이 사용자 눈에 보이는 경우 포그라운드 그룹에 들어있게되고, 사용자에게 보이지 않으면 백그라운드 그룹에 들어간다.    따라서 사용자 눈에 보이는 앱이 더 빠르게 동작하게 하여 사용자 경험을 향상시킨다.   컨트롤 그룹을 통해 백그라운드에 있는 앱이 포그라운드 앱의 동작에 영향을 미치는것을 최소화 한다.   하지만 포그라운드 앱은 여전히 자기 앱 구동에 필요한 여러 쓰레드를 가지고 있고 이들은 UI 쓰레드와 같은 우선순위를 가지고 있기 때문에 프로세서 할당을 경쟁한다.      UI 쓰레드에서 Background 쓰레드를 생성했기 때문에 기본적으로 우선순위가 동일하게 됨    이 문제를 해결하기 위해 쓰레드의 우선순위를 백그라운드 그룹으로 만들어버릴 수도 있다.   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)            [참고 문서]          안드로이드 가이드       도서 “이것이 안드로이드다”         ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/android/android_thread_and_process",
        "teaser": null
      },{
        "title": "안드로이드 Task",
        "excerpt":"안드로이드에서 Activity는 서로 다른 앱에서도 사용이 가능하다.     예를 들어 A앱의 A1 Activity는 A앱에서 실행이 가능하지만 B앱에서도 실행이 가능하다.     만약 A앱에서 A1 Activity를 실행하였다면 사용자 입장에서는 이 Activity가 A의 앱인것으로 느껴질 것이고, B앱에서 실행하였다면 이 Activity는 B앱인것처럼 느껴질 것이다.   이렇게 개발자 입장에서의 앱 단위인 Package와 달리 사용자 입장에서 느끼는 앱을 Task라 볼 수 있다.   실제로 Task 단위로 볼때 A1 Activity는 A의 Task에도 있지만 B의 Task에도 존재하게 된다.   구글 가이드에서는 Task를 아래와 같이 설명한다.     Task란 액티비티 컬렉션을 일컫는 말로, 사용자가 특정 작업을 수행할 때 이것과 상호 작용합니다.   액티비티는 스택 안에 정렬되며(BackStack), 이때 순서는 각 액티비티가 열린 순서와 같습니다.   1. Activity Task  정리하면 Package 단위의 앱 구분없이 실행되는 Activity의 순서에 따라 하나의 흐름이 생기는데 이를 Task라 한다. (Task에는 Activity만 들어갈 수 있어 Activity Task 라고도 함)   1.1. Activity Stack  Task는 내부에 Stack 구조를 가지고 있고, 실행되는 Activity 정보를 이 Stack에 쌓는다.              Root Activity (base Activity)     Task 내에서 최하단에 있는 Activity를 Root Activity라 한다.            Top Activity     Task의 최상단에 위치하고있어 사용자와 가장 최근에 상호작용한 Activity이다.       1.2. Task 생성과 소멸  앱을 실행하여 Activity가 생성될때 Task가 생성되고, 이후 Activity가 연속적으로 호출되면 해당 Task Stack에 쌓이게 된다.     사용자가 “뒤로가기” 를 통해 이전 Activity로 돌아가면 Task Stack에서 Activity가 POP 되어 하나씩 사라지고, 최종적으로 Root Activity가 종료되면 Task도 소멸된다.      1.3. Task 확인  아래 ADB 명령을 통해 현재 기기에 생성된 Task를 확인할 수 있다.   adb shell dumpsys activity activities &gt; result.txt      Activity의 상태를 보여달라는 명령으로 Activity에 Task 정보가 포함되어 있다.   dumpsys log 로 보는 Task 분석은 안드로이드 Task stack 뜯어보기 포스팅을 참고할 것.    2. Task 친화력 (Affinity)  Task를 집이라고 할때 각 Activity는 자신의 집(Task)에 머물기를 원한다.    집인 Task가 있으면 각 Activity는 머물고자 하는 집의 주소를 가지고 있는데 이 값이 Task Affinity(친화력) 이다.   Dump 데이터를 보면 모든 Task는 affinity 값을 가지고 있고, 모든 Activity는 taskAffinity 값을 가지고 있다.    여기서 집인 Task의 주소가 affinity이고 Activity가 가지고 있는 taskAffinity는 집의 주소에 해당한다.   어떠한 Activity가 실행됬을때 어떤 Task 안에서 실행이 되는지는 바로 이 affinity 값의 영향을 받은것이다.    동일한 taskAffinity 값을 가지는 Activity 들은 가족과 같은 그룹을 형성하고 그 그룹이 Task이다.      참고로 Task 내에 반드시 그 Task의 affinity 값을 taskAffinity로 가지는 Activity만 들어갈수 있는 것은 아니다.    Affinity는 매우 중요한 속성이다.    Affinity, Intent flag, Activity launchMode 에 따라서 새로운 Task가 생성되거나 특정 Task에 Activity가 포함되기 때문이다.     Task는 개발자가 설정한 패키지 단위의 앱과 무관하게 사용자 입장에서 느끼는 앱의 단위이기 때문에 사용성에 영향을 많이 주게 된다. 따라서 적절한 Task 구성이 되지 않으면 사용성 저하를 불러온다.   2.1. affinity 값의 설정과 변경  Task의 affinity 값은 자신을 생성한 Activity의 taskAffinity 값으로 가진다.   Activity의 taskAffinity 값은 자신이 속한 PackageName으로 가진다.    taskAffinity는 필요에 따라 AndroidManifest 에서 수정이 가능하다.   &lt;activity android:name=\".A\" android:taskAffinity=\"com.B\" /&gt;   3. Intent flag   3.0. API 21의 변화 (Document의 추가)  API 21부터 Task에 Document 라는 용어가 추가되었다.    그리고 이를 위한 Intent flag 3종이 추가되었고, manifest에는 이와 매칭되는 Activity 속성으로  documentLaunchMode 가 추가되었다,   참고로 Document라고 하는 것은 App이 동시에 여러개의 인스턴스를 유지하고자 하는 Item을 말하는데 Document라고 불리는것에서 알 수 있듯이 주 예로 텍스트 파일, 웹페이지, 스프레드시트, 이메일 등이 있다.   사용하는 예를 보면 스프레드시트를 열어주는 Activity는 SpreadSeetActivity 라는 Activity인데 A 파일과 B 파일을 서로 다른 인스턴스로 생성하고 싶은 경우이다.   이런 요구사항은 기존에 있는 FLAG_ACTIVITY_MULTIPLE_TASK 를 통해서도 할 수 있다.    하지만 실 동작의 차이가 존재하는데, FLAG_ACTIVITY_MULTIPLE_TASK로 생성된 Task는 Task가 종료 후 최근 앱 목록에 남게되지만 Document로 실행된 Task는 최근 앱 목록에 남지 않는다.   이런 차이 외에도 “문서 관리” 라는 독특한 Task 형태를 위한 몇가지 옵션이 추가되었다.   3.1. FLAG_ACTIVITY_NEW_TASK  FLAG_ACTIVITY_NEW_TASK 로 Activity를 실행하면 Activity는 자신의 taskAffinity 값을 가지고 있는 Task에서만 실행된다.   만약 taskAffinity 값으로 생성된 Task가 이미 존재한다면 해당 Task 위에서 실행이 되고, 존재하지 않으면 새로운 Task를 생성하고 그 안에서 실행이 된다. (무조건 새로운 Task를 만드는 것이 아니라는 것에 주의할 것)   만약 같은 앱 안에서 Activity의 taskAffinity를 수정하여 분리하고, 이 flag를 설정하면 실행 앱 리스트에서 2개의 Task로 나눠져 보이게 된다.   3.1.1. FLAG_ACTIVITY_NEW_TASK 를 사용하는 곳          대표적인 예가 런처앱으로, 런처앱이 타 앱을 실행시켜줄때 자기의 Task가 아닌 실행시키고자 하는 앱의 Task를 만들어줘야 하기 때문에 이 flag를 사용한다.            Activity가 아닌 컴포넌트에서 Activity를 실행하고자 할때는 무조건 이 flag를 사용해야 한다. Activity 외의 컴포넌트는 Task를 가지고 있을 수 없기 때문이다.         3.1.2. 각종 테스트     B앱이 A앱의 A1 Activity를 FLAG_ACTIVITY_NEW_TASK 로 실행한다. 이 때 B앱이 또 다시 A1 Activity를 FLAG_ACTIVITY_NEW_TASK로 호출시 어떻게 될까?              A앱의 Task에는 A1 Activity가 하나만 들어가있다. 두번 호출하였더라도 Activity가 추가로 쌓이진 않는다.           B앱이 A앱의 A1 Activity를 FLAG_ACTIVITY_NEW_TASK 로 실행한다. A1 Activity는 내부적으로 A2 Activity를 호출한다. 이후 B앱이 A1 Activity를 FLAG_ACTIVITY_NEW_TASK로 다시 호출시 어떻게 될까?              B앱이 호출 시 A앱 Task가 그냥 상위로 올라가 기존 Task의 Top Activity인 A2가 화면에 보인다. 추가로 호출되었던 A1이 A2위에 다시 쌓이지는 않는다.           B앱이 A앱의 A1 Activity를 FLAG_ACTIVITY_NEW_TASK 로 실행한다. A1 Activity는 내부적으로 A2 Activity를 호출한다. 이후 B앱이 A2 Activity를 FLAG_ACTIVITY_NEW_TASK로 호출시 어떻게 될까?              A앱의 Task에 A1,A2,A2 형태로 쌓인다. 두번째 테스트와 달리 단순히 Task가 상위로 올라오는게 아니라 새로운 Activity가 Stack에 쌓인다.           B앱이 A앱의 A1 Activity를 FLAG_ACTIVITY_NEW_TASK 로 실행한다. A1 Activity는 내부적으로 A2 Activity를 호출하는데 호출후 A1 Activity를 finish 한다. 이후 B앱이 A1 Activity를 FLAG_ACTIVITY_NEW_TASK로 다시 호출시 어떻게 될까?              B앱이 호출 시 A앱 Task가 그냥 상위로 올라가 기존 Task의 Top Activity인 A2가 화면에 보인다. 추가 호출에 의해서 Task에 A2가 두개 쌓여있지는 않다.           3.1.3. 테스트를 통한 고찰  위 2,3,4 번 결과로 볼때 Task가 최초 생성되도록 한 Activity의 Intent 정보와 연관이 있어 보인다.   두번째 테스트의 경우 A앱의 Task 자체가 A1 Activity에 의해 최초 생성이 되었다. 이후 외부에서 다시 A1 Activity를 FLAG_ACTIVITY_NEW_TASK 로 호출하게 되면 Activity 인스턴스를 추가로 생성하지 않고 기존 Task를 상위로 올리기만 한다.   세번째 테스트의 경우 A앱의 Task는 A1 Activity에 의해 생성되었고, Top Activity는 A2인 상황인데 외부에서 FLAG_ACTIVITY_NEW_TASK로 A2 Activity를 호출하니 A2 Activity 인스턴스가 추가로 생성되어 Stack에 쌓인것을 볼 수 있다.    즉, Task의 Top Activity와 FLAG_ACTIVITY_NEW_TASK는 관계가 없다는 것을 뜻한다.   네번째 테스트의 경우 A앱의 Task가 A1 Activity에 의해 생성되었는데, 이후 A1 Activity를 finish시켜 Task에서 지웠다. 이후 외부에서 FLAG_ACTIVITY_NEW_TASK로 A1 Activity를 다시 호출하였는데도, 추가로 호출되지 않고 Task만 상위로 올라온 것을 볼수있다.    즉, Task의 최하단 Activity도 FLAG_ACTIVITY_NEW_TASK와 관계가 없다는 것을 뜻한다.   정리하면, FLAG_ACTIVITY_NEW_TASK로 Activity 호출 시 단순히 Task가 상위로 올라오는가 아니면 Activity의 새로운 인스턴스를 생성하여 Task에 쌓는가는 Task를 만든 Activity와 연관이 있다고 할 수 있다.   3.2. FLAG_ACTIVITY_MULTIPLE_TASK  이 flag 는 단독으로 사용할 수 없고 FLAG_ACTIVITY_NEW_TASK 의 보조 flag 이다.   FLAG_ACTIVITY_NEW_TASK 는 기존 Task가 존재할 경우 새로운 Task를 생성하지 않는데, FLAG_ACTIVITY_MULTIPLE_TASK 는 무조건 새로운 Task를 생성한다.   이 flag를 사용하면 Activity가 실행할 때마다 새로운 Task를 생성하기 때문에 정말 특별한 경우가 아니면 사용하지 않는것이 좋겠다.   3.2.1. 새롭게 생성되는 Task의 Affinity  FLAG_ACTIVITY_MULTIPLE_TASK flag에 의해 새롭게 생성되는 Task의 affinity와 Task에 속하는 Activity의 taskAffinity는 어떻게 될까.     아래는 Dump 로그이다. (A Activity가 B Activity를 실행시키면서 flag를 준 경우)   Task id #2411 * TaskRecord{a943ac5 #2411 A=kimss.app.tasktest U=0 sz=1}   affinity=kimss.app.tasktest   realActivity=kimss.app.tasktest/.B    * Hist #0: ActivityRecord{a8497d5 u0 kimss.app.tasktest/.B t2411}       taskAffinity=kimss.app.tasktest       realActivity=kimss.app.tasktest/.B  Task id #2410 * TaskRecord{f2b6128 #2410 A=kimss.app.tasktest U=0 sz=1}   affinity=kimss.app.tasktest   realActivity=kimss.app.tasktest/.A      * Hist #0: ActivityRecord{aa838c4 u0 kimss.app.tasktest/.A t2410}       taskAffinity=kimss.app.tasktest       realActivity=kimss.app.tasktest/.A   결과적으로 위 로그를 보면 Task 2개의 affinity 값이 똑같고, Activity가 가지고 있는 taskAffinity 값 역시 동일하게 생성이 된다.   그렇다면 이 때 외부에서 FLAG_ACTIVITY_NEW_TASK  flag와 함께 이 앱에 있는 어떠한 Activity를 호출하게 되면 이 Activity는 둘중 어느 Task에 속하게 될까?     테스트 해본결과 위와 같은 상황에서는 B Activity가 있는 Task #2411 에 들어간다.    이건 단순히 Task #2410보다 #2411이 더 상위에 있기 때문인데 만약 최근 앱 목록을 눌러 Task #2410에 있는 A Activity를 한번 실행해줘서 상위로 올린다음 똑같은 테스트를 해보면, 새로운 Activity는 Task #2410에 들어가는 것을 확인할 수 있었다.   결론적으로.. 사용자가 최근에 어떤 Task를 사용했는지에 따라 결정버리게 되므로 이는 예측할수 없는 상황이 되버린다. 그냥 안쓰는게 답이다..   3.3. FLAG_ACTIVITY_BROUGHT_TO_FRONT  이 flag는 보통 사용자가 설정하는것이 아니라  시스템에 의해 설정되는 값이다.     예를 들어 Activity의 LaunchMode가 singleTask인데 해당 Activity가 이미 Task에 존재하는 상태일 경우 이 Activity는 재활용 되어야 한다. 이 때 시스템에 의해 이 flag가 자동으로 설정된다.   3.4. FLAG_ACTIVITY_CLEAR_TASK (API 11)  이 flag 는 단독으로 사용할 수 없고 FLAG_ACTIVITY_NEW_TASK 의 보조 flag 이다.     이 flag가 설정된 경우 taskAffinity 값에 의해 이 Activity가 실행되어야 할 Task가 존재할때 해당 Task내의 모든 Activity를 finish 시킨 후 Activit가 실행된다.     3.4.1. 고찰          슈퍼안드로이드 책에는 자신의 앱에서 실행할 경우 FLAG_ACTIVITY_NEW_TASK가 없어도 된다고 되어 있지만 실제로 테스트 해보면 그렇지 않다. (안드로이드 가이드에도 보면 NEW_TASK와 같이 쓰이는 flag라 되있음)    예를 들어 A1,A2,A3가 있을때 A2가 A3를 FLAG_ACTIVITY_CLEAR_TASK 로 실행한다. 예상되는 바는 Task에 A3만 존재하는 형태이지만, NEW_TASK를 주지 않으면 A1,A2,A3가 그대로 남는다.            Task를 삭제하고 다시 생성하는 것일까?      잘 모르겠다. 안드로이드 가이드에는 해당 Task의 모든 Activity를 finish 하고, 비어있는 Task의 새로운 Root Activity가 된다고 되어 있다.     모든 Activity가 finish되기 때문에 Task 자체도 삭제되었다가 다시 생성되는 것으로 이해를 했는데 노트5 단말에서 테스트해보면 그런것은 아닌듯하다.     예를 들어 A1,A2,A3가 있을때  A2가 A3를 FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK 로 실행한다.     이후 dump 로그를 뽑아보면 Task에는 A3 Activity가 Root가 되는 Task가 있음을 확인할 수 있다. 하지만 Task 정보 자체를 보면 해당 Task를 생성한 Intent 정보는 A1 Activity 라고 되어있다. 이 말은 Task 자체는 삭제되지 않고 기존 Task를 사용하였다는 것을 의미한다.       3.5. FLAG_ACTIVITY_CLEAR_TOP  만약 Activity가 Activity Stack에 이미 존재할 경우 새로운 인스턴스를 생성하지 않고, 이미 존재하는 Activity를 재활용하여 Foregroud로 가져온다.    그리고 Stack 상 해당 Activity 위에 있던 Activity들은 모두 날려 시켜버린다.   예를 들어 A,B,C,D Activity가 있는데 D가 B Activity를 호출하면서 이 flag를 주게 되면 C,D Activity는 종료되고 Stack에는 A,B만 남게 된다.   Forground로 올라오는 기존 Activity는 onCreate()를 다시 타지 않는다. (재활용이기때문에 인스턴스를 새롭게 생성하는것이 아님)    대신 Intent 처리를 위해 onNewIntent(Intent intent) 가 호출되기 때문에 새롭게 호출된 Intent 처리를 할 수 있다.   3.6. FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS  Task를 생성하는 Activity가 이 flag로 실행된 경우 “최근 앱 목록”에 나타나지 않게 된다.   3.6.1. 다양한 케이스에서의 테스트      A가 B를 띄우면서 이 flag를 준다. 하지만 새로운 Task가 아니라 자기 Task에서 실행한다.              Task를 처음 생성한건 A Activity이고, 이때 flag 설정이 되어 있지 않았기 때문에 B에 flag가 설정되어 있다고 한들 상관없이 최근 앱 목록에 나타난다.    (참고로 마지막 사용한 Activity가 B여도 상관없이 보인다. 어차피 최근 앱 목록은 Task 단위로 나타나는 것이기 때문이다)           A가 B를 띄우면서 이 flag를 준다. 또한, B를 새로운 Task로 실행한다.(NEW_TASK 및 affinity 수정)              Task가 분리되어 2개로 나타난다. B Activity를 사용중일때는 최근 사용 앱 목록에 나타나지만 다른 Task로 이동한 후 다시 최근 사용앱 목록을 보면 보이지 않는다.           2번 테스트에서 B가 C를 또 띄운 경우              최근 사용앱 목록에 보이는 것은 Task 단위이다. 따라서, C를 standard로 실행하였어도 Task를 처음 생성한 B에 의해 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 설정이 되어 있으므로 최근 앱 목록에 보이지 않는다.           3.7. FLAG_ACTIVITY_FORWARD_RESULT  Task와는 상관없이 startActivityForResult()와 관련있는 flag이다.        위와 같이 A가 B로부터 결과를 받기 위해 startActivityForResult()로 호출을 하였고, B는 C를 실행하였다.    만약 C의 결과를 A에게 전달하고 싶은 경우 또 startActivityForResult()를 호출하는 것이 아니라, 단순히 flag만을 설정하면 C의 결과를 A에게도 같이 전달할 수 있다.   3.8. FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY  이 flag는 보통 사용자가 설정하는것이 아니라 시스템에 의해 설정되는 값이다.    Activity가 “최근 사용 앱” 목록에 의해 실행이 되었을때 자동으로 설정된다.   3.9. FLAG_ACTIVITY_NO_ANIMATION (API 5)  이 flag를 사용할 경우 Activity가 나타날때 사용될 수 있는 애니메이션 효과를 사용하지 않는다.   3.10. FLAG_ACTIVITY_NO_HISTORY  이 flag로 실행된 Activity는 Activity Stack 내에 History를 남기지 않는다.     예를 들어 A,B,C 를 실행하는데 B에 flag를 준 경우 B가 실행중일때는 Activity Stack에 남아있지만, B가 Background로 내려가는 순간 finish 된다.    Background로 내려가는 순간이라고 하면 다른 Activity로 이동한 것뿐 아니라, 홈키를 눌러 밖으로 빠져나갔을때도 포함된다.     3.10.1 고찰  슈퍼안드로이드 설명에는 Activity Stack에 남아있지만, finishing=true 로 설정되어 있다고 되어 있다.    그리고 Task 밖으로 벗어난 이후 다시 dump 로그를 보면 Activity Stack에서도 사라진다고 되어있다.   예를 들어, A1-&gt;A2-&gt;A3를 실행하는데 A2를 FLAG_ACTIVITY_NO_HISTORY로 실행한다.    책 설명에는 A3가 실행중일때 dump log를 보면 Task 상에 A1,A2,A3가 다 나오고 A2의 finishing이 true로 되어있는 상태라고 한다.    그리고, 홈키를 눌러 밖으로 빠져나간 후 다시 dump log를 보면 Task에 A1,A3만 남는다고 한다.   하지만 노트5에서 테스트 해보니 해당 Activity가 background로 내려가기만 하면 무조건 Activity Stack에서 빠지는것 같다.    다시 말해 A3 Activity가 보이는 상태에서 dump log를 보면 이미 Task에는 A2가 사라진 상태이다.   뭐 이런 상태 자체가 별 의미가 있는것은 아닌듯 하다.   Dump 로그는 어차피 로그정보라 버전에 따라 출력되는 내용이 다른데 단순히 그 내용이 바뀐것일수도 있다.~   3.11. FLAG_ACTIVITY_NO_USER_ACTION (API 3)  사용자 의도와 상관없이 전화나 알람에 의해 자동적으로 Activity가 전환되는 경우 onUserLeaveHint() 메서드가 콜백되는데 이 flag를 설정하면 onUserLeaveHint() 메서드가 콜백되는 것을 방지한다.      어떠한 용도로 사용할 수 있는지 모르겠다.    3.12. FLAG_ACTIVITY_PREVIOUS_IS_TOP   If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately.   3.13. FLAG_ACTIVITY_REORDER_TO_FRONT  이 flag가 설정된 Activity가 이미 Stack에 존재하고 있다면 기존 Activity를 재활용하여 최상위로 올려준다.      기존 Activity는 onCreate()를 다시 타지 않는다. (재활용이기때문에 인스턴스를 새롭게 생성하는것이 아님)    대신 Intent 처리를 위해 onNewIntent(Intent intent) 가 호출되기 때문에 새롭게 호출된 Intent 처리를 할 수 있다.   3.14. FLAG_ACTIVITY_SINGLE_TOP  Task의 Top Activity가 같은 Activity인 경우 새로운 인스턴스를 생성하지 않고 기존 Top에 있는 Activity를 재활용 한다.   기존 Activity는 onCreate()를 다시 타지 않는다. (재활용이기때문에 인스턴스를 새롭게 생성하는것이 아님)    대신 Intent 처리를 위해 onNewIntent(Intent intent) 가 호출되기 때문에 새롭게 호출된 Intent 처리를 할 수 있다.   3.15. FLAG_ACTIVITY_TASK_ON_HOME (API 11)  이 flag 는 단독으로 사용할 수 없고 FLAG_ACTIVITY_NEW_TASK 의 보조 flag 이다.     이 flag가 설정된 경우 새롭게 생성된 Task는 런쳐 Activity가 있는 Task 위에 위치하게 된다.    이 말은 이 Task가 종료되면 무조건 런쳐로 이동한다는 것이다.   예를 들어 A가 B Activity를 실행하는데 B를 다른 Task로 실행한다.    보통의 경우라면 A Task 다음에 B Task가 실행됬기 때문에 B Activity에서 뒤로가기를 눌러 Task가 종료되면 이전의 A Task가 나타난다. (Activity Stack 에 의한것이 아니라 Task의 순서에 의해서.)     하지만 B Activity 실행시 이 flag를 주게 되면 B Task 종류 후 런쳐가 나타나게 된다.   그림으로 보면 아래와 같다.      3.16. FLAG_ACTIVITY_RESET_TASK_IF_NEEDED  이 flag는 새로운 Task를 생성하거나 이미 존재하는 Task를 foreground로 가져오는 경우가 아니라면 의미가 없다.   이 flag가 하는 역할 자체는 어떠한 타이밍을 시스템에 알려주는 역할만 하고, 실제 동작은 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET flag의 설정이나 기타 설정에 의해서 결정된다.    그리고 Task내에 존재하는 Activity에 설정이 어떤지에 따라서 Activity Stack 구조가 변경될 수도 있다.     일반적으로 이 flag를 설정하는 경우는 거의 없다.    이 flag를 사용하는 대표적인 앱은 런처앱인데 런처앱이 타 앱을 실행시킬때 이 flag를 설정한다.   이 flag를 이해하기 위해서는 런처에서 아이콘을 통해 앱을 실행하는 것과 최근 실행 앱 목록에서 최근 사용한 Task를 눌러 앱을 실행하는 동작의 차이를 보면 된다.   3.16.1. 최근 실행 앱 목록에서 앱을 실행  단순히 선택한 Task를 최상위로 올려 활성화 시키는 역할만 한다.    Task의 순서만 변화가 있고 Task 내의 Activity Stack 구조는 변화가 없다.   3.16.2. 런처 홈 아이콘을 통해 앱을 실행  런처가 아이콘을 통해 앱을 실행하는 코드는 아래와 같다.    Intent intent = new Intent();  intent.setClassName(\"kimss.app.tasktest\", \"kimss.app.tasktest.A\"); // 1.  intent.setAction(Intent.ACTION_MAIN); // 2.  intent.addCategory(Intent.CATEGORY_LAUNCHER); // 2.  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 3.  intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); // 4.  startActivity(intent);           Activity 지정   실행할 Activity를 명시적으로 지정.            Action, Category 지정   Action과 Category는 원래 암시적 Intent를 사용할때 지정한다. 그런데 런처는 명시적으로 앱을 실행하면서도 Action과 Category를 같이 지정해준다.         이 설정은 이미 앱이 실행되어 Task가 존재하면 해당 Task의 Top Activity가 활성화되도록 한다고 한다.                   FLAG_ACTIVITY_NEW_TASK 설정   각 앱은 런처의 Task가 아니라 자신의 Task에서 실행되어야 하기 때문이다.            FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 설정   Task내에 정리되어야 할 Activity가 존재한다면 정리를 하라고 시스템에 알려주는 역할을 한다.   이 flag에 의해 영향을 받는 속성과 flag는 아래에서 설명한다.       3.16.3. clearTaskOnLaunch 속성  Activity가 실행될때 해당 Activity가 기존 Task에 존재한다면 Task를 모두 비우는 역할을 한다.      위 그림을 보면 5번 동작에 의해 기존 Task가 정리됨을 볼 수 있다.    원래 런처앱에서 아이콘을 선택하면 기존 Task의 Top Activity를 불러오지만, 위와 같이 clearTaskOnLaunch 속성이 사용된 Activity가 있는 경우 앱을 처음 실행한 효과를 가져온다.   참고로 위와 같이 런처에서 실행하는 경우 clearTaskOnLaunch 속성은 앱의 메인 Activity 에서만 의미를 가진다.    A2 Activity에 속성을 주더라도 런처가 호출하는건 메인 Activity인 A1이기때문에 A2에 속성이 있든 없든 영향이 없다. 굳이 영향을 주는경우라면 외부 앱에서 FALG_ACTIVITY_RESET_TASK_IF_NEEDED flag와 함께 A2 Activity를 호출하는 경우 의미가 있을 것이다.   이 속성이 하는 역할 자체는 FLAG_ACTIVITY_CLEAR_TASK Intent flag 와 유사하다. 하지만, Intent flag의 경우 설정한 Activity를 호출할때 동작하지만, clearTaskOnLaunch 속성은 해당 Activity가 이미 Task에 존재하는 상태에서 FALG_ACTIVITY_RESET_TASK_IF_NEEDED flag가 설정되어야만 동작한다는 차이가 있다.   3.16.4. finishOnTaskLaunch 속성  Background에 있던 Task가 FALG_ACTIVITY_RESET_TASK_IF_NEEDED flag 설정을 통해 Foreground로  복귀할때 정리할 Activity가 된다.      위와 같이 이미 Task가 있는 경우 런처에서 앱을 선택하면 Task의 Top Activity인 A3로 이동한다.    그런데 Task 중에 A2는 finishOnTaskLaunch 속성이 있어 finish 가 되어버려 Task에는 A1, A3만 남는다.   이 속성이 하는 역할 자체는 FLAG_ACTIVITY_NO_HISTORY  Intent flag 나 noHistory 속성과 유사하다. 하지만 Intent flag나 noHistory의 경우 설정한 Activity를 호출할때 동작하지만, finishOnTaskLaunch  속성은 해당 Activity가 이미 Task에 존재하는 상태에서 FALG_ACTIVITY_RESET_TASK_IF_NEEDED flag가 설정되어야만 동작한다는 차이가 있다.   3.16.5. allowTaskReparenting 속성  Task를 부모라고 하고 Activity를 자식이라고 가정한다. 만약 해당 속성이 설정된 자식 Activity가 다른 부모 밑에서  실행된 경우, 친부모가 활성화될때 자식은 친부모 Task 밑으로 이동한다.   즉, 친부모 Task가 부르면 자식 Activity가 달려가는 형태이다.      위 그림을 보면 B Task에서 A Affinity를 가진 A2,A3가 실행되어 Task에 들어가 있다가 A Task가 실행되면 A2,A3가 A Task로 이동하는 것을 볼 수 있다.   이 속성은 Task 구조를 완전히 바꿔버리기 때문에 사용자에게 혼란을 줄 수 있다.    특별한 경우가 아니라면 사용하는 경우는 거의 없을 것 같지만 혹시 사용하는 경우 주의를 해야 할 것이다.   3.17. FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET (API 3, Deprecated)      설명과 테스트 결과가 달랐다. 노트5에서 테스트시 이 플래그만 붙으면 자꾸 Task 자체가 분리되버린다. API 21에서 Deprecated 되면서 같은 상수 값으로 21부터 새로 생긴 FLAG_ACTIVITY_NEW_DOCUMENT 를 사용한다. 이 flag 속성때문에 테스트 결과가 다른 것인지도 확인이 필요하다    이 flag를 사용하여 Activity가 실행되면 이후 Task가 Reset 될때 이 Activity 부터 Top Activity 까지의 모든 Activity를 종료한다.   Task의 Reset이란 Task가 Background 상태가 되었는데, 다시 Foreground가 될때 Activity의 Intent 속성이 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 으로 설정된 경우를 말한다.      위와 같이 A1이 A2를 실행할때 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET flag를 줬다. 이후 Task가 Background 로 내려간 상태에서 런처의 아이콘 선택을 통해 다시 Foreground가 될경우 A2,A3 Activity가 finish 된다.   이 flag는 백그라운드로 넘어갔을때 유지를 안해도 될 일회성 엑티비티들은 해당 플래그를 사용하면 도움이 될것이다.   3.18. FLAG_ACTIVITY_NEW_DOCUMENT (API 21)  이 flag를 사용하면 Activity는 새로운 Task의 Root Activity가 된다. (이 때 열린 Activity의 인스턴스는 document 라고 불린다.)     이 flag를 사용하거나 이에 상응하는 documentLaunchMode 속성을 사용해 Activity가 열리면 같은 Activity 지만 다른 내용을 담는 별개의 인스턴스가 생성되고, 최근앱 목록에서 보면 여러개의 Task로 나타나게 된다.   이 flag를 통해 Task가 생성될 경우 Task에 존재하는 Activity 종류 후에는 최근 앱 목록에 남지 않는 특징이 있다.   FLAG_ACTIVITY_NEW_DOCUMENT가 단독으로 사용될때는 documentLaunchMode의 intoExisting 속성과 같은 동작을 하고, 만약 FLAG_ACTIVITY_MULTIPLE_TASK flag 와 함께 사용되면 documentLaunchMode의 always 속성을 준 것과 같은 동작을 한다.   3.19. FLAG_ACTIVITY_RETAIN_IN_RECENTS (API 21)  기본적으로 FLAG_ACTIVITY_NEW_DOCUMENT flag가 설정된 Activity를 통해 생성된 Task는 종료시 최근 앱 목록에 남지 않는다.   하지만 만약 종료후에도 최근앱 목록에 남게하고 싶고, 최근앱 목록에서 선택하여 Activity를 재시작 하고 싶은 경우 이 flag를 사용하면 된다.   Activity는 autoRemoveFromRecents 나 Activity.finishAndRemoveTask() 를 통해 이 설정을 덮어쓸 수 있다.   3.20. FLAG_ACTIVITY_LAUNCH_ADJACENT (API 24)  이 flag는 split-screen multi-window 모드에서만 유효하다.        아직 직접 테스트 해보지 못함. StackOverFlow 글에 따르면 문서 내용과 다르게 이상하게 동작하는 경우가 있고 FLAG_ACTIVITY_MULTIPLE_TASK 와 함께 사용하라고 함. (참고글)    4. Launch Mode   4.1. standard  Default 값으로 Task 내 중복된 Activity를 허용한다.   4.2. singleTop  FLAG_ACTIVITY_SINGLE_TOP 속성과 동일하다.    Task 내 Top Activity와 동일한 Activity일 경우 중복하지 않고 기존 인스턴스를 재활용한다   기존 Activity는 onCreate()를 다시 타지 않는다. (재활용이기때문에 인스턴스를 새롭게 생성하는것이 아님)    대신 Intent 처리를 위해 onNewIntent(Intent intent) 가 호출되기 때문에 새롭게 호출된 Intent 처리를 할 수 있다.   4.3. singleTask  Task 내 모든 Activity를 대상으로 중복을 제한한다.     만약 Task 내에 Activity가 이미 존재한다면 새로운 인스턴스를 사용하지 않고 기존 인스턴스를 재활용한다.    또한, Activity Stack에서 해당 Activity 위에 있던 Activity는 모두 finish 된다.   기존 Activity는 onCreate()를 다시 타지 않는다. (재활용이기때문에 인스턴스를 새롭게 생성하는것이 아님)    대신 Intent 처리를 위해 onNewIntent(Intent intent) 가 호출되기 때문에 새롭게 호출된 Intent 처리를 할 수 있다.   4.3.1. 중요 특징  singleTask는 자신의 Task에서만 실행될 수 있다.      위와 같이 A1,A2,A3 Activity가 실행되는데 A2가 singleTask로 되어 있다.    이때 B앱의 B1이 A2를 호출하면, A2는 B앱의 Task가 아니라 A앱의 Task에서 동작하게 된다.   4.3.2. 다양한 케이스에서의 테스트      singleTask로 설정된 Activity는 자신의 Task에서만 실행 가능한것이 사실인지 확인.              그렇다. 만약 자신의 Task가 존재하지 않으면 자신을 Root Activity로 하는 새로운 Task를 생성한다.           A앱의 A1 Activity가 B앱의 B1 Activity를 standard로 실행한다. B1은 B2 Activity를 호출하는데 B2는 singleTask이다.              A앱 Task에 A1, B1 이 있고, B1이 B2를 실행하게 되면서 B앱 Task가 생성되면서 해당 Task에는 B2만 존재한다.           A앱의 A1 Activit가 B앱의 B1 Activity를 실행하고, B1은 B2를 실행한다. 이때 B1은 singleTask이다.              A앱의 Task에 A1이 있고, B앱의 Task에 B1, B2가 존재한다.           4.4. singleInstance  모든 Task를 대상으로 중복된 Activity를 허용하지 안는다.    또한, Task내에 오직 singleInstance 설정된 Activity 하나만 존재할 수 있다.     방으로 따지면 독방을 차지하고 있으면서 동일한 방의 중복을 허용하지 않는 상태다.   5. documentLaunchMode  이 속성은 Intent의 FLAG_ACTIVITY_NEW_DOCUMENT flag와 매칭된다.   이 속성이 설정되면 Activit는 새로운 Task의 Root Activity가 된다.    이 속성을 사용한다는 것은 하나의 App에서 여러개의 Document를 사용한다는 것으로, 최근 앱 목록에 여러개의 Task가 나타난게 된다.   5.1. none  default 값으로 아무것도 설정되지 않은 상태이다.    none으로 설정된 것은 Run-time에 변경이 가능하다. 예를 들어 Activity 호출 시 Intent.FLAG_ACTIVITY_NEW_DOCUMENT Intent의 flag를 줄 수 있다.   5.2. intoExisting  Intent.FLAG_ACTIVITY_NEW_DOCUMENT flag 를 설정한 것과 동일한 동작을 한다. (Intent.FLAG_ACTIVITY_MULTIPLE_TASK flag는 설정하지 않은 상태)   Activity를 실행시킨 Intent의 ComponentName과 Data URI를 확인하고, 기존 Task에서 해당 Activity가 포함된 Task를 찾는다. 만약 기 존재하는 Task가 발견되면 Task는 Clear된 후 Activity를 Root로 하여 재시작된다. 이 때 변경되는 Intent는 onNewIntent()를 통해 받을 수 있다.   만약 기 존재하는 Task가 없다면 새로운 Task를 생성한다.   5.3. always  intoExisting과 달리 이 Activity를 Root로 하는 새로운 Task를 항상 생성한다.    이는 Intent.FLAG_ACTIVITY_NEW_DOCUMENT와 Intent.FLAG_ACTIVITY_MULTIPLE_TASK flag를 동시에 사용한 것과 동일한 동작을 한다.   5.4. never  이 속성이 설정되면 Activity 호출 Intent에 Intent.FLAG_ACTIVITY_NEW_DOCUMENT 가 설정되어 있어도 무시된다.    이는 Activity를 호출하는 곳에서 마음대로 Intent flag를 줘서 제어하려고 하는 것을 방지한다.              [참고 문서]          안드로이드 가이드       도서 “이것이 안드로이드다”         ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/android/android_task",
        "teaser": null
      },{
        "title": "프레임워크로써의 안드로이드",
        "excerpt":"목표  OS, Framework, Library 의 차이에 대해서 구분하고 안드로이드 환경에서 앱이 동작하는 기본적인 원리에 대해서 이해한다.      프레임워크와 라이브러리 차이를 설명할 수 있다.   new Activity() 코드가 왜 없는지에 대해 설명할 수 있다.   Lifecycle을 누가 호출하는지에 대해서 설명할 수 있다.   1. 안드로이드란   1.1. OS  하드웨어와 소프트웨어를 제어하며 사용자가 컴퓨터를 쓸 수 있도록 인터페이스를 제공하는 시스템(소프트웨어).      안드로이드는 OS 이다.    1.2. Platform  소프트웨어가 실행되는 환경. 좀 더 넓은 의미로 보자면 일관된 개발/실행 환경을 제공하는 모든 하드웨어나 소프트웨어.     Platform은 OS보다 좀 더 넓은 개념으로 OS 역시 Platform 이다.     일관된 개발/실행 환경을 제공한다는 의미에서 Java, .NET 프레임워크 등 도 모두 Platform 이다.      안드로이드는 OS 이자 Platform 이다.    1.3. Library  자주 사용되는 기능을 묶어 클래스나 함수, 메서드로 만들게 되는데 이들의 집합을 Library 라 한다.    단순히 재활용 가능한 코드의 집합으로 예를 들어 C 표준 library, Java library가 있다.   1.4. Framework  프레임워크는 소프트웨어 개발에 있어 하나의 뼈대 역할을 하는데 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합이다.   프레임워크는 라이브러리보다 더 넓은 개념으로 보통 프레임워크는 라이브러리를 제공한다.      안드로이드는 앱 개발을 위해 Application Framework를 제공한다. 여기에 여러 library가 있다.    1.5. Library와 Framework의 차이     주요한 차이점은 소프트웨어 제어 흐름에 대한 주도성이 누구에게/어디에 있는가 이다.     라이브러리는 개발자가 호출하여 사용한다.    개발자 필요에 따라 사용하므로 개발의 흐름을 개발자가 가지고 있다.     프레임워크는 제어의 역전이 발생한다.    개발자가 흐름을 주도하는것이 아니라 프레임워크에 의해서 흐름이 주도되며, 개발자는 프레임워크의 요구에 맞춰 코드를 개발한다.   1.6. 안드로이드에서 Framework의 특징을 알 수 있는 예  안드로이드 주요 컴포넌트 Activity, Service, Broadcast Receiver, Content Provider 를 앱에서 구현할때 이 클래스들을 상속받은 다음 Lifecycle 메서드를 override하여 필요한 코드를 추가한다.   Activity를 구현하는 예를 본다.   // Activity를 상속받는 클래스를 생성함. class SampleActivity : AppCompatActivity() { \t \t// Activity Lifecycle 메서드인 onCreate()를 override하여 필요한 코드를 개발함. \toverride fun onCreate(savedInstanceState: Bundle?) { \t\tsuper.onCreate(savedInstanceState) \t\tsetContentView(R.layout.activity_sample) \t\tinitView() \t} }   객체 지향 프로그래밍에서 모든 것은 객체로 존재해야 한다.   그런데 안드로이드에서 Activity를 생성할때 new SampleActivity()를 호출하지 않는다.     또한, Lifecycle 메서드인 onCreate(savedInstanceState: Bundle?) 는 개발자가 호출한 적이 없는데 알아서 호출된다.   프레임워크의 특징은 뼈대 역할을 하고 제어의 역전이 발생한다고 했다.        Activity 라는걸 만들면 하나의 화면이 만들어진다는 점. (Activity가 화면이 되는 뼈대를 제공함)   onCreate()는 개발자가 호출한적이 없는데 알아서 호출이 되고, 개발자에게는 적당한 lifecycle 메서드 아래에 적당한 코드가 기입되는것이 강요된다는 점   이러한 것이 안드로이드가 프레임워크인 예라고 할 수 있다.   2. OS / Framework 로써 안드로이드     2.1. Kernel  OS의 핵심.    메모리 관리, 프로세스 관리, 쓰레드 관리, 하드웨어 드라이버 관리 등을 한다.     안드로이드는 오픈소스 OS인 리눅스의 커널을 Base로 모바일 환경에 맞게 커스터마이징 하여 사용한다.   2.2. Library  여기서 Library는 일반적으로 앱 개발할때 사용하는 android library가 아니라 system library를 말한다. 단말의 속도를 결정하는 중요한 요소라 자바가 아닌 C로 개발되어 있다.   2.3. Runtime  안드로이드 앱이 구동되는 실행 환경이다.    안드로이드에서 Dalvik, ART가 런타임에 해당한다.   일반적인 컴파일 언어는 CPU의 아키텍쳐와 플랫폼의 환경에 맞추어 기계어로 컴파일된다. 간단히 말하자면, 사람이 작성한 프로그램을 CPU가 알아들을 수 있는 언어로 바로 번역하여 저장하는 것이다. 이 CPU간의 서로 다른 “언어”가 “아키텍쳐”에 해당한다고 보면 된다.   그러나, 자바의 경우는 기본적으로 한 가지 CPU의 아키텍쳐나 환경에 맞추는 것이 아닌 바이트코드라는 것으로 컴파일 되며, 이를 실행하기 위해서는 자바 가상 머신이 필요하다. 이렇게 하는 이유는 자바는 바이트코드 하나만으로 여러 가지 아키텍쳐나 플랫폼에서 작동할 수 있도록 하는 것이 목표이기 때문이다. 아키텍쳐와 플랫폼에 맞는 가상머신만 있다면 하나의 실행 파일만 가지고도 각종 장치에서 쓸 수 있는 것이다.   안드로이드도 Java 언어를 사용하기 때문에 VM이 필수적이다. 이에 자바 가상머신(JVM)을 사용할 수 있지만, JVM은 라이센스 문제가 있어서 구글에서는 안드로이드 개발 시 Dalvik VM을 따로 개발해서 넣었다.   이후 Dalvik 대신 ART를 개발하였고, 최신 버전의 안드로이드 Runtime은 ART이다.   2.4. Application Framework  앱 개발의 기본이 되는것이 어플리케이션 프레임워크로 개발시 어플리케이션 프레임워크를 사용한다. 앱은 커널이나 시스템 라이브러리를 직접호출할 수 없고, 프레임워크의 api를 호출하여 이들을 사용할 수 있다.   2.5. Application  안드로이드 환경에서 동작하는 앱.     참고로 안드로이드 폰을 구동하면 부팅 후 런처가 뜨는데 이 런처 역시 Application에 속한다. 마치 OS의 특징인것처럼 보여 다른 계층에 존재할것 같지만 런처는 다른 앱을 구동시키는 앱일 뿐이다.   3. ActivityManagerService  startActivity()를 호출하면 누가 Activity를 생성하게 되는가? 이들을 관리하는것은 누구인가? 최근 앱 목록을 보면 어떻게 이 목록들이 나타날 수 있을까?   이들을 가능하게 하는게 ActivityManagerService 이다.    ActivityManagerService는 코어 플랫폼 서비스(시스템 서비스)로써, Application Framework에 속한다.   ActivityManagerService의 주 역할이 안드로이드 4대 Component인 Activity, Service, BroadcastReceiver, ContentProvider를 생성하고 이들의 생명주기를 관리하는 것이다.   즉, startActivity(), startService() 를 했을때 액티비티와 서비스를 생성하는 주체가 바로 ActivityManagerService 이다.        System Service는 SystemServer에 의해 단말 부팅 시 실행된다.    3.1 ActivityThread  ActivityManagerService에 의해서 실제로 Activity에 대해 관리가 이뤄지는 곳이 ActivityThread 이다.   ActivityThread는 모든 안드로이드 애플리케이션의 메인 스레드로서 액티비티 및 서비스의 생성 및 스케쥴링을 담당한다.     앱에서 Activity나 Service 생성을 요청하면 SystemService인 ActivityManagerService에게 요청이 전달된다. ActivityManagerService는 실행하고자 하는 Activity나 Service의 Process가 존재하는지 보고 존재하지 않으면 zygote process 를 통한 프로세스 생성 및 ActivityThread 생성을 요청한다.   ActivityThread 코드 참고.        [참고 문서]            참고 블로그 1       참고 블로그 2     ","categories": ["안드로이드"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/",
        "teaser": null
      },{
        "title": "함수형 프로그래밍",
        "excerpt":"절차지향, 객체지향처럼 프로그래밍 패러다임의 하나이다.     프로그래밍 패러다임  프로그래밍 패러다임은 개발자가 개발할때 대상을 어떠한 관점에서 바라봐야 하는지 기준을 제시하고 결정하는 역할을 한다. 예를 들어 객체지향 프로그래밍은 프로그램이란 서로 상호작용하는 객체의 집합이며, 객체는 책임과 역할에 따라 적절한 동작을 수행하는 것으로 정의한다. 개발자는 개발할때 이 관점에서 프로그램을 바라보기 때문에 객체를 정의하기 위한 class를 설계하게되며 메서드를 만들때 책임과 역할을 고민하여 만들게 된다.     패러다임은 소프트웨어를 바라보는 관점을 제시하는 것이기 때문에 서로 다른 모든 패러다임이 배타적인 관계인것은 아니다.     예를 들어 명령형 프로그래밍, 선언형 프로그래밍, 객체지향 프로그래밍이 있을때 명령형 프로그래밍과 선언형 프로그래밍은 대조관계 인것은 맞지만 명령형 프로그래밍과 객체지향 프로그래밍은 대조관계 는 틀린 말이다.   개발 언어가 하나의 패러다임만을 지원하는것은 아니다.    예를 들어 C++는 절차적 프로그래밍, 객체기반 프로그래밍, 객체지향 프로그래밍, 제네릭 프로그래밍 등의 요소들을 지원하도록 설계되었다.     또한, 언어가 지원하는 패러다임은 확장될 수 있다.    예를 들어 초창기 자바의 경우 함수형 프로그래밍을 지원하지 않았으나, 1.8 버전부터 함수형 프로그래밍을 지원한다.   1. 함수형 프로그래밍이란  공유 상태 (shared state), 변경 가능한 데이터(mutable data), 부수 효과(side effect) 없이 순수 함수(pure function)의 조합을 통해 프로그램을 구축하는 것. 이 때 함수의 조합은 선언적으로 표현된다.   2. 명령형 프로그래밍 vs 선언형 프로그래밍  명령형 프로그래밍과 선언형 프로그래밍은 서로 반대되는 개념이다.           명령형 프로그래밍   컴퓨터가 어떻게(How) 명령을 수행하는지를 순서대로 써 놓는 것.            선언형 프로그래밍   어떤 방법으로 해야 하는지(How)가 아니라 무엇(What)을 해야 하는지를 설명하는 것.       쉽게 말해 명령형 프로그램은 일반적으로 개발하는 방식으로 구현 동작이 어떻게 동작해야 하는지 방법(알고리즘)을 명시하는 것이라면, 선언형 프로그래밍은 방법(알고리즘)을 명시하는것이 아니라 무엇을 해야 하는지(목표)를 명시하는 것이다.      함수형 프로그래밍의 경우 선언형 프로그래밍의 하나이다.    3. 1급 객체(first class)  함수형 프로그래밍을 위해서 함수는 1급 객체여야 한다. 아래는 1급 객체가 무엇인지를 설명한다.   아래 조건을 만족하는 경우 1급 객체(first class) 라고 한다.      어떤 변수나 데이터에 할당할 수 있어야 한다.   파라미터로 전달할 수 있어야 한다.   리턴값 (return value)으로 사용할 수 있어야 한다.   JavaScript는 언어 자체에서 함수(Function)를 객체(Object)로 다루고있어 위 특징을 만족한다. 따라서 JavaScript에서 함수는 1급 객체이다.   3.1. 코틀린의 1급 객체 함수  코틀린은 아래처럼 1급 함수를 사용할 수 있도록 지원한다.           함수를 변수에 할당할 수 있음.        val firstClassFunction: () -&gt; Unit = {      println(\"This is function\")   }   val a = firstClassFunction                파라미터로 전달할 수 있음.        fun function(func: () -&gt; Unit) {      func.invoke()  }                리턴값으로 사용할 수 있음.        fun function(): () -&gt; Unit {      return { println(\"This is function\") }  }           3.2. 코틀린은 어떻게 1급 객체 함수를 지원하는가.  위 코드에 대해 자바코드로 변환해보면 코틀린이 함수를 1급 객체로 다루는 방식을 알 수 있다.   fun myFunction(func: () -&gt; Unit) { \tfunc.invoke() }  public final void myFunction(@NotNull Function0 func) { \tIntrinsics.checkParameterIsNotNull(func, \"func\"); \tfunc.invoke(); }   위와 같이 1급 객체로 사용된 함수는 임의로 FunctionX 라는 클래스의 객체로 만든다. 즉, 함수를 객체화 시켜서 1급 객체의 특징을 가질 수 있게 만들었다.   4. High-order function (고차함수)  아래 조건을 하나라도 만족하는 함수를 High-order function 이라 한다.      함수를 파라미터로 전달 받는 함수   함수를 리턴하는 함수   고차함수 조건을 보면 알수있듯 고차함수가 되려면 기본적으로 함수가 1급 객체여야 한다.   5. 람다함수, 람다식  람다 함수는 프로그래밍 언어에서 사용되는 개념으로 이름 없는 함수인 익명 함수(Anonymous functions)를 지칭하는 용어이다.   람다식은 주로 고차 함수(High-order function)에 인자(argument)로 전달되거나 고차 함수가 돌려주는 리턴값으로 쓰인다. 즉, 람다 함수는 1급 객체 함수이다.      돌도 도는 말이 많은데.. 결국 함수형 프로그래밍은 “함수가 1급 객체” 라는것에서 시작한다. 함수를 파라미터로 받거나 리턴하는 함수를 고차함수라고 하고, 이 고차함수의 파라미터 함수나 리턴 함수를 표현하는 표현식을 람다식이라 한다.    람다를 함수형 인터페이스(functional interface)라고 표현하는 내용이 많은데 이는 람다식으로 표현가능한 본체는 하나의 함수만 가진 인터페이스로 표현되기 때문이다.   예를 들어 View.OnClickListener 는 아래와 같다.   public interface OnClickListener { \tvoid onClick(View v); }   람다식을 사용하지 않고 View에 OnClickListener를 설정하는 코드는 아래와 같다.   button.setOnClickListener(object: OnClickListener { \toverride fun onClick(v: View) { \t\t// todo \t} })   람다식을 사용하면 아래와 같다.   button.setOnClickListener { v -&gt; \t// todo }   위와 같이 람다식을 사용하면 자잘한 코드를 작성하지 않아 간결해진다.   6. CallByName  파라미터로 전달 될때 평가(실행)되지 않고, 실제로 call이 될때 평가(실행)하는 것을 말한다.   fun callByValue(b: Boolean): Boolean { \tprintln(\"callByValue\") \treturn b }  fun callByName(func: () -&gt; Boolean): Boolean { \tprintln(\"callByName\") \treturn func() }      val funA: () -&gt; Boolean = { \tprintln(\"funA\") \ttrue }  fun main() { \t// CallByValue 에 의한 호출 \tcallByValue(funA()) \t \t// CallByName 에 의한 호출 \tcallByName(funA) }      callByValue() 결과 : funA, callByValue   callByName() 결과 : callByName, funA    위 예처럼 파라미터로 전달되는 시점이 아니라 호출이 발생할때 실행되는 것을 callByName 이라고 한다.   고차 함수(High-order funtion)는 CallByName으로 실행된다.   7. 순수 함수(pure function)와 부수 효과(Side effect)  아래 조건을 만족하는 함수를 순수 함수(pure function)라고 한다.      입력이 같을때 항상 같은 출력을 리턴한다.   함수의 호출이 객체의 상태를 변경하거나 외부와 상호작용하지 않는다.   콘솔이나 로그로 출력(print)하지 않는다.   파일, 데이터베이스, 네트워크 어디에도 데이터를 쓰지(write)않는다.   예외가 발생하지 않는다.   함수형 프로그래밍은 이러한 순수함수의 조합으로 프로그래밍 하는 방식을 말한다.     순수함수는 외부와의 상호작용이 없기 때문에 외부 환경에 따라 변하는 side effect(부수 효과)가 없다. 그리고 외부와 상호작용이 없다는 것은 순수 함수가 mutable data가 아니라 immutable data를 사용한다는 것을 말한다.   순수함수로 만들어진 함수는 그 함수의 결과를 계산하는 것 외에 다른 효과가 없기 때문에, 버그의 주요 원인을 제거할 수 있고, 함수의 실행 순서가 덜 중요하게 된다.   7.1. 순수 함수 예제   var z = 10 fun pureAdd(x: Int, y: Int): Int {     return x + y }     위 함수는 순수 함수이다.    var z = 10 fun nonPureAdd(x: Int, y: Int): Int {     return z + x + y }     위 함수는 순수 함수가 아니다.    fun buyCoffe(card: Card, coffee: Coffee): Card { \tcard.charge(coffe.price) \treturn card }     위 함수는 순수 함수가 아니다. 외부에서 전달받은 card 상태를 변경시켰기 때문이다. 위 코드를 순수 함수로 만들고자 한다면 card를 복사해야 한다.    fun buyCoffe(card: Card, coffee: Coffee): Card { \tval c = card.copy() \tc.charge(coffe.price) \treturn c }     위 함수는 순수 함수이다.    writeFile(fileName) updateDatabaseTable(sqlCmd) sendAjaxRequest(ajaxRequest) openSocket(ipAddress)     위와 같은 함수들은 순수함수가 아니다. 외부 상태를 변경시키기 때문이다.      [참고 문서]           위키피디아       나무위키      참고 블로그 1       참고 블로그 2      참고 블로그 3      참고 블로그 4      참고 블로그 5      참고 블로그 6      참고 블로그 7      참고 블로그 8      ","categories": ["개발 etc"],
        "tags": [],
        "url": "http://localhost:4000/%EA%B0%9C%EB%B0%9C%20etc/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
        "teaser": null
      },{
        "title": "Iterator 패턴",
        "excerpt":"1. Iterator 패턴이란  List와 같은 집합 객체들의 내부 표현 구조들을 노출시키지 않고 원소들을 반복자(Iterator)를 이용하여 접근하는 패턴이다.   자바에서 Iterator는 Inteface이자 Iterator 자체가 하나의 디자인 패턴이다.    자바에서 Iterator interface는 아래와 같다.   public interface Iterator&lt;E&gt; { \tpublic boolean hasNext(); \tpublic E next(); \tpublic void remove(); }   2. Iterator 패턴 장점   2.1. 캡슐화 측면     리스트 등의 Collection class 구현 코드가 변경되어도 순회하는 코드에 영향이 없다.   Collection class 의 상세 구현 내용에 대한 이해 없이도 순환을 사용할 수 있도록 한다.   2.2. 다형성 측면     iterator를 활용하면 ArrayList, HashMap 등 어떠한 Collection 객체를 사용하더라도 순환 방법이 동일하다.   ","categories": ["디자인패턴"],
        "tags": [],
        "url": "http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/Iterator-%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "Singleton 패턴",
        "excerpt":"1. Singleton Pattern 이란  클래스에 대해서 오직 하나의 instance만을 가지는 클래스이다.    설정과 같이 전역변수를 관리하거나 유틸성 기능을 가지는 클래스의 경우 쓸때마다 새로운 instance를 생성할 필요없이 하나의 instance만을 가지고 사용하는 것이 좋을 것이다. 이럴때는 Singleton pattern을 고려해 볼 수 있다.   2. Singleton class를 만드는 4가지 방법   2.1. 방법 1  가장 간단한 방법으로 class 로드시에 instance가 생성이 된다.    코드가 짧고 성능도 좋다. 하지만 class를 사용할때가 아니라 로드시 instance가 생성되므로 실제 사용하지 않을때도 instance가 생성되어 불필요하게 메모리를 낭비할 수도 있다.   public class Singleton {     private static final Singleton instance = new Singleton();          private Singleton(){     }          public static SingletonCounter getInstance(){         return instance;     } }   이 방법의 경우 instance를 public으로 해도 된다. 뒤에서 나오는 방법과 달리 초기화가 보장이 되기 때문이다.    단, 이때는 반드시 final로 선언하는것이 좋다. 만약 상수로 만들지 않으면 외부에서 null가 같이 instance를 변경해버릴수 있기 때문이다. 참고로 권장사항은 아니다..   2.2. 방법 2  1번 방법과 달리 class 로드시에 instance가 생성되지 않고, getInstance()가 호출시에 생성된다.    synchronized가 있는 이유는 만약 없을 경우 multi-thread 환경에서 타이밍에 따라 여러개의 instance가 생성될 수도 있기 때문이다.    synchronized 때문에 성능이 안좋은 단점이 있다.   public class Singleton {     private static Singleton instance; \t     private Singleton2(){     } \t     public static synchronized Singleton getInstance(){         if (instance == null) {             instance = new Singleton();         }     return instance;     } \t }   2.3. 방법 3  1번의 장점인 성능이 좋다는것과 2번의 장점인 사용할때만 instance를 생성한다는 장점을 합친 형태이다.    주의해야 할 부분은 (instance == null) 체크를 2군대서 한다는 것이다.     만약 A,B Thread가 동시에 접근을 하여 첫번째 null 체크를 둘다 통과했다고 가정하자.     synchronized로 인해 A가 먼저 통과를 했다면 젤 처음엔 instance가 null 이므로 instance를 생성할 것이고, A가 synchronized 를 빠져나오면 다음에 B가 접근하는데 이때는 instance가 null이 아니라 새로운 instnace를 생성하지 않는다.     여기서의 핵심은 2번처럼 synchronized를 처음부터 수행하지 않기때문에 성능이 좋다는 것이고, instance를 getInstance() 내부에서 생성하기 때문에 불필요하게 instance를 생성하지 않는다는 점이다.   public class Singleton {     private volatile static Singleton instance; \t     private Singleton3(){     } \t     public static Singleton getInstance(){         if (instance == null) {             synchronized(Singleton3.class) {                 if (instance == null) {                     instance = new Singleton();                 }             }         }         return instance;     } }   instance를 보면 volatile로 선언이 되어 있는데 volatile 키워드는 변수의 원자성을 보장한다. 자바가 new를 통해 instance를 생성하는 과정은 원자적이지 않다. 그래서 singleton이 보장되려면 volatile로 선언이 되어 있어야 한다고 한다.   2.4. 방법4  SingletonHolder라는 inner class를 사용하는 방법이다.    inner class인 Holder클래스가 호출될 때 instance를 생성하므로 3번 방법과 같이 불필요하게 instance가 생성되지도 않고 2번처럼 성능이 느리지도 않다.   public class Singleton {     private Singleton(){     } \t     private static class SingletonHolder{         static final Singleton instance = new Singleton4();     }      public static Singleton getInstatnce(){         return SingletonHolder.single;     } }   3. Singleton의 특징     instance가 오직 하나만 생성된다. (제대로 구현했다면..)   private 생성자때문에 상속이 불가능하다. (상속받은 하위 클래스 생성시 상위 클래스 생성자가 호출되기 때문에)   자바 api에서 singleton은 대부분 1번으로 구현이 되어 있다고 한다.   ","categories": ["디자인패턴"],
        "tags": [],
        "url": "http://localhost:4000/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/Singleton-%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "Collection과 Multi thread",
        "excerpt":"자바의 Collection 클래스 대부분은 thread-safety 하지 않다.   아래 예의 ArrayList는 thread-safety 하지 않다. 따라서 위 코드는  ConcurrentModificationException 이 발생한다.      참고로 이런 Multi thread 가 아니라도 ConcurrentModificationException은 발생할 수 있다 자세한 내용은 ConcurrentModificationException 포스팅을 참고할 것.    public class Main {     public static void main(String[] args) {         List&lt;integer&gt; list = new ArrayList&lt;integer&gt;();         new WriterThread(list).start();         new ReaderThread(list).start();      } }   public class ReaderThread extends Thread {     private final List&lt;integer&gt; list;      public ReaderThread(List&lt;integer&gt; list) {         super(\"ReaderThread\");         this.list = list;     }        public void run() {         while (true) {             // foreach문은 내부적으로 iterator를 사용한다.             for (int n : list) {\t                 System.out.println(n);             }         }     } }   public class WriterThread extends Thread {     private final List&lt;integer&gt; list; \t     public WriterThread(List&lt;integer&gt; list) {         super(\"WriterThread\");         this.list = list;     }        public void run() {         for (int i = 0; true; i++) {             list.add(i);     // list에 write             list.remove(0);  // list에 write         }     } }   WriterThread가 list를 변경시키기 때문에 ReaderThread의 foreach 문에서 예외가 발생한다.   이런 Collection의 동기화 문제를 해결하는 2가지 방법이 있다.   1. Collections.synchronizedList()  Collections.synchronizedList() 메서드를 이용하면 Collection 인스턴스를 동기화 시킬 수 있다.    동기화되면 Collection 클래스의 모든 메서드는 동기화되어 동작한다.    (내부 코드를 보면 parameter로 전달받는 list를 new SynchronizedList(list)로 만들고 내부적으로 호출을 synchronized로 호출하게 된다.)   주의해야 할 점은 구현에 따라 이게 모든 동기화 문제를 해결한다고 생각하면 안된다는 것이다.   참고로 Collection의 인터페이스에 따라서 Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedMap() 등이 있다.   1.1. 예 1  위의 코드를 예를 들면 아래와 같이 ReaderThread는 synchronized로 list를 동기화 처리 해야 한다.   final List&lt;integer&gt; list      = Collections.synchronizedList( new ArrayList&lt;integer&gt;() );   public class ReaderThread extends Thread {        private final List&lt;integer&gt; list;      public ReaderThread(List&lt;integer&gt; list) {         super(\"ReaderThread\");         this.list = list;     }        public void run() {         while (true) { \t\t             // list 객체로 동기화             synchronized (list) {                 for (int n : list) {                     System.out.println(n);                 }             }         }     } }   WriterThread에서 list 객체의 add(), remove()는 동기화 되어 여러 쓰레드에서 동시에 접근할 수 없다. ReaderThread의 foreach문의 경우 내부적으로 Collection을 다룰때 iterator 객체로 다루기 때문에 Collection의 동기화와 상관이 없다. 따라서, 루프문을 돌때는 list 변화가 일어나지 않도록 루프문 전체를 list 객체로 synchronized를 건 것이다.   1.2. 예 2   final List&lt;String&gt; list      = Collections.synchronizedList(new ArrayList&lt;String&gt;()); final int nThreads = 2;  ExecutorService es = Executors.newFixedThreadPool(nThreads); for (int i = 0; i &lt; nThreads; i++) {     es.execute(new Runnable() {         public void run() {             while(true) {                 try {                     list.clear();                     list.add(\"888\");                     list.remove(0);                 } catch(IndexOutOfBoundsException ioobe) {                     ioobe.printStackTrace();                 }             }         }     }); }   위 예는 여전히 문제가 발생한다. list의 각 메서드 동작이야 동기화가 되겠지만 Thread 1이 list.clear() 한 직후 Thread 2가 list.remove(0)을 하는 순간 빈 list를 지우려 하기 때문에 예외가 발생한다.   따라서 아래와 같이 동작 전체를 synchronized로 묶어야 한다.   sychronized(list) {     list.clear();     list.add(\"888\");     list.remove(0); }   2. CopyOnWriteArrayList 클래스  java.util.concurrent.CopyOnWriteArrayList 클래스는 thread-safety 하다.   final List&lt;Integer&gt; list      = new CopyOnWriteArrayList&lt;Integer&gt;();   copy-on-write는 ‘write 할 때 copy 한다’는 의미.     컬렉션에 대하여 write(추가, 수정)를 할 때마다, 내부에 확보된 배열을 통째로 복사한다. 이렇게 통째로 복사를 하면 iterator를 사용하여 element들을 순서대로 읽어가는 도중에 element가 변경될 염려가 없으므로  ConcurrentModificationException가 발생하지 않는다.    Collections.synchronizedList()를 통해서도 thread-safety한 collection을 사용할 수 있겠지만 이 경우 read에 대해서도 동기화 되어 성능상 손해가 발생한다.     이 클래스는 read에 대한 성능상 손해가 없는 대신 write할때마다 배열을 통째로 copy하기 때문에 성능저하가 심하다.    즉, 적은 write와 잦은 read가 발생할때 좋은 클래스이다.   3. BlockingQueue  보통 생산자 - 소비자 패턴에서 활용되는 큐로 많이 사용된다.    이 큐는 멀티쓰레드환경에서 대표할만한 컬렉션이다.   소비자가 꺼내어 사용할동안 생산자는 멈춰있고, 생산자가 넣을동안 소비자는 멈춰있어야한다.   4. ConcurrentHashMap  HashTable은 java2에서 Collection framework가 나오기 이전부터 있었던 클래스로 기본적으로 모든 메서드가 synchronized 로 동기화 되어 있다.    이는 Collections.synchronizedMap()을 이용해 Map을 동기화 시키는 경우도 마찬가지다.   이렇게 모든 동작이 동기화되어 있을 경우 이 객체를 참조하는 thread의 개수가 많아질수록 경쟁이 심해져 성능이 기하급수적으로 떨어진다.   반면에 ConcurrentHashMap 에서는 내부적에 여러개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 가지고 있다. 따라서 여러 쓰레드에서 ConcurrentHashMap 객체에 동시에 데이터를 삽입, 참조하더라도 그 데이터가 다른 세그먼트에 위치하면 서로 락을 얻기 위해 경쟁하지 않아 성능이 좋다.        [참고 문서]           참고 자료       참고 블로그       ConcurrentModificationException 참고       ConcurrentHashmap과 Hashtable 비교          ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/collection_and_multi_thread",
        "teaser": null
      },{
        "title": "자바 Concurrent 패키지",
        "excerpt":"java.util.concurrent 패키지에 속한 클래스들로 동시성(concurrency) 작업을 위한 클래스들이다.    동시성이란 말에서 알 수 있듯 멀티 쓰레딩 환경에서 유용한 클래스들이다.   대표적으로 Executor, Callable, Future와 같이 비동기 작업을 위한 클래스나 인터페이스들이 있고, ConcurrentHashMap, ConcurrentLinkedQueue 처럼 비동기 환경에서 안전한 Collection 클래스들도 있다.    또한, lock을 위한 ReentrantLock 클래스도 있다.   1. Collection 클래스들      CopyOnWriteArrayList   BlockingQueue   ConcurrentHashmap      관련 내용은 Collection과 Multi thread 포스팅을 참고할 것.    2. ReentrantLock      관련 내용은 자바의 Thread 포스팅을 참고할 것.    3. Executor  다수의 Thread를 사용하는 프로그램은 아래와 같은 문제가 있을 수 있다.      소규모 많은 요청이 들어올 경우 쓰레드 생성 및 종료에 따른 오버헤드가 발생한다.   생성되는 쓰레드 개수에 제한이 없기 때문에 OutOfMemoryError가 발생할 수 있다.   많은 수의 쓰레드가 실행될 경우, 쓰레드 스케줄링에 따른 오버헤드가 발생한다.   이런 문제들때문에 다수의 Thread를 사용하는 프로그램은 일반적으로 Thread pool을 구현하는데 java5에 추가된 Concurrency API의 Executor를 이용하면 이런 작업들을 쉽게 할 수 있다.   Executor는 interface로써 java api는 Thread pool, Queue 등을 사용하는 다양한 Executor 구현체를 제공한다.   public interface Executor {     void execute(Runnable command); }      3.1 ScheduledThreadPoolExecutor  Runnable이나 Callble을 구현한 비동기 작업 구현체를 실행시키는 역할을 한다.  이 때 쓰레드 풀 관리 및 스케줄링을 할 수 있다.   4. Callable  Runnable과 다르게 리턴값을 받을 수 있는 작업 interface   5. Future  비동기 작업을 Callble 구현체로 만든 경우 리턴값을 받을 수 있는데 비동기작업이다 보니 리턴값을 바로 받을 수 없고 미래의 어느 시점에 받을 수 있다.  이때 미래의 특정 시점에 결과를 받기 위해 사용하는 Interface이다.      TODO Callable, Future 추가 정리 필요.         [참고문서]           참고 블로그       ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/concurrent_package",
        "teaser": null
      },{
        "title": "ConcurrentModificationException",
        "excerpt":"Concurrent는 동시의 라는 뜻이고, Modification은 수정 이란 뜻이다.    즉, 객체의 상태를 동시에 변경하는 것을 허용되지 않는데 변경이 발생하여 상태가 깨지는 경우에 발생하는 예외이다.   1. Multi thread 문제만은 아니다.  동시에 수정이 발생한다라고 하면 Multi thread를 생각할 수 있는데 꼭 Multi Thread가 아니더라도 ConcurrentModificationException 이 발생할 수 있다.   Javadoc API 문서에서도 아래와 같이 설명한다.    Single thread 가 객체 접근을 잘못하면 exception을 throw 할 수 있다.  예를 들어 fail-fast Iterator를 가지는 Collection을 반복 처리하는 동안 Collection을 직접 수정하면 이 exception을 throw 한다.   즉, Collection이 Iterator를 통해 순회(Iterate)중인데 Collection의 수정이 발생하면 exception이 발생한다.   2. fail-fast 란?  2.1. Enumeration과 Iterator  fail-fast를 알기전에 Enumeration과 Iterator에 대해 간단히 알아야 한다.   Enumeration, Iterator 모두 자바에서 제공하는 Collection에 대해 각 항목들을 순차적으로 접근하는데 사용된다.      Enumeration - 자바 초기버전 개발된 것으로 HashTable과 Vector에서 사용 가능   Iterator - JDK 1.2(자바 2)에서 생긴 중요한 변화중 하나가 Collection 클래스들이 Collection framework 으로 통합 관리되는 것이다. Iterator는 기존 Enumeration 기능을 확장한 것으로 Collection interface를 구현한 모든 클래스에서 사용 가능하다.   Enumeration과 Iterator의 가장 큰 차이는 바로 Snap Shot 인데 여기서 fail-fast 가 나오게  된다.   2.2. Snap shot  Enumeration은 snap shot을 사용하고 Iterator는 snap shot을 사용하지 않는다. 이 차이로 인해 fail-fast가 발생한다.    스냅샷이란 순간의 상태를 말하는데 Enumeration은 컬렉션 순간의 상태를 따로 저장하고 있기때문에 컬렉션 객체의 변경에 영향을 받지 않은 것이다.   2.3. fail-fast  자바 2 이전의 Enumeration은 fail-fast 방식이 아니지만 Iterator는 fail-fast 방식이다.   컬렉션에 저장된 객체들에 대한 순차적 접근을 제공하는 컬렉션 뷰(Enumeration이나 Iterator)객체는 순차적 접근이 끝나기 전에 컬렉션에 변경이 일어나면 순차적 접근에 실패하게 된다.   이렇게 순차적 접근에 실패할 경우 Enumeration 객체는 실패를 무시하고 끝까지 순차적 접근을 제공한다.(스냅샷이 있기 때문에) 이와 달리  Iterator 객체는 ConcurrentModificationException 예외를 발생한다. (스냅샷이 없기 때문에)   이렇게 순차적 접근에 실패했을때 예외를 발생시키도록 되어 있는 방식을 fail-fast라고 한다.   좀 더 자세히 말하면 컬렉션에 변경이 발생했을때 빠르게 예외를 발생시켜 안전하지 않을지도 모르는 행위 수행을 막는 것이다.   3. ConcurrentModificationException 을 신뢰하지 말라  Javadoc API 문서에 보면 ConcurrentModificationException의 경우 최선의 노력일 뿐이니 버그를 검출하는데만 사용하고 이 exception에 의존해서 개발하지 말라고 되어있다.   실제로 경우에 따라서 예외가 발생하지 않는 경우가 있는데 이는 Iterator 순환 구조때문에 그렇다.  내부 구조에 대한 내용은 내부 구조에 대한 상세내용 를 참고한다.       [참고 문서]           ConcurrentModificationException 설명 잘되있음       Javadoc      fail-fast      내부 구조에 대한 상세내용        ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/ConcurrentModificationException/",
        "teaser": null
      },{
        "title": "Hash에 대해서",
        "excerpt":"1. Hash 란  임의의 데이터를 고정된 크기의 정수로 변환해주는 것. Hash 또는 Hashing이라 한다.    Hash 함수는 이런 역할을 하는 Hash algorithm을 구현한 함수를 말한다.   2. Hash의 용도     데이터를 저장함에 있어 빠르게 검색을 할 수 있도록 indexing 하는 key로 사용.   (만약 어떠한 데이터를 저장하는데 저장된 이후 빠르게 검색하게 하기 위해서는 데이터의 index를 만들고 해당 index에 데이터를 저장하면 된다. 이후 검색할때는 이 index에서 바로 값을 찾아낼 수 있다. hash값은 바로 이러한 index를 만들때 사용한다. )   데이터의 무결성을 확인하는데 사용된다. 예를 들어 다운로드한 파일의 무결성을 확인할때 업로더가 정상적인 hash값을 적어두면, 다운로더는 동일한 hash 함수를 통해 hash값을 얻어낸 후 값이 동일한지 확인하여 무결성을 확인한다.   데이터 무결성 확인할때 사용하는 주 용도가 전자서명이다.   3. Hash 함수(알고리즘)  Hash 함수의 특징으로 항상 한 쪽 방향으로만 연산된다.    즉, 해시된 값을 분석함으로써 원본값을 찾아내거나 해시 함수를 추출해내는 reverse engineering은 필요가 없다.    이상적인 해시함수는 이러한 분석에 의해 추론할 수 없어야 한다.     또한, 우수한 해시 함수는 서로 다른 두 개의 입력에 대해 동일한 해시 값을 만들지 않는 것이다. (이는 불가능함)     서로 다른 값에 대해서 동일한 해시 값이 리턴되는것을 해시 충돌이라 한다.    이러한 충돌 위험성이 적은 해시 함수가 훌륭한 해시 함수로 평가된다.   유명한 Hash 알고리즘으로 MD(MD1, MD2, MD5 등), SHA(SHA-1, SHA-2) 알고리즘이 있다.    참고로 MD5 해쉬는 1996년부터 취약점이 발견되었고, SHA-1 해쉬도 공격이 이미 감지되었다. 따라서 정말 중요한것은 SHA-2 해쉬를 사용하는 것을 권장한다고 한다.   4. Key-Value Table의 2가지 방법   4.1. Direct Addressing Table  key-value로 데이터를 배열에 저장하는데 key값을 직접 배열 index로 사용하고 해당 배열에 value를 저장하는 방식이다.     구조가 매우 단순하고, O(1)의 시간에 검색이 가능한 장점이 있다.    하지만 key값의 범위가 큰데 비해 저장되는 데이터가 적다면 불필요하게 메모리 소모가 크다.   예를 들어 key값의 범위가 최대 500이라면 우선 500만큼의 배열을 만들어야 한다.   4.2. Hash Table  Hash table은 Direct Addressing Table의 단점(불필요한 메모리공간)을 hash 함수로 극복한 방법이다.     Hash table의 경우 value를 hash함수를 통해 key값을 만들어내고 이 key값을 배열의 index로 사용한다.     Direct Addressing Table의 경우 input으로 들어오는 key값의 범위에 따라서 메모리 사용량이 결정되는데 Hash table의 경우 hash 함수의 구현에 따라 저장할 배열의 크기가 달라진다.   Hash table은 서로 다른 value에 대해서 유일한 index를 보장하지 못한다.    이렇게 다른 값에 대해 동일한 hash 함수값이 리턴되는걸 해시 충돌이라 하고 이러한 해시 충돌이 발생했을때 해결하는 여러가지 방법이 있다.   5. Java의 HashTable 과 HashMap   5.1. 정의  HashMap과 HashTable을 정의한다면 아래와 같다고 한다.     Key에 대한 Hash값을 사용하여 값을 저장/조회 하고, Key-Value 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array.     이 associate array를 지칭하는 다른 용어로 Map, Dictionary, Symbol Table 등이 있는데, HashMap에서는 내부적으로 Map이라는 용어를 사용하고, HashTable은 내부적으로 Dictionary 라는 용어를 사용한다고 한다.   5.2. JDK에서의 차이  HashTable은 JDK 1.0부터 있던 Api이고, HashMap은 JDK 2.0에 추가된 Collection Framework에 추가된 Api이다.    HashTable, HashMap 모두 Map 인터페이스를 구현하고 있으므로 둘이 제공하는 기능은 동일하다.   HashTable은 하위 호환성 유지때문에 존재하고 있고, 사실상 업데이트로 되지 않는 반면 HashMap의 경우 성능 개선이 지속적으로 이뤄지고 있다.    따라서 둘의 성능을 비교하는 것은 의미가 없다.   HashTable과 HashMap의 주요 차이점은 아래와 같다.      HashTable은 모든 메서드가 동기화되어 있으므로 성능상 단점이 있다.   HashMap은 보조 해시 함수를 사용하고 있어 HashTable에 비해서 해시 충돌이 덜 발생해 성능이 좋다.   6. Hash 분포와 Hash 충돌  서로다른 객체 X, Y에대해서 X.equals(Y)가 false일때 X.hashCode() != Y.hashCode() 를 무조건 만족한다면 이 Hash함수는 완전한 해시 함수(perfect hash functions)라고 할 수 있다.   만약 구분되는 객체의 종류가 유한한 경우(ex - boolean, integer, long) 객체의 값 자체를 key로 삼을 수 있고, 완전 해시 함수의 대상으로 삼을 수 있다.   하지만 String이나 일반적인 객체를 대상으로 완전 해시 함수를 만드는것은 사실상 불가능하다.    적고 빠른 연산으로 동작하는 완전 해시 함수가 존재한다 하더라도 HashMap에서 사용할 수 있는것은 아니다. (사실 hashCode() 메서드는 int값을 리턴하게 하고 있으므로 완전 해시 함수 자체가 존재할 수 없음. 세상의 모든 객체를 2^32개로 표현할 수 없으므로)     그 이유는 Direct Addressing Table의 단점과 동일한데 값을 저장하기 위한 배열의 크기가 2^32개나 존재해야 하기 때문이다.   위와 같은 메모리 이슈로 HashMap을 비롯하여 Hash함수를 사용하는 associate array 구현체들은 내부적으로 M개 크기의 배열만 사용한다.     int index = X.hashCode() % M;   관련 코드는 위와 같은데 나머지 연산을 통해 index의 범위를 0~(M-1)로 한정한다.    이 경우 서로 다른 해시 코드를 가지는 객체에 대해서도 1/M 확률로 같은 해시 버킷을 사용하는 문제가 있다.   서로 다른 객체가 동일한 Hash값을 리턴하는것을 Hash충돌이라 하는데, 위 경우는 메모리 절약때문에 서로 다른 Hash값에 대해서 동일한 index값을 리턴하는 또 다른 문제가 발생한다. 이 문제는 또다른 형태의 Hash 충돌이다.   이렇게 또 다른 형태의 Hash충돌이 발생하더라도 Key-Value값을 잘 저장하고 조회할 수 있도록 하는 방법이 여러가지가 있는데 대표적으로 Open Addressing, Separate Chaining 이 있다.      6.1. Separate Chaining  각 배열의 index는 같은 해시 버킷을 연결한 LinkedList의 Head이다.    즉, 서로 다른 객체가 같은 hash값을 가지게 되는 경우 해당 index에서 LinkedList 형태로 연결된다.     LinkedList 방식이라 처음  위치를 찾는 과정 이후에는 모든 탐색/삽입/삭제가 LinkedList의 구현을 따르게 된다.      참고로 Java 8에서 HashMap에서는 LinkedList가 아니라 Red-Black Tree로 바뀌었다고 한다.    6.2. Open Addressing  데이터를 삽입하려고 하는데 이미 해시 버킷이 사용중이라면 다른 해시 버킷에 데이터를 삽입한다.    즉, hash 값을 index 위치로 하는것을 기본으로 하지만 해당 index에 있는 값이 반드시 맞다고 할 수는 없다.    데이터를 저장/조회할 해시 버킷을 찾을때 Linear Probing, Quadratic Probing 등의 방법을 사용한다.   6.2.1. Linear Probing  충돌이 발생했을때 바로 다음 index에 데이터를 저장하는 방식이다.    다음 index로 이동한 이후에 또 충돌이 발생하면 또 다시 다음 index에 값을 저장하는 과정을 반복한다.   // k는 index, i는 충돌시 1씩 증가하는 값, m은 배열 크기 h(k,i) = (k+i) mod m      Linear Probing은 간단하지만 primary clustering 이라는 문제점이 있다.    이는 비슷한 위치에서 충돌이 자주 발생할때 하나의 데이터 덩어리를 이루게 되어 특정 위치에 데이터가 밀집하는 현상을 말한다. 이 현상이 발생하면 탐색 시간이 크게 늘어난다.   6.2.2. Quadratic Probing  primary clustering 현상을 방지하기 위해 index 증가를 1차식으로 하지 않고 2차식 형태로 만든것이다.      위는 간단한 예로 해쉬 함수는 h(k,i) = (k+i^2) mode m 형태를 취한 것이다.   Quadratic Probing은 primary clustering이 발생하지 않지만 secondary clustering 이라는 또 다른 문제가 발생한다.    이는 처음 시작 hash 값이 같을때 그 이후의 해쉬값이 모두 동일한 값으로 계산되어 충돌이 반복적으로 일어나는것을 말한다.   6.3. HashMap의 구현  JDK의 HashMap은 Separate Channing 을 사용한다.    Open Addressing은 데이터 삭제할때 효율적이기 어려운데 HashMap은 삭제가 빈번할 수 있기 때문이다.    또한, HashMap에 저장된 데이터 개수가 일정 개수 이상으로 많아지면 Open Addressing이 Separate Channing보다 느리다고 한다.        [참고 문서]           terms      NAVER 블로그(추천)       블로그     ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/Hash%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C/",
        "teaser": null
      },{
        "title": "JVM과 자바 메모리 구조",
        "excerpt":"1. JVM의 특징           플랫폼에 독립    운영체제와 무관하게 가상머신 위에서 동작함. 가상머신은 스팩이 정해져있고 구현은 OS마다 다르다.            stack 기반    대표적인 컴퓨터 아키텍처인 인텔 x86, ARM과 같은 하드웨어가 레지스터 기반으로 동작하는데 JVM은 스택 기반으로 동작한다.            Garbage Collection     메모리 정리를 알아서 한다.       2. 자바 실행 과정     2.1. 실행 과정          자바 컴파일러를 통해 .java 파일을 바이트코드로 된 .class 파일로 컴파일            Class Loader에 의해서 class 파일들이 JVM의 메모리에 로딩됨. 메서드나 클래스 변수들은 이 때 적절한 메모리 영역에 배치된다.            로딩된 class 파일은 Execution Engine을 통해 해석됨.            해석된 프로그램은 Rumtime Data Areas에 배치되어 실질적인 수행이 이루어짐. 즉, main 메서드를 찾아 순차적으로 실행하면서 지역변수, 참조변수 등을 스택에 쌓는다.            실행 중 JVM은 필요에 따라 Thread Synchronization과 Garbage Collection같은 관리작업을 수행함.       2.2. Class Loader  컴파일된 class 파일을 JVM의 메모리에 로딩한다. (런타임시에 동적으로 로딩함)   2.3. Execution Engine  Class Loader를 통해 JVM내의 데이터 영역에 배치된 바이트코드를 실행한다. Execution Engine은 자바 바이트코드를 명령어 단위로 읽어 실행한다.   2.4. Runtime Data Area  JVM도 일종의 프로그램으로 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 총 5개의 영역으로 나눌 수 있다.         위 그림이 정확히 맞는지 모르겠다. 그림에는 Heap에 Permanent Generation 영역이 있는데 다른 글을 보니 Permanent 영역의 역할이 Method Area와 동일했다. 그래서 또 찾아보니 Permanent 영역의 subset이 Method Area라고 하고 Heap에 포함된 영역이 아니라 별개 영역으로 표시하였다. JVM따라서 다른건지 정확히 잘 모르겠다.    2.4.1. Method(Static) Area     모든 Thread가 공유하는 영역으로 JVM이 시작될 때 생성되어 프로그램 종료까지 유지됨.   로딩된 Class와 Interface에 대한 Runtime Constant Pool, 멤버 변수, static 변수, 메서드와 생성자의 바이트코드 등을 저장한다.     (로딩된 클래스의 정보를 저장한다는 의미이다. static 변수는 class 정보라 이곳에 저장되고 일반 멤버 변수는 실제 객체가 생성될때 heap 영역에 할당되어 저장된다. )   구성 방식이나 GC방법은 JVM 벤더마다 다를 수 있다.   (참고) Rumtime Constant Pool     Method Area에 포함되지만 독자적인 중요성이 있다.   Class와 Interface의 상수, 멤버필드, 메서드에 대한 모든 레퍼런스를 저장한다.   JVM은 Runtime Constant Pool을 통해 해당 메서드나 멤버 필드의 메모리 상 주소를 찾아 참조한다.   2.4.2. Heap Area     instance(객체)나 배열을 저장하는 공간으로 런타임시에 동적으로 할당하여 사용된다.   Heap 영역에 생성된 객체나 배열은 Stack 영역의 변수나 다른 객체의 필드에서 참조한다.   객체가 참조되지 않는 경우 GC 대상이 된다.   구성 방식이나 GC방법은 JVM 벤더마다 다를 수 있다.   Method Area와 마찬가지로 모든 Thread에서 공유하는 영역   2.4.3. Stack Area     Thread 마다 하나씩 존재하며 Thread가 시작될 때 할당된다.   Stack Frame이라는 구조체를 저장하는 Stack으로 Frame은 메서드 호출에 대한 수행정보(메서드 정보, 지역변수, 매개변수)를 가지고 있다.   지역변수나 매개변수가 Primitive 타입인 경우 Stack 영역에 직접 저장한다.   Reference 타입 변수일 경우에는 Heap Area나 Method Area에 있는 값을 참조한다.   정리하면 메서드를 호출할 때마다 해당 메서드가 동작할때 필요한 정보들을 보고 Stack Frame을 만든 뒤  추가(push)하고 메서드가 종료되면 해당 Frame을 제거(pop)하는 동작을 수행한다.   Exception 발생 시 printStackTrace() 등의 메서드가 보여주는 Stack Trace 정보의 각 라인은 Stack Frame을 표현한 것이다.   2.4.4. PC(Program Counter) register     Thread 마다 하나씩 존재하며 Thread가 시작될 때 생성된다.   현재 수행 중인 JVM 명령 주소를 갖는다.   2.4.5. Native Method stack     자바 외 언어로 작성된 Native 코드를 위한 Stack이다.   자바는 java외의 언어로 작성된 프로그램과 연동할 수 있도록 하기 위해 JNI(Java Native Interface) 표준 규약을 제공한다.   즉, Native Code로 작성된 함수 호출을 Java 프로그램에서 직접 수행할 수 있는데 이 때 함수의 매개변수 지역변수 등을 바이트 코드로 저장한다.   2.5. 객체 생성과 메모리 예   public class Exam {     int c, d;     public int add(int a, int b) {         c = a + b;         return c;     }     public int multi(int a, int b) {         d = a * b;         return d;     } }  public class MemoryTest2 {     public static void main(String[] args) {         int sum, multi;         int x, y;         x = Integer.parseInt(args[0]);         y = Integer.parseInt(args[1]);  // 1번         Exam obj1 = new Exam();         Exam obj2 = new Exam();         // 2번         sum = obj1.add(x, y);         multi = obj2.multi(x, y);         System.out.println(\"add = \" + sum);         System.out.println(\"multipy = \" + multi);     } }           main() 메서드 실행                Exam 객체의 생성                Exam 객체의 생성    아래는 add() 메서드 수행 후 multi() 메서드가 수행되는 시점         3. 참고하면 좋은 내용   3.1. 참고   public class MemoryArchitecture {      // Member Variable(Intance Variable)     // 객체를 생성할때 Heap에 올라간다.     int n1 = 10; \t     // Member Variable(Intance Variable)     // 객체를 생성할때 Heap에 올라간다. \"Hello\"는 string constant pool에 저장되고 s1은 이를 가리킨다.     String s1= \"Hello\"; \t     // Class Variable     // Class가 로드될때 Method 영역(static 영역)에 올라간다.     static int n2= 10; \t     // final static 으로 선언하면 Class가 로드될때 Constant Pool 복사     static final int n3= 20;  \t     // parameter Variable     public static void t1(int a) {          // a, a1, b2 모두 stack에 올라간다.         int a1;         int b2;     } }   3.2. String과 메모리   String과 메모리 포스팅을 참고할 것.        [참고 문서]           참고1      참고2      참고3      참고4        ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/JVM%EA%B3%BC-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/",
        "teaser": null
      },{
        "title": "String과 메모리",
        "excerpt":"1. 문자열 생성 방식과 메모리 위치  자바에서 String을 생성하는 방법은 두가지가 있다.   String 생성 방법에 따라서 메모리 저장위치가 달라진다.   1.1 new 연산자로 생성   String name = new String(\"이름\");  new를 통해 String을 생성할 경우 메모리의 Heap 영역에 존재하게 된다.   1.2. 리터럴로 생성   String name = \"이름\"   리터럴을 이용하여 생성한 경우 메모리의 string constant pool이라는 영역에 존재하게 된다.   2. string constant pool  많은 String object가 중복 생성되는것을 방지하기 위해 JVM에는 string constant pool(string literal pool) 이라는 영역이 존재한다.     만약 문자열을 리터럴로 생성할 경우 우선 이 pool을 찾아 동일한 String이 있는지 확인하여 중복 생성을 방지하고 pool에 없을 경우 새로운 문자열을 생성하여 pool에 추가한다.   3. 문자열 비교에 대한 고찰  문자열 비교시 == 연산자를 사용하지 않고 equal() 메서드를 사용한다.    == 연산자의 경우 문자열 객체가 존재하는 메모리 위치를 비교하고, equal() 메서드는 문자열의 값 자체를 비교하기 때문이다.     그렇다면 아래의 결과는 어떻게 될까?   public void test1() {     String name1 = \"이름1\";     System.out.println(\"결과는 : \" + (name1 == \"이름1\")); }  public void test2() {     String name2 = new String(\"이름2\");     System.out.println(\"결과는 : \" + (name2 == \"이름2\")); }   위 결과에서 첫번째는 true, 두번째는 false가 리턴된다.     3.1. test1     name1 : 메서드 내의 변수이므로 stack에 생성된다. 만약 class의 멤버변수 였다면 객체가 생성될때 heap에 생성되었을 것이다.   이름1 : 모든 객체는 heap에 생성된다. 이름1 문자열 객체 역시 heap에 생성되는데, 문자열 리터럴로 생성되었기 때문에 생성된 heap의 위치는 string constant pool에 저장된다.   결국 stack에 생성된 name1은 heap에 생성된 이름1의 주소를 가리키고 있고, 이 주소값은 string constant pool에 저장된다. 두번째 결과를 확인하는 과정에서 이름1은 이미 그 전에 생성된적이 있어 string constant pool에 들어가있고 이 값은 name1 이 가리키는 주소와 동일하기에 true가 리턴된다.   3.2. test2     name2 : 첫번째와 동일하게 메서드 내의 변수이므로 stack에 생성된다.   이름2 : 첫번째와 동일하게 heap에 우선 생성된 후 string constant pool에 저장된다.   new String() : new 연산자로 새롭게 객체를 생성한다. 따라서 heap 영역에 또 다른 메모리 공간을 할당해 객체를 생성한다. 내부적으로는 이름2 를 가리키고 있을것이지만 여기를 가리키는 또 다른 객체가 생성된 것이다.   결과 비교시 name2는 이미 새롭게 heap에 할당된 곳을 가리키기 때문에 string constant pool의 이름2가 가리키는 곳과 다른 주소값을 가진다. 따라서 false가 리턴된다.      [참고 문서]           참고1       참고2       ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/string_and_memory",
        "teaser": null
      },{
        "title": "Thread 상태를 조절하는 메서드",
        "excerpt":"Thread를 대기시키는 메서드   1. sleep()  명시된 시간만큼 Thread를 대기시킨다.      sleep(long mills) : ms 만큼 대기   sleep(long mills, int nanos) : ms + nano초 만큼 대기   2. wait()  Object에 선언되어 있다.    대기 시간 설정은 sleep() 와 동일하다. 시간 설정이 되어 있지 않을 경우 notify()나 notifyAll()이 호출될때까지 대기한다.   3. join()  파라미터로 입력받은 시간만큼 해당 Thread가 죽기를 기다린다.    대기 시간 설정은 sleep()와 동일하다. 시간 설정이 되어 있지 않을 경우 죽을때까지 기다린다.     A Thread가 B Thread의 join()을 호출하면 A Thread는 B Thread가 죽기 전까지 먼저 종료되지 않는다.     만약 시간을 설정하면 그 시간만큼만 B Thread의 종료를 기다리고 그때까지 B가 죽지 않으면 A는 그대로 종료한다.      죽는 것을 기다린다. 라는 표현이 이상하긴 하지만 레퍼런스에도 그렇게 되어 있다.    3.1. join의 사용 예  Main Thread가 있고, Work Thread 여러개가 있다. Main Thread는 Work Thread들이 끝날때까지 종료가 되면 안된다.    이 때 사용하는 것이 join() 이다.   public static void main(String[] args) {     ArrayList&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;();     for(int i=0; i&lt;10; i++) {         Thread t = new Test(i);         t.start();         threads.add(t);     }      for(int i=0; i&lt;threads.size(); i++) {         Thread t = threads.get(i);         try {             t.join();         }catch(Exception e) { }     }     System.out.println(\"main end.\"); }   Thread를 깨우는 메서드   1. interrupt()  Thread를 대기시키는 메서드 (sleep, wait, join)을 모두 깨울 수 있는 메서드이다.     interrupt()가 호출되면 해당 Thread에서 isInterrupted()의 결과가 true로 리턴되고, 때대로 InterruptedException이 발생하기때문에 인터럽트 여부를 확인할 수 있다.   1.1. InterruptedException 사용 주의 점  보통 interrupt()는 Thread를 중간에 종료시키고 싶을떄 사용한다.     그리고 interrupt()를 호출 했을때 발생하는 InterruptedException로 인터럽트 여부를 구분하는 경우가 있다.    하지만 interrupt() 호출시 InterruptedException는 항상 발생하는 것이 아니다.   InterruptedException은 interrupt() 호출 당시 해당 Thread가 block 되거나 특정 상태에서만 발생한다.   즉, 잘 구동중인 Thread는 interrupt()가 호출된다고 해서 InterruptedException이 발생하지는 않는다.   1.2. Thread 종료를 위한 안전장치           flag 적용     Thread의 while() 조건에 boolean flag를 설정한다.     해당 Thread를 중간에 멈추고자 할때 flag 값을 수정한다.       boolean flag = true; public void run() {     while(flag) {         ...     }\t\t } \t public void setFlag(boolean flag) {     this.flag = flag; }                sleep() 추가하여 아주 잠깐 대기시키기     Thread의 마지막에 sleep()을 잠시 줘서 대기상태로 만든다.     만약 interrupt()가 호출된다면 잠시 대기상태로 가있는 동안 InterruptException이 발생할 것이다.     이 방법은 약간의 성능 저하가 발생한다.       public void run() {     while(flag) { \t\t\t         try{             // 1 nano초 만큼 Sleep             Thread.sleep(0,1);         }catch(Exception e) {}     }\t\t }           1.3. isInterrupted() 사용 주의 점  Thread 종료를 위한 안전장치로 flag를 언급했는데 사실 이미 flag는 존재한다.     interrupt()가 호출되면 내부적으로 플래그를 설정하여 인터럽트 여부를 설정하게 되고 이 설정 여부는 isInterrupted()로 알 수 있다.     public class SimpleThread extends Thread {     public void run() {         while(!isInterrupted()) {             ...         }     } }   isInterrupted()는 초기화 될 수 있다는 점에서 주의해야 한다.    예를 들어 interrupt() 호출 시 InterruptedException이 발생하면 이 flag값은 다시 초기화 된다.   public class SimpleThread extends Thread {     public void run() {         try{             Thread.sleep(10000);\t         }catch(InterruptedException e) {             // InterruptedException이 발생하면 flag가 초기화됨.         } \t\t         // sleep 중간에 interrupt()를 호출했을때 이 결과는 true일것 같지만 false가 리턴됨.         Log.d(TAG, \"isInterrupted() : \" + isInterrupted());     } }   이렇게 InterruptedException가 발생했는데 이 Exception을 쓰레드 내부에서 catch하면 외부에서는 이 쓰레드가 interrupted 됬는지 확인할 수 있는 방법이 없다. (flag를 초기화 시켜버리기 때문에)     이 때는 catch절에서 한번 더 interrupt() 시키는 방법이 있을 수 있다.   public class SimpleThread extends Thread {     public void run() {         try{             Thread.sleep(10000);\t         }catch(InterruptedException e) {             // InterruptedException이 발생하면 flag가 초기화됨.             // 한번 더 interrupt() 호출             Thread.currentThread().interrupt();         } \t\t         // 한번 더 interrupt()를 해줘서 true로 리턴됨.         Log.d(TAG, \"isInterrupted() : \" + isInterrupted());     } }   2. notify(), notifyAll()  wait()에 의해 대기된 Thread를 깨우는 메서드이다.    두 메서드는 Object에 정의된 메서드로 notify()는 객체의 모니터와 관련된 단일 Thread를 깨우고, notifyAll()은 객체의 모니터와 관련있는 모든 Thread를 깨운다.     ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/thread_status_method",
        "teaser": null
      },{
        "title": "자바의 Thread",
        "excerpt":"1. Thread의 기본   운영체제 레벨에서 Thread는 명령어 포인터(instruction pointer)와 스택 포인터(stack pointer) 두가지를 가지고 있다.        명령어 포인터 : 다음에 실행할 명령어를 가리킴   스택 포인터 : Thread의 독립적인 local data를 저장하는 메모리 영역을 가리킴.   CPU는 한번에 한 명령어만 처리할 수 있다.   따라서 한 CPU를 통해 멀티쓰레드 동작을 위해서 CPU는 응용 프로그램 Thread 사이에 처리 시간을 공유해야 한다.   이러한 CPU 처리 시간 공유는 스케줄러(schedular)에 의해 처리된다.   스케줄러는 CPU가 얼마나 한 Thread를 얼마동안 처리해야 하는지를 결정하는데 이런 스케줄링 전략은 다양한 방식에 의해 구현될수 있지만 보통은 우선순위 스케줄링 전략을 기반으로 한다.   자바에서 Thread 우선 순위는 Thread.setPriority(int) 를 통해 설정 할 수 있다.   최저 1에서 최고 10까지 선택할 수 있고 명시적으로 설정하지 않을 경우 default는 5이다.   그런데 스케줄링이 우선순위를 기반으로만 동작하게 된다면 낮은 우선순위의 Thread는 작업을 수행할 충분한 시간을 얻지 못할 수 있다. 이러한 상태를 기아(starvation) 상태라 한다. 따라서 스케줄러는 이러한 경우에 대한 고려도 필요하다.   멀티 Thread 환경에서 처리할 Thread의 변경은 문맥 교환(context switch) 이라고 한다.   문맥 교환은 여러 과정으로 구성된다.      현재 실행중인 thread를 나중에 다시 시작할 수 있도록 상태 저장.   저장 이후 thread를 대기상태로 만듬.   다른 thread 처리를 위해 대기 상태인 다른 thread를 복원   2. 멀티 Thread  멀티쓰레딩을 통해 동작이 동시에 실행되도록 할 수 있다. 만약 실행하는 Thread의 수가 프로세서의 수를 초과하게 되면 완벽한 동시성이 될 수 없다. 하지만 스케줄러는 Thread 사이를 빠르게 전환하며 여러 동작이 동시에 실행 되도록 한다.   멀티 Thread는 필수적이지만 아래와 같이 복잡성 증가, 자원 소비 증가 등이 동반된다.   2.1. 자원 소비 증가  각 thread는 지역변수 및 매개변수를 저장하기 위해 전용 메모리 영역이 할당된다.    이 메모리 영역은 thread가 생성될대 할당되어 thread가 종료되면 회수된다.    프로세서 입장에서는 thread가 많으면 context switch를 해야 하기 때문에 오버헤드가 생긴다.   2.2. 복잡성 증가  멀티 thread는 실행의 불확식성을 동반한다. 이러한 불확실성으로 인해 디버깅이 어려워지고 멀티 thread 조절은 또 다른 버그를 만들 위험도 있다.   2.3. 데이터 불일치  2개 이상의 서로 다른 thread가 동일한 변수를 동시에 변경하려고 할때 이 변수는 경쟁조건(race condition)에 노출된다.    경쟁조건이란 코드 실행 순서가 일정하지 않기 때문에 발생한다.   public class RaceCondition {     int sharedResource = 0; \t     public void startTwoThreads() {         Thread t1 = new Thread(new Runnable() {             public void run() {                 sharedResource++;             }         });         t1.start(); \t\t         Thread t2 = new Thread(new Runnable() {             public void run() {                 sharedResource--;             }         });         t2.start();     } }   위 예에서 sharedResource는 경쟁조건에 노출된다.     위의 또 다른 문제점은 sharedResource++, sharedResource-- 연산이다.    context switch는 바이트코드 연산 사이에서도 발생할 수 있는데 위의 --, ++ 연산의 경우 내부적으로 3가지 연산의 조합이기 때문에 더 예상할 수 없는 결과를 발생시킨다.   만약 위와같은 문제를 피하기 위해서는 코드가 각 thread에서 상호 배타적으로 동작해야 하고 이러한 영역을 원자 영역(atomic region) 이라 한다.   자바에서 원자 영역을 만들어주는 가장 기본적인 동기화 매커니즘으로 synchronized 키워드가 있다.   3. Thread Safe  여러 thread에서 객체에 접근할 때 객체가 항상 정확한 상태를 유지하는 것을 Thread safe 하다고 말한다.    즉, 객체의 상태가 경쟁조건에 빠지지 않는 것이다.   Thread safe는 여러방법이 있겠지만 기본적으로 객체 상태에 대한 접근을 제어할 수 있도록 객체를 동기화 함으로써 가능해진다.    참고로 이렇게 두개 이상의 쓰레드가 특정 자원을 공유하고 있을 때 한번에 하나의 쓰레드에게만 접근을 허용하고자 하는 영역을 임계 영역(critical section) 이라고 한다.   동기화는 현재 임계 영역에서 실행되는 thread가 있는지 확인하는 잠금 매커니즘(locking machanism)으로 만들어 진다.   자바는 아래와 같은 암시적 잠금과 명시적 잠금 매커니즘을 가지고 있다.      암시적 잠금            synchronized 키워드           명시적 잠금            java.util.concurrent.locks.ReentrantLock       java.util.concurrent.locks.ReentrantReadWriteLock           3.1. 암시적 잠금  synchronized 키워드에 의해 구현되며 자세한 내용은 (Java)synchronized.md 문서를 참고한다.   3.2. 명시적 잠금  좀 더 고급화된 잠금 전략으로 ReentrantLock 또는 ReentrantReadWriteLock 클래스를 이용할 수 있다.    (try-catch로 묶여야 해서 코드가 조금 지저분해지는 단점이 있다.)   3.2.1. ReentrantLock  ReentrantLock과 synchronized는 같은 의미를 가진다.    두 기법 모두 어느 한 thread가 임계영역에 들어온 경우 다른 thread의 접근을 차단한다.     int sharedResource; private ReentrantLock mLock = new ReentrantLock();  public void changeState() {     mLock.lock();     try{         sharedResource++;     }finally{         mLock.unlock();     } }   3.2.2. ReentrantReadWriteLock  ReentrantLock과 synchronized과 같은 기법은 다른 모든 thread가 공유 변수를 단순히 읽는 것조차 유해하다고 판단하는 방어적인 전략이다.   ReentrantReadWriteLock의 경우 읽으려는 thread는 동시에 실행되게 두면서, 쓰기는 차단한다.   int sharedResource; private ReentrantReadWriteLock mLock = new ReentrantReadWriteLock();  public void changeState() {     mLock.writeLock().lock();     try{         sharedResource++;     }finally{         mLock.writeLock().unlock();     } }  public int readState() {     mLock.readLock().lock();     try{         return sharedResource;     }finally{         mLock.readLock().unlock();     } }    참고로 ReentrantReadWriteLock은 thread가 허용 또는 차단되야 하는지 확인하기 때문에 상대적으로 복잡하고 성능이 떨어진다.    ReentrantReadWriteLock 적용의 좋은 사례는 읽기 thread가 다수 있으면서 쓰기 thread는 적은 경우이다.   4. 소비자-생성자 패턴  멀티 thread의 흔한 사례로로 한 thread는 데이터를 생산하고, 한 thread는 데이터를 소비하는 소비자-생산자 패턴(consumer-producer pattern)이 있다.   public class ConsumerProducer {     private LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();     private final int LIMIT = 10;     private Object lock = new Object(); \t     public void produce() throws InterruptedException {         int value = 0;         while(true) {             synchronized(lock) {                 while(list.size() == LIMIT){                     // 생산 최대치면 wait를 걸어서 lock 사용 권한을 넘겨준다.                     lock.wait();                     // 나중에 consume()에서 lock을 풀어주면 여기 다음 구문이 실행된다.                 }                 list.add(value++); \t\t\t\t                 // notify는 굳이 필요없을 수도 있지만 lock을 바로 풀어줘서 좀 더 빠르게 실행되게 할 수 있는 효과가 있다.                 lock.notify();             }         }     } \t     public void consume() throws InterruptedException {         while(true) {             synchronized(lock) {                 while(list.size() == 0){                     // 전부 소비하고 없으면 wait를 걸어서 lock 사용 권한을 넘겨준다.                     lock.wait();                     // 나중에 produce()에서 lock을 풀어주면 여기 다음 구문이 실행된다.                 }                 int value = list.removeFirst(); \t\t\t\t                 // notify는 굳이 필요없을 수도 있지만 lock을 바로 풀어줘서 좀 더 빠르게 실행되게 할 수 있는 효과가 있다.                 lock.notify();             }         }     } }   final ConsumerProducer cp = new ConsumerProducer();  new Thread(new Runnable() {     public void run() {         try{             cp.produce();         }catch(InterruptedException e){ \t\t\t         }     } }).start();  new Thread(new Runnable() {     public void run() {         try{             cp.consume();         }catch(InterruptedException e){ \t\t\t         }     } }).start();    5. Thread 통신   5.1. 파이프 (Pipe)  java.io 패키지의 하나로 같은 프로세스 내에서 두 쓰레드 간의 단방향 통신을 제공한다.    (생산자 쓰레드는 파이프에 데이터를 기록하고, 소비자 쓰레드는 데이터를 읽는다.)   자바의 파이프는 POSIX의 pipe operator(쉘에서 | 문자)와 비슷한 기능을 하지만 프로세스 간의 통신을 하는 POSIX pipe 와는 달리 VM 위 스레드 사이에서 출력을 리다이렉팅 한다.   파이프 자체는 두 개의 연결된 쓰레드(생산자, 소비자)에서 단방향으로만 접근할 수 있는 circular buffer(원형 버퍼)이다.    그리고 앞의 소비자-생산자 패턴에서 볼 수 있듯 파이프는 Thread safe 한 방법이다.   파이프는 시간이 오래 걸리는 어떤 작업(task)에 대해 쓰레드를 나눠 분할할 수 있게 하고, 쓰레드로 나눠진 작업(task)이 있을때 하나의 task가 끝나면 다음 task로 데이터를 옮길 수 있게한다.   파이프는 binary 데이터나 character 데이터를 전송할 수 있다.      PipedInputStream : binary 데이터 전송을 위한 생산자   PipedOutputStream : binary 데이터 전송을 위한 소비자   PipedWriter : character 전송을 위한 생산자   PipedReader : character 전송을 위한 소비자   파이프의 수명은 connection이 형성될때부터 닫힐때까지 작동한다.    이 과정을 크게 세 가지로 나누면 setup, data transfer, disconnection으로 나뉜다.      POSIX : portable operating system interface(이식 가능 운영체제 인터페이스)의 약자로써 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격이다. POSIX의 마지막 글자 X는 유닉스 호환 운영체제에 보통 X가 붙는 것에서 유래한다. 규격의 내용은 커널로의 C 언어 인터페이스인 시스템 콜 뿐 아니라, 프로세스 환경, 파일과 디렉터리, 시스템 데이터베이스(암호 파일 등), tar 압축 포맷 등 다양한 분야를 아우른다.    pipe 사용 예   PipedInputStream pipedInputStream = new PipedInputStream(); PipedOutputStream pipedOutputStream = new PipedOutputStream(); pipedInputStream.connect(pipedInputStream);  Thread inputThread = new Thread(new Runnable() {      @Override      public void run() {          try {              String string = \"Hello Pipe!\";             pipedOutputStream.write(string.getBytes());          }catch(IOException e) {              e.printStackTrace();          }      }  });  Thread outputThread = new Thread(new Runnable() {      @Override      public void run() {          try {              int data = pipedInputStream.read();              for(; data != -1; data = pipedInputStream.read()) {                  System.out.print((char)data);              }          } catch (IOException e) {              e.printStackTrace();          }      }  });  inputThread.start();  outputThread.start();     통신은 blocking 매커니즘을 가진 소비자-생산자 패턴이다.    파이프가 가득 차면 write()는 차단되고, 파이프가 비면 read()는 차단된다.     통신 완료 후에는 아래 코드로 종료한다.   pipedInputStream.close();  pipedOutputStream.close();   둘 중 하나만 닫혀도 충분하다.    단, 쓰기를 닫으면 파이프는 분리되지만 버퍼안의 데이터는 읽을 수 있다. 읽기를 닫으면 퍼버는 즉시 지워진다.   5.2. 공유 메모리 (Shared memory)  동일한 프로세스 내의 모든 스레드는 각각의 stack 영역을 제외한 모든 영역(Code, Data, Heap)을 공유한다. 이 중 Heap 영역(공유 메모리)을 이용하여 스레드간의 통신을 할 수 있다.   아래와 같이 공유메모리(heap)에 쓴 데이터는 같은 프로세스 내의 모든 쓰레드에서 접근이 가능하다.      객체 인스턴스의 경우 인스턴스는 각 쓰레드의 stack에 저장되지만 객체 자체는 heap에 저장되기 때문에 참조를 전달하여 다른 쓰레드에서 접근할 수 있다.   5.2.1. 시그널링  만일 두 스레드가 순서대로 실행되야 하며, 두 스레드 간에 Shared Memory를 사용해 통신한다면 어떻게 해야 할까? 앞서 Pipe의 예시처럼 어떤 state를 polling하여 구현할 수 있다.    Shared Memory에 state를 나타내는 변수를 만들고, 무한 루프를 돌며 state 변수가 변하는 것을 체크하는 것이다.   이 방법도 물론 잘 동작하지만, 이러한 busy waiting은 성능 저하를 초래한다.   이런것보다 Java의 built-in signaling mechanism을 이용하면 더 효율적으로 작동하게 할 수 있는데, java.lang.Object에 정의되어 있는 wait(), notify(), notifyAll() 세 개의 메서드를 사용하는 것이다.      자세한 내용은 Thread 상태를 조절하는 메서드 포스팅을 참고한다.    5.3. 블로킹 큐 (Blocking Queue)  쓰레드 시그널링은 정교한 설정이 가능한 low-level mechansim으로 다양하게 적용할 수 있지만 그만큼 고려해야 할 부분이 많아 버그를 만들기 쉽다.   자바에서는 이를 위해 단방향 통신에 대해 추상화된 high-level signaling mechansim을 제공하는데 그게 java.util.concurrent.BlockingQueue 이다.        java.util.concurrent.BlockingQueue 인터페이스들의 구현체로는 여러 가지가 있는데, Array로 구현되어 고정 크기를 가지는 ArrayBlockingQueue, Linked List로 구현된 LinkedBlockingQueue, Priority를 가지는 PriorityBlockingQueue, insert와 remove가 동시에 이루어지는, 크기가 항상 0으로 유지되는 SynchronousQueue 등이 있다.      API 문서    Blocking queue 사용 예   class Producer implements Runnable {     private final BlockingQueue queue;     Producer(BlockingQueue q) { queue = q; }     public void run() {         try {             while (true) { queue.put(produce()); }         } catch (InterruptedException ex) { ... handle ...}     }     Object produce() { ... } }  class Consumer implements Runnable {     private final BlockingQueue queue;     Consumer(BlockingQueue q) { queue = q; }     public void run() {         try {             while (true) { consume(queue.take()); }         } catch (InterruptedException ex) { ... handle ...}     }     void consume(Object x) { ... } }  class Setup {     void main() {         BlockingQueue q = new SomeQueueImplementation();         Producer p = new Producer(q);         Consumer c1 = new Consumer(q);         Consumer c2 = new Consumer(q);         new Thread(p).start();         new Thread(c1).start();         new Thread(c2).start();     } }   Producer는 BlockingQueue.put()을 하고, Consumer는 BlockingQueue.take()를 하는 것만으로 Thread Safe한 통신을 구현할 수 있다. 내부적으로 atomical하게 작동하도록 lock을 컨트롤 해 주기 때문이다.    ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/thread",
        "teaser": null
      },{
        "title": "finalize 를 사용하지 말것",
        "excerpt":"7. finalize 를 사용하지 말것  C++의 경우 생성자와 소멸자를 쌍으로 만들지만 자바의 경우는 GC가 불필요한 메모리를 정리하기 때문에 소멸자가 필요하지 않다.   자바에서 소멸자인 finalize는 절대로 사용하면 안된다.   finalize의 단점  자바의 finalize의 경우 예측이 불가능하고, 위험하며 불필요하다.   1. 즉시 실행된다는 보장이 없다.  객체에 대한 모든 참조가 사라지고 난 이후 finalize가 언제 호출될지는 알 수가 없다.    이 호출 시점은 GC의 알고리즘에 좌우되고 이는 JVM에 따라서 다르다.   따라서  파일을 닫는것과 같은 행위를 finalize에서 하면 안된다. file descriptor는 시스템에서 유한한 자원인데 언제 호출될지 모르는 finalize에서 이를 반환하게 하면 자칫 다음 파일을 열때 파일 개수 제한에 걸려 오류가 날 수도 있다.   2. 실행 된다는 보장도 없다.  자바 명세에는 종료자가 즉시 실행되어야 한다는 내용도 없지만 반드시 실행되어야 한다는 내용도 없다. 따라서 JVM에 따라 아예 실행이 되지 않을 가능성도 있다.   3. 객체 상태를 망가트릴 수 있고, 예외를 던지지 않는다.  finalize 실행 도중 uncaught 예외가 발생할 경우 해당 예외는 무시되고 종료 과정은 그냥 중단된다.    무시되는 예외는 stack trace에 표시되지 않고 경고조차 뜨지 않는다.   4. 프로그램 성능이 심각하게 떨어진다.  테스트를 해보면 finalize를 사용하는 경우 객체의 생성과 소멸 시간이 엄청나게 늘어난다고 한다.   finalize의 실행          System.gc(), System.runFinalization()     이 메서드를 호출하는 방법이 있는데 이 역시 종료자의 호출 가능성을 높여주는 것 뿐 명시적으로 실행을 보장하는 것은 아니다.            System.runFinalizersOnExit(), Runtime.runFinalizersOnExit()     종료자의 실행을 보장하는 메서드이다. 하지만 심각한 결함이 있어 이미 명세에서 폐기되었다.          뒷부분 추가 정리할 부분 남았음.   ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/finalize-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EA%B2%83/",
        "teaser": null
      },{
        "title": "synchronized",
        "excerpt":"   자바 Thread에 대한 내용은 자바의 Thread 포스팅을 참고할 것.      자바에서는 synchronized 키워드를 이용해 Multi Thread 환경에서 동기화를 제공한다.     synchronized 키워드는 메서드 앞에 쓰여 메서드에 대한 동기화가 되거나 synchronized 블럭을 만들면서 객체를 전달하여 객체에 대한 동기화를 할 수 있다.   1. instance method 동기화   public synchronized void add(int value){     this.count += value; }   위와 같은 instance 메서드 동기화는 자기 instance(this)를 기준으로 동기화 한다.    클래스가 기준이 아니라 객체가 기준이라는 것에 주의하자. 해당 객체에서 synchronized 가 걸린 모든 메서드는 동기화 된다.    즉, 하나의 인스턴스에 대해 여러 Thread에서 동시에 접근할 수 있는 메서드는 단 하나이다.      햇갈리지 말자. 동기화는 객체를 기준으로 되는것이고, synchronized가 걸린 해당 메서드만 동기화 되는게 아니라 해당 클래스에 있는 모든 synchronized 메서드는 동기화된다.    예를 들어 아래와 같은 코드가 있다.    public class BlackOrWhite {     private String str;     private final String BLACK = \"black\";     private final String WHITE = \"white\";          public synchronized void black(){         str = BLACK;         try {             long sleep = (long) (Math.random()*100L);             Thread.sleep(sleep);             if (!str.equals(BLACK)) {                 System.out.println(\"++++++broken!!++++++\");             }         } catch (InterruptedException e) {             e.printStackTrace();         }     }     public synchronized void white(){         str = WHITE;         try {             long sleep = (long) (Math.random()*100L);             Thread.sleep(sleep);             if (!str.equals(WHITE)) {                 System.out.println(\"++++++broken!!++++++\");             }         } catch (InterruptedException e) {             e.printStackTrace();         }     } }   public class Test {          public static void main(String[] args) {         final BlackOrWhite bow = new BlackOrWhite();         Thread white = new Thread() {             public void run() {                 while (true) {                     bow.white();                 }             }         };         Thread black = new Thread() {             public void run() {                 while (true) {                     bow.black();                 }             }         };         white.start();         black.start();     } }   위 코드에서 whtie Thread와 black Thread는 bow 라는 인스턴스를 공유하면서 각자 white()와 black() 메서드를 호출한다.   위 내용을 실행해보면 동기화가 잘 이루어져 broken 이라는 문자는 절때 찍히지 안는다.     서로 다른 Thread에서 각각 black()과 white()를 호출하고 있지만 두 메서드 모두 bow 인스턴스의 메서드 콜이기 때문에 동일한 객체에 대한 동기화가 이루어 진 것이다.   2. static method 동기화   public static synchronized void add(int value){     count += value; }   위와 같이 static 메서드 동기화는 이 메서드를 가진 클래스 객체를 기준으로 이루어진다.    JVM 안에 클래스 객체는 클래스 당 하나만 존재할 수 있다.   즉, 인스턴스에 따라서 동기화되는 instance 메서드 동기화와 달리 static 메서드 동기화는 클래스에 대해서 동기화 되어 어떤 인스턴스가 어떤 Thread에서 실행되던지와 무관하게 동시에 접근이 불가능하다.   3. 동기화 블럭을 활용한 객체 동기화  동기화가 반드시 메서드 전체에 대해 이루어져야 하는 것은 아니다. 동기화를 잘못 할 경우 전체 성능을 크게 떨어트리기 때문에 종종 메서드 특정 부분에 대해서만 동기화를 제공하는 것이 효율적일 수 있다.   public void add(int value){     synchronized(this){         this.count += value;        } }   위와 같이 메서드 안에서 synchronized 블럭을 따로 쓸 수 있다.   참고로 위와 같이 메서드 내부 전체가 synchronized 블럭으로 잡힌 경우 메서드 자체에 synchronized를 건 것과 동일한 동작을 하게 된다.   동기화 블럭은 객체를 전달받고 있다.(여기에서는 자기 자신 객체인 this가 전달되었다. 자기 자신이라 함은 현재 add를 호출한 객체를 의미한다.)   이와 같이 동기화 블럭안에 전달되는 객체를 모니터 객체 라고 한다. 동기화 블럭은 모니터 객체를 기준으로 동기화가 이루어진다.      현재 메서드 자체에 synchronized를 건것과 동일한 이유는 synchronized를 건 범위가 메서드 구현부 전체이면서 모니터 객체가 this이기 때문이다.    만약 method가 static 이라면 모니터 객체로 자기 자신 클래스(XXX.class)로 하면 역시 동일한 의미를 가진다.   3.1. 모니터 객체 활용   public class TwoMap {     private Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;();     private Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;();          public synchronized void put1(String key, String value){         map1.put(key, value);     }     public synchronized void put2(String key, String value){         map2.put(key, value);     }          public synchronized String get1(String key){         return map1.get(key);     }     public synchronized String get2(String key){         return map2.get(key);     } }   위 코드는 비효율적으로 동작한다. 실제로 동기화가 이뤄져야 하는 코드는 put1()과 get1() 그리고 put2()와 get2()이다. 하지만 모든 인스턴스 메서드에 synchronized가 걸려있어 하나의 인스턴스는 동시에 하나의 메서드만 사용이 가능하게 되버린다.    실제로는 pu1이 실행됨과 동시에 pu2가 실행되어도 무관한데 말이다.   이 때 모니터 객체를 활용할 수 있다.   public class TwoMap {     private Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;();     private Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;();     private final Object syncObj1 = new Object();     private final Object syncObj2 = new Object();          public void put1(String key, String value){         synchronized (syncObj1) {             map1.put(key, value);         }     }     public void put2(String key, String value){                 synchronized (syncObj2) {             map2.put(key, value);         }     }        public String get1(String key){         synchronized (syncObj1) {             return map1.get(key);         }     }     public String get2(String key){         synchronized (syncObj2) {             return map2.get(key);         }     } }    위는 동기화 되어야 하는 쌍인 put1(), get1()이 syncObj1 객체에 의해 동기화 되고 put2(), get2()가 syncObj2 객체에 의해 동기화되어 이전보다 효율적으로 동작한다.   3.2. 클래스 객체 동기화   private void printLog(String log) {      synchronized (java.lang.Object.class) {         System.out.println(\"디버깅 시작했다~\");         System.out.println(log);         System.out.println(\"디버깅 끝났다~\");     } }   위는 모니터 객첼 모든 class의 부모인 Object 클래스 객체에 대해서 동기화를 했다.   이 코드는 어떤 클래스가 어떤 Thread에서 실행되든지 절때 중복해서 실행되지 않는다.   이렇게 클래스를 기준으로 동기화 할 경우 static 메서드 동기화와 같이 같은 클래스에 대해서 동기화 되어 어떤 인스턴스가 어떤 Thread에서 실행되던지와 무관하게 동시에 접근이 불가능하다.   참고로 아래 둘은 같은 동작을 한다.   class MyClass {     public static synchronized void add(int value){         count += value;     } }   class MyClass {     public static void add(int value){         synchronized (MyClass.class) {             count += value;         }     } }   4. 자바 Concurrency 유틸리티     자바 Concurrent 패키지 관련은 Concurrent 패키지 포스팅을 참고할 것.    synchronized 키워드는 여러 쓰레드에 공유되는 객체에 대한 동기화 매커니즘이다. 이 방식은 아주 훌륭한 방식은 아니었고 이후 보다 나은 동시성 컨트롤을 위해 Concurrency API가 나왔다. (Java 5)   synchronized가 암시적인 lock이라면 concurrent package에 있는 ReentrantLock은 명시적인 lock 객체이다.        [참고 문서]           참고 블로그1       참고 블로그2         ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/java_synchronized",
        "teaser": null
      },{
        "title": "자바의 Reference 형태와 GC",
        "excerpt":"1. 자바의 GC(Garbage Collector)  GC는 프로세스의 힙 영역에 할당된 메모리 중 더 이상 사용되지 않는 메모리를 주기적으로 회수함으로써 프로세스 메모리를 관리한다.    자바에서 GC는 다양한 형태가 있지만 공통적으로 다음과 같은 작업을 한다.        힙(heap) 내의 객체 중 garbage를 찾는다.   찾아낸 garbage를 처리해서 힙의 메모리를 회수한다.   GC가 garbage를 판단하기 reachability 라는 개념을 사용하는데 객체의 참조 형태에 따라 reachability 세분화하여 GC의 동작을 다르게 지정한다.   2. GC와 Reachability  자바의 GC는 reachability 라는 개념을 이용해 garbage를 판단하는데, 어떤 객체에 유효한 참조가 있으면 reachable(도달 가능한) , 유효한 참조가 없으면 unreachable(도달할 수 없는)로 구별하고 unreachable인 객체를 garbage로 간주해 GC를 처리한다.    (reachable 상태는 더 세분화 될 수 있음)   참고로 reachability 탐색을 위한 최초 객체를 GC root 객체라고 부른다. 즉, GC는 GC root가 도달할 수 없는 객체의 메모리를 회수하는 것이다.   2.1. root set  한 객체는 여러 다른 객체를 참조하고, 참조된 다른 객체들도 마찬가지로 또 다른 객체들을 참조할 수 있으므로 객체들은 참조 사슬을 이룬다. 이런 상황에서 유효한 참조 여부를 파악하려면 항상 유효한 최초의 참조가 있어야 하는데 이를 객체 참조의 root set이라고 한다. (gc root의 집합)   JVM에서 메모리 영역인 런타임 데이터 영역(runtime data area)의 구조를 그림으로 그리면 다음과 같다.         자바 메모리 구조는 (Java) JVM과 자바 메모리 구조.md 참고    자바 메모리 구조에서 Runtime Data Area는 5개 영역으로 나뉠 수 있는데 이 중 PC Register를 제외한 4가지 영역이 GC와 관련있다.      Stack Area   Native Stack Area   Heap Area   Method(Static) Area   화살표는 객체의 참조를 나타낸다. GC root set에 포함될수 잇는 GC root 객체는 Heap 외부에서 접근하는 객체들이다.   즉, 아래의 3가지 경우가 GC root 객체가 되는 것이다.      Stack Area에서 Heap에 있는 객체에 참조. 즉, 어떤 메서드 실행 시에 사용하는 지역 변수와 파라미터들에 의한 참조   Native Stack Area에서 Heap에 있는 객체에 참조. 즉, JNI(Java Native Interface)에 의해 생성된 객체에 대한 참조   Metthod Area에서 Heap에 있는 객체에 대한 참조. 즉, 클래스의 static 변수에 의한 참조      위 그림에서 참조는 java.lang.ref패키지를 사용하지 않은 일반적인 참조이며 이를 strong reference 라고 부른다.   (참고) 안드로이드 GC 특징  GC와 관련된 용어 중 stop-the-world라는 용어가 있다.    JVM에서 GC가 호출되면 응용프로그램의 실행이 일시적으로 멈추는 현상을 말하는 것이다.   안드로이드 달빅VM 역시 진저브레드까지 메모리가 회수되는 동안 앱의 실행이 중지되었다.    이로 인해 GC될때 UI 렌더링이 일시중지되어 사용자 경험을 크게 떨어트리는 요인이 되었다.     허니콤부터는 GC가 별도의 Thread에서 비동기로 실행된다.   3. Soft, Weak, Phantom Reference  java.lang.ref 패키지는 3가지의 reference 타입을 클래스로 제공하는데 이를 이용하면 개발자가 GC 처리 과정에 영향을 끼칠 수 있도록 한다.      java.lang.ref.WeakReference   java.lang.ref.SoftReference   java.lang.ref.PhantomReference   3.1. 용어  간단하게 WeakReference 객체 생성과정을 보고 용어를 살펴본다.   Sample sample = new Sample(); WeakReference&lt;Sample&gt; wr = new WeakReference&lt;Sample&gt;(sample);   Sample ex = wr.get(); ... ex = null;    위와 같이 WeakReference 클래스는 Sample 클래스의 instance를 캡슐화한다.        마지막 줄의 ex = null;이후에는 아래와 같이 된다.      위 예에서 용어를 보면 아래와 같다.           reference object    WeakReference, SoftReference, PhantomReference 객체. 위 예에서는 wr            referent    reference object에 의해 참조된 객체로 new()로 생성된 원본 인스턴스. 위 예에서 sample            weakly reachable 객체    ex = null; 이후의 상태.       3.2. Reference와 Reachability  GC는 Reachability 상태를 통해서 GC 대상을 판단한다.    Reachability 상태는 java.lang.ref를 사용하면 더 다양하게 분류되는데 전체적으로 총 5가지 상태가 될 수 있다.    하나의 객체에 대한 참조는 여러가지 형태의 조합으로 될 수 있고, 다양한 참조 관계에서 아래의 5가지 상태 중 하나가 된다.   3.2.1. Strongly reachable  참조 사슬 중 ref 패키지 사용 없이 Root set으로 부터 참조된 경우가 있을때.    만약 객체에 여러 참조사슬이 있는데 하나라도 root set에서 바로 참조되는 경우가 있으면 strongly reachable 상태이다.   3.2.2. Softly reachable  SoftReference 로 참조된 경우.    strongly reachable 이 아닌 객체 중에서 weak reference, phantom reference 없이 soft reference로만 참조되는 사슬이 하나라도 있는 경우.   3.2.3. Weakly reachable  WeakReference 로 참조된 경우.    strongly reachable, softly reachable 이 아닌 객체 중에서 phantom reference 없이 weak reference로만 참조되는 사슬이 하나라도 있는 경우.   3.2.4. Phantomly reachable  PhantomReference 로 참조된 경우.    strongly reachable, softly reachable, weakly reachable 모두 해당되지 않는 경우.    이 객체는 finalize 되었지만 아직 메모리가 회수되지 않은 상태이다.   3.2.5. Unreachable  root set으로부터 시작하는 참조가 없는 경우.      –   참조가 여러개 섞여 있을때 상태 판단이 햇갈릴 수 있다.        위 예에서 B의 상태는 softly reachable 이다.   만약 왼쪽 하단 root set에서 SoftReference에 대한 참조가 없다면 B는 phantomly reachable 상태가 된다.   또한 그 상태에서 root set에서 WeekReference에 대한 참조가 있다면 B는 weakly reachable 상태가 된다.   3.3. SoftReference와 Softly Reachable  softly reachable 상태의 객체는 아래 두가지에 의해 GC 여부가 결정된다.      Head에 남아있는 여유 메모리 양   해당 객체의 사용 빈도   즉, 메모리가 많고 사용이 많이 될수록 GC 대상이 되지 않아 오래 살아남는다.   3.4. WeakReference와 Weakly Reachable  weakly reachable 상태의 객체는 특별한 정책이 있는 soft와 달리 GC를 수행할때마다 회수의 대상이 된다.    물론 GC가 언제 객체를 회수할지는 GC 알고리즘에 따라 다르고, 수행할때 반드시 모든 메모리를 회수하는 것도 아니다.    단지, 바로 회수할 수 있는 상태라고 보면 된다.   참고로, LRU 캐시를 구현할때는 대체로 softly reachable 객체보다 weakly reachable 객체가 쓰인다.    softly reference를 사용하게 되면 메모리가 남아있을때동안 GC대상이 되지 않아 메모리 사용량이 점차 늘어나게 되고 나중에 메모리가 부족해지면 GC에 의해 회수되기때문에 GC가 더 자주 발생한다.   3.5. ReferenceQueue  PhantomReference를 보기 전에 java.lang.ref.ReferenceQueue 를 알아야 한다.     SoftReference 객체나 WeakReference 객체가 참조하는 referent 객체가 GC 되어야 한다고 판단되면 Reference 객체 내의 referent를 null로 설정한다. 그렇게되면 해당 객체는 더이상 root set 으로부터의 참조가 없어지므로 자연스레 GC 대상이 된다. 그리고 SoftReference, WeakReference 객체 자체는 ReferenceQueue에 enqueue 된다.    (이 작업은 GC에 의해 자동으로 수행됨)   즉, 이 ReferenceQueue에 reference object가 들어있는지 확인하면 softly reachable 객체나 weakly reachable 객체가 GC되었는지 판단할 수 있고, 이에 대한 후처리 작업을 할 수 있다.     ReferenceQueue 확인이 아니더라도 referent 객체의 null 여부로 확인해도 되지 않을까?    SoftReference, WeakReference는 이런 ReferenceQueue를 사용할 수도 있고 사용하지 않을수도 있다. 이는 생성자로 구분된다.    하지만 PhatomReference 클래스의 경우 반드시 ReferenceQueue를 사용하도록 한다.   ReferenceQueue&lt;Object&gt; rq = new ReferenceQueue&lt;Object&gt;();  PhantomReference&lt;Object&gt; pr = new PhantomReference&lt;Object&gt;(referent, rq);   SoftReference, WeakReference는 객체 내부의 참조가 null로 설정된 이후에 ReferenceQueue에 enqueue되지만, PhantomReference는 객체 내부의 참조를 null로 설정하지 않고 참조된 객체를 phantomly reachable 객체로 만든 이후에 ReferenceQueue에 enqueue된다.     이를 통해 애플리케이션은 객체의 finalize 이후에 필요한 작업들을 처리할 수 있게 된다.   3.6. PhantomReference와 Phantomly Reachable  phantomly reachable 상태는 기존 두개와 많이 다르다.     GC는 대상 객체를 찾는 과정과 해당 객체를 처리하는 과정이 연속적이지 않다.    마찬가지로 해당 객체를 처리하는 과정과 실제 할당된 메모리를 회수하는 과정 역시 연속적이지 않다.    GC는 대상 객체를 처리하는 작업(finalize)이후 GC알고리즘에 따라서 할당된 메모리를 회수한다.   softly reachable, weakly reachable 상태는 GC 대상객체를 판단하는데 관여한다.    이와 달리 phantomly reachable은 finalize와 메모리 회수 사이에 관여한다.   strongly reachable, softly reachable, weakly reachable에 해당하지 않고 PhantomReference로만 참조되는 객체는 우선 finalize 된 이후에 phantomly reachable로 간주된다.   GC가 객체를 처리하는 순서는 아래와 같다..      strong reference   soft reference   weak reference   finalize   phantom reference   메모리 회수   즉, 어떤 객체에 대해서 GC여부를 판별하는 작업은 이 객체가 strongly reachable 인지, softly reachable 인지, weakly reachable 인지 여부를 순서대로 먼저 판별하고 모두 아니면 finalize를 수행한다.   이후에 해당 객체를 참조하는 PhantomReference 가 있으면 phantomly reachable로 간주하여 PhantomReference 객체를 ReferenceQueue에 enqueue 한다. 이 때 후처리 작업을 애플리케이션이 수행하도록 하고 메모리 회수는 지연된다.   3.6.1. 주의할 점  PhantomReference의 get() 은 SoftReference, WeakReference와 달리 항상 null을 리턴한다.    (내부적으로 유지하고 있는데 null을 리턴한다.)   phantomly reachable 상태로 판단된 객체는 더 이상 사용할 수 없게 된다.    (finalize() 이후에 이 상태로 판단되므로 이미 객체에 대해서 정리하는 단계인 것이다.)     phantomly reachable 상태로 판단된 객체는 객체에 대한 참조를 GC가 자동으로 null 처리를 하지 않는다.   따라서 후처리 작업 후 반드시 clear() 메서드를 실행해 null로 만들어 줘야 메모리가 회수된다.   3.7. 메모리 leak 회피를 위한 WeakReference 사용 예  Memory leak을 피하기 위해서는 그냥 Innner class 대신 Static Inner class를 사용하는 것이 좋다. 그런데 이 경우 Outer class의 멤버에 접근할 수 없는 문제가 발생한다. 이럴 경우 Outer 클래스를 weakReference로 접근하면 된다.   public class Outer{     private int mField;          private static class SampleThread extends Thread{         private final WeakReference&lt;Outer&gt; mOuter;                  SampleThread(Outer outer){             mOuter = new WeakReference&lt;Outer&gt;(outer);         }                  @Override         public void run(){             if(mOuter.get() != null){                 mOuter.get().mField = 1;             }         }              } }       [참고 문서]                           네이버 블로그                                   도서 Efficient Android Threading                 ","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/%EC%9E%90%EB%B0%94%EC%9D%98-Reference-%ED%98%95%ED%83%9C%EC%99%80-GC/",
        "teaser": null
      },{
        "title": "[Effective Java] 3. Singleton 패턴에 대해서",
        "excerpt":"Effective java : 3. private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라.   Singleton은 하나의 객체만 가질 수 있는 Class이다.    Singleton을 생성하는 방법은 여러가지가 있다.   public final 필드를 이용  아래 코드는 Elvis class가 초기화될때 하나만 생성된다.   public class Elvis {     public static final Elvis INSTANCE = new Elvis(); \t     private Elvis() { ... } }   static factory method 사용  Singleton객체를 만드는 일반적인 방법이다. 객체를 생성하는 방법은 여러가지가 있을 것이다.   이 방법은 첫번째보다 더 유연한 방법인데. 추후 싱글턴 패턴을 포기하고자 할 때 수정이 쉽다.   public class Elvis {     private static final Elvis INSTANCE = new Elvis(); \t     private Elvis() { ... }     public static Elvis getInstance() {         return INSTANCE;     } }   public class Elvis {     private static final Elvis INSTANCE; \t     private Elvis() { ... }     public static Elvis getInstance() {         if(INATANCE == null) {             INSTANCE = new Elvis();         }         return INSTANCE;     } }   싱글턴 객체의 Serializable  Singleton 객체를 Serializable 객체로 만들고자 할때 단순히 Serializable을 implements 하는것으로 부족하다.   Singleton의 특성을 유지하기 위해서는 모든 필드를 transient로 선언하고 readResolve() 메서드를 추가해야 한다. 그렇지 않으면 직렬화된 객체를 역직렬화 할때마다 새로운 객체가 생성되게 되어 싱글턴의 특징이 깨진다.   참고로 이런 문제를 막으려면 아래와 같은 메서드 구현이 필요하다.    그러면 동일한 Instance가 반환되는 동시에 새롭게 생성되는 가짜 Elvis 객체는 GC에 의해 처리된다고 한다.   private Object readResolve() {     return INSTANCE; }   enum 을 활용한 Singleton 객체 생성  원소가 하나뿐인 enum을 활용하면 가장 완벽환 Singleton 객체를 만들 수 있다고 한다.   public enum Elvis {     INSTANCE }   이러면 직렬화가 알아서 처리되어 여러객체가 생길일이 없고, reflection을 통한 공격에도 안전하다고 한다.   (참고) reflection을 통한 private 생성자 호출  Singleton 객체 생성을 위해 private 생성자를 만들었지만, 자바 reflection을 이용하면 private 생성자를 호출할 수 있는 방법이 존재한다.   AccessibleObject.getAccessible() 메서드를 통해 권한을 획득한 후 reflection을 이용하면  private 생성자를 호출할 수 있다.   ","categories": ["Java"],
        "tags": ["Effective java"],
        "url": "http://localhost:4000/java/3.-Singleton-%ED%8C%A8%ED%84%B4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C/",
        "teaser": null
      },{
        "title": "[Effective Java] 8. equals를 재정의할 때는 일반규약을 따르라.",
        "excerpt":"equals() 메서드는 Override시 실수하기 쉬워 가능한 그대로 사용하는게 좋다.   1. equals()를 Override할 필요가 없는 경우  아래 중 하나라도 해당된다면 equals()를 Override 하지 말고 있는 그대로 사용하자.                  객체가 가지는 값(value)에 대한 동일 비교가 아니라 객체 자체에 대한 비교인 경우         객체 자체 비교는 == 연산자를 사용한다.                       값에 대한 검증(논리적인 동일성)이 있든 없든 상관없는 경우.         예를 들어 java.util.Random 클래스는 두 Random 객체가 같은 난수열인지 검사하도록 equals() 메서드를 Override 할 수 있었지만 굳이 그렇게 쓸 사용자가 없을것으로 보여 만들지 않음.                       클래스가 private 또는 package-private 으로 만들어진 경우.         equals() 메서드가 호출될 일이 없기 때문에 Override 할 필요도 없다. 호출 자체를 막고자 한다면 아래처럼 처리할 수도 있다.           @Override public boolean equals(Object o){     throw new AssertionError();\t//호출하면 안되는 메서드 호출 }           2. equals()를 Override 해야 하는 경우                  논리적인 동일성(값의 비교) 개념을 지원해 줘야 할 때.         Integer, Date 처럼 value class가 대부분 이에 해당한다. 참고로 이런 value class의 equals()를 적절하게 Override하면 객체 자체를 Map의 Key나 Set의 원소로 사용할 수 있다.      반대로 말하면 잘못 Override하면 Map이나 Set에 포함되었을때 예측할 수 없는 결과를 만든다.                       상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때                  3. equals()를 Override할때 규약  아래는 Object 클래스 명세의 내용이다.    equals() 메서드는 동치관계(equivalence relation)를 구현한다.   다음의 관계를 동치 관계라 한다.    1. 반사성(reflexive)    : null이 아닌 참조 x가 있을때 x.equals(x)는 true를 반환한다.     2. 대칭성(symmetric)   : null이 아닌 참조 x, y가 있을때, x.equals(y)는 y.equals(x)가 true일때만 true를 반환한다.     3. 추이성(transitive)   : null이 아닌 참조 x, y, z가 있을때, x.equals(y), y.equals(z)가 true이면 x.equals(z)도 true 이다.     4. 일관성(consistent)   : null이 아닌 참조 x, y가 있을때 x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.     5. null이 아닌 참조 x에 대해서, x.equals(null)은 항상 false를 반환한다.    3.1. 반사성  객체는 자기 자신과 같아야 한다는 것이다. 일부러 깨트리기도 힘들어 별로 문제가 생기지 않는다.   3.2. 대칭성  두 개의 객체에게 서로 같은지 물어봤을때 둘 다 같은 답이 나와야 한다는 것이다. 실수하면 깨지기 쉬운 규칙이다.   public final class CaseInsensitiveString {     private final String s; \t     public CaseInsensitiveString(String s){         if (s == null)             throw new NullPointerException();         this.s = s;     } \t     // 대칭성 위반     @Override     public boolean equals(Object o){         if(o instanceof CaseInsensitiveString) {             return s.equalsIgnoreCase((CaseInsensitiveString)o).s);         } \t\t         if(o instanceof String) {             return s.equalsIgnoreCase((String)o).s);         }  \t\t         return false;     } }   위 예제는 CaseInsensitiveString 클래스가 일반 문자열 String과도 호환되게 하려고 한다.   하지만 이 경우 String 클래스가 CaseInsensitiveString 클래스를 모르기 때문에 대칭에 문제가 발생한다.   CaseInsensitiveString cis = new CaseInsensitiveString(\"Aa\"); String s = \"aa\";  &gt; cis.equals(s) 는 true 리턴 &gt; s.equals(cis) 는 false 리턴   만약 이걸 Collection에 대입하면 문제가 된다.   List&lt;CaseInsensitiveString&gt; list = new ArrayList(); list.add(cis);  // 아래 결과는?? 예측할 수 없다. list.contains(s);   contains()의 결과는 자바 버전이나 JVM에 따라서 달라져서 예측할 수 없게 된다.   올바르게 equals()를 Override한다면 아래와 같이 해야 한다.   @Override public boolean equals(Object o){     return o instanceof CaseInsensitiveString &amp;&amp;          s.equalsIgnoreCase((CaseInsensitiveString)o).s; }   3.3. 추이성  역시 실수하면 깨지기 쉬운 규칙이다.   아래 예는 상위클래스에 없는 값을 하위클래스에 추가한 경우이다. 즉, equals()가 비교해야 할 대상이 추가된 경우다.   public class Point {     private final int x;     private final int y;     public Point(int x, int y){         this.x = x;         this.y = y;     } \t     @Override     public boolean equals(Object o){         if( !(o instanceof Point))             return false; \t\t\t         Point p = (Point)o;         return p.x == x &amp;&amp; p.y == y;     } }  public class ColorPoint extends Point{     private final Color color;     public ColorPoint(int x, int y, Color color){         super(x,y);         this.color = color;     } \t     // 추이성 위반되는 경우.     @Override     public boolean equals(Object o){      } }   3.3.1. 대칭성이 위반되는 경우  아래의 경우는 대칭성에 위반된다.   @Override public boolean equals(Object o){     if(!(o instanceof ColorPoint))         return false; \t\t     return super.equals(o) &amp;&amp; ((ColorPoint)o).color == color; }   위 경우의 문제는 Point 객체와 ColorPoint 객체를 비교하는 순서를 바꾸면 다른 결과가 반환될 수 있다는 것이다.   Point p = new Point(1,2); ColorPoint cp = new ColorPoint(1,2,Color.RED);  p.equals(cp);\t\t// 결과는 true cp.equals(p);\t\t// 결과는 false   3.3.2. 추이성이 위반되는 경우  ColorPoint가 비교할때는 컬러를 무시하게 해보자.   @Override public boolean equals(Object o){     if(!(o instanceof Point))         return false; \t     // o가 Point면 색상 비교하지 않음     if(\t!(o instanceof ColorPoint)){         return o.equals(this);     } \t     // o가 ColorPoint이므로 모든 정보 비교     return super.equals(o) &amp;&amp; ((ColorPoint)o).color == color; }   위 경우는 대칭성은 보장되지만 추이성이 깨진다.   ColorPoint p1 = new ColorPoint(1,2,Color.RED); Point p2 = new Point(1,2); ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);  p1.equals(p2);\t\t// 결과는 true p2.equals(p3);\t\t// 결과는 true p1.equals(p3);\t\t// 결과는 false - 추이성 위반   3.4. 일관성  같다고 판정된 객체들은 그 내용이 바뀌지 않는한 늘 같아야 한다.   3.5. null에 대한 비교  모든 객체는 null과 비교시 false를 리턴해야 한다.    참고로 이를 위해 따로 null체크를 할 필요는 없다. equals() 메서드의 첫부분은 항상 instanceof를 통해 타입체크를 하게 되는데 이 때 체크가 같이 되기 때문이다.   Object o = null; if(o instanceof AA){ \treturn true; }else{ \treturn false; }   위 내용에서 o가 null이면 항상 false가 리턴된다.   4. 상속과 equals() 관련 중요한 내용  객체 생성 가능한 클래스를 상속받아 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법은 없다.     만약 새로운 값 컴포넌트가 추가되면서도 equals()를 깔끔하게 Override 하려면 상속받는 대신에 구성(composition)하는 방법을 쓰면 된다.   public class ColorPoint{     private final Point point;     private final Color color;     public ColorPoint(Point point, Color color){         this.point = point;         this.color = color;     } \t     @Override     public boolean equals(Object o){         if(!(o instanceof ColorPoint)){             return false;         } \t\t         ColorPoint cp = (ColorPoint)o;         return cp.point.equals(point) &amp;&amp; cp.color.equals(color);     } }   4.1. abstract 로 선언된 클래스의 경우 상관없다.  abstract 로 선언된 클래스의 경우 새로운 값 컴포넌트를 추가해도 equals 규약을 어기지 않고 가능하다.    어짜피 상위클래스가 abstract면 직접적인 객체 생성이 불가능하기 때문이다.   4.2. 자바 기본 라이브러리 중 잘못 구현된 내용  java.sql.Timestamp는 java.util.Date를 상속받은 이후에 nanoseconds 필드를 추가하였다.     이 때문에 Timestamp 클래스의 equals 메서드는 대칭성을 위반하여 Timestamp 클래스와 Date 클래스를 같은 컬렉션에 넣으면 문제가 생길 수 있다.    (Timestamp 클래스 주석에 Date와 같이 쓰지 말라고 되어있음)   5. 훌륭한 equals()를 만드는 지침   5.1. ==를 통해 equals()의 인자가 자기자신인지 검사하라.  성능 최적화를 위해 우선 자기자신인지 확인하자. 객체 비교에 대한 오버헤드가 클 수록  위력이 크다.   5.2. instanceof를 통해 인자의 자료형을 검사하라.  보통은 자기 자신 클래스를 확인하겠지만.. equals()가 구현하는게 인터페이스를 구현하는 여러 클래스에 대해 공통적으로 사용하는 것일수도 있다.    (ex- List, Map 과 같은 컬렉션 인터페이스)   5.3. equals()인자의 정확한 자료형을 변환하라.  ColorPoint cp = (ColorPoint)o; 처럼 명확히 타입 casting하여 사용하여 혹시 모를 버그를 대비하자.   5.4. 비교 대상 필드의 일치 여부를 검사한다.  모두 일치할때 true, 하나라도 아니면 false를 리턴한다.        기본자료형 : == 로 비교   float, double : Float.compare(), Double.compare()   객체 : equals()를 재귀적으로 호출하여 비교   배열 : 배열의 원소 각각 비교   5.5. 구현을 끝낸 이후 대칭성, 추이성, 일관성 만족 여부를 검토하라.  단위 테스트로 검사할 것.   5.6. 추가적인 주의사항           equals()를 구현할때는 hashCode()도 재정의하라.     hashCode()의 일반 규약이다. (규칙9 참고)            equals() 메서드 인자를 Object에서 다른것으로 바꾸지 마라.     아래 클래스는 Object.equals()의 Override 한것이 아니라 Overloading 한것이다.       public boolean equals(MyClass o){   }           ","categories": ["Java"],
        "tags": ["Effective java"],
        "url": "http://localhost:4000/java/8.-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%BC%EB%B0%98%EA%B7%9C%EC%95%BD%EC%9D%84-%EB%94%B0%EB%A5%B4%EB%9D%BC",
        "teaser": null
      },{
        "title": "[Effective Java] 9. equals를 재정의할 때는 반드시 hashCode도 재정의하라.",
        "excerpt":"equals() 메서드를 Override 하는 클래스는 반드시 hashCode() 도 Override해야 한다. 그렇지 않으면 Object.hashCode() 의 일반규약을 어기게 되어 HashMap, HashSet, Hashtable 과 같은 해시 기반 컬렉션을 사용할 때 오동작하게 된다.   1. hashCode() 일반 규약           응용프로그램 실행 중 같은 객체의 hashCode를 여러번 호출하는 경우, equals가 사용하는 정보들이 변경되지 않았다면 언제나 동일한 정수(integer)가 반환되어야 한다. 다만 응용프로그램이 종료되었다가 다시 실행되어도 같은 값이 나올 필요는 없다.            equals() 메서드가 같다고 판정한 두 객체의 hashCode값은 같아야 한다.            equals() 메서드가 다르다고 판정한 두 객체의 hashCode값이 꼭 다른 필요는 없다. 그러나 서로 다른 hashCode 값이 나오면 Hashtable의 성능이 향상될 수 있다.          2번째 규약때문에 equals() 메서드 override시 hashCode()도 override 해야 한다.    2. 잘못되는 예   2.1. override하지 않아 문제가 되는 경우  PhoneNumber 라는 클래스가 있는데 number로 equals() 여부를 리턴해주도록 Override 하였다.     Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;PhoneNumber String&gt;(); m.put(new PhoneNumber(707, 867, 5309), \"Jenny\");  // name은 어떤 값이 올 것인가. String name = m.get(new PhoneNumber(707, 867, 5309));   위 코드에서 2개의 PhoneNumber 객체가 사용되었다.   그런데 equals() 메서드를 override 했기때문에 논리적으로 2개는 같은 객체이다. 하지만 리턴되는 name은 Jenny가 아니라 null 이다.   hashCode()를 override 하지 않아 두 객체는 서로 다른 해시코드를 갖기때문이다. 따라서 get메서드는 put이 저장한것과 다른 해시 버킷(hash bucket)을 뒤지게 된다.   2.2. 잘못 구현하여 문제가 되는 경우   @Override public int hashCode() {     return 42; }   이런식으로 구현해도 동작은 한다. 하지만 모든 객체가 동일한 hashCode()값을 가지게 되어 Hashtable을 쓸때 모두 같은 버킷에 해시되고.. 결국 Hashtable은 LinkedList가 되어버린다.   동작은 하지만 실행시간 O(N)이 되어야 하는것이 O(N^2)이 되어버려 성능이 엄청 느려 진다.   3. hashCode()의 올바른 구현          좋은 hash함수는 다른 객체에 대해서 다른 hashcode를 리턴한다.(3번째 규약의 내용)            다른 필드 값에 의해 유도될 수 있는 값은 hashcode 계산에서 제외해도 된다.            equals 계산에 쓰이지 않는 필드는 반드시 제외해야 한다. (2번째 규약때문)            immutable 클래스인 경우 hashcode 계산 비용이 높다면 객체 내부에 캐쉬해 돌 수 있다.            성능을 개선하려고 객체의 중요 부분을 hashcode 계산에서 빼면 안된다. 그럴 경우 hash함수 속도가 빠를순 있어도 hashtable 성능은 엄청 떨어트릴 수 있다.       ","categories": ["Java"],
        "tags": ["Effective java"],
        "url": "http://localhost:4000/java/9.-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%B0%98%EB%93%9C%EC%8B%9C-hashCode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC",
        "teaser": null
      },{
        "title": "SSL(Secure Socket Layer)과 인증서",
        "excerpt":"   SSL에 대해서는 암호화 알고리즘 를 참고할 것.    간단히 SSL(Secure Socket Layer) 프로토콜은 대칭형 암호화와 비대칭형 암호화 방식을 혼합하여 사용한 것으로 Netscape사에서 웹서버와 브라우저 사이 데이터를 주고받을때의 보안을 위해 만들었다.     SSL은 중간자 공격(MITM : Man In The Middle Attack)에 취약한데 이 때문에 verysign과 같은 제 3의 인증기관이 생겼다. 즉, 내가 접속한 사이트가 진짜인지 가짜인지를 구분하는 용도인 것이다.   이런 인증기관을 Certificate Authority(CA)라 부른다. 이 때 인증을 위한 인증서를 SSL 인증서라 부른다.   1. SSL 인증서 기반 암호화 통신  전체 과정은 아래와 같다.      인터넷 사이트는 자신의 정보와 공개키를 인증 기관에 제출한다.   인증 기관은 검증을 거친 후 해당 사이트 정보와 공개키를 인증기관의 개인키로 암호화한다. (이것이 해당 사이트의 SSL 인증서이다.)   인증기관은 웹 브라우저에게 자신의 공개키를 제공하고 브라우저는 검증된 인증기관의 공개키를 브라우저 내에 미리 탑재한다. (정확히는 공개키가 들어있는 CA 인증서.)   사용자가 웹브라우저로 사이트에 접속하면 사이트는 인증기관이 만들어준 자신의 인증서를 웹브라우저에게 보낸다.   웹브라우저는 인증 기관의 공개키로 인증서를 해독한다.(유명 인증기관의 공개키는 브라우저에 이미 탑재되있음. 참고로 이 때 인증서의 유효성을 검증하는데 전자서명이 사용되고, 전자서명을 위한 해시 알고리즘 문제가 바로 SHA-1 인증서 문제이다. )   해독된 인증서를 통해 사이트를 검증하고, 해당 사이트의 공개키를 얻는다.   이렇게 얻은 사이트의 공개키로 대칭키를 암호화해서 보낸다.   사이트는 자신의 개인키로 암호문을 해독하여 요청자의 대칭키를 얻는다.   이제 서로 대칭키를 알고있기때문에 대칭키 암호 방식으로 데이터를 주고받을 수 있다.   SSL Handshaking 과정을 이미지로 보면 아래와 같다.      2. 인증서(Certificate)  인증서는 접속하고 있는 웹사이트가 신뢰할 수 있는 사이트라는 것을 인증하는 역할을 한다.    인증서의 상세내용은 대개 아래와 같다.      서비스 정보 (인증서를 발급한 CA, 서비스 도메인, 유효기간 등)   서버측의 공개키 (공개키 내용, 공개키 암호화 방식)   인증서 유효성을 검증하기 위한 해쉬(Hash)   SSL 인증서의 기본 구조는 “당신이 인증서 서명한 사람을 신뢰한다면, 서면된 인증서도 신뢰할 수 있다” 라는 것이다. 또한 인증서는 Tree 구조를 이루고 있고 인증서가 다른 인증서를 서명한다.     Tree 구조이기 때문에 최상위 인증서가 존재하는데 최상위 인증서를 발행한 기관을 Root Certification Authority(Root CA) 라고 부른다.    유명한 인증기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 웹브라우저에 기본 설치되어있다. 그럼 Root CA의 인증서는 누가 서명을 했을까? 모든 Root CA 인증서는 자체 서명(self signed) 되어 있다.   브라우저 회사는 자신들의 판단에 의해 CA를 선택하여 목록을 브라우저에 미리 탑재하는데 만약 해당 인증기관이 아닌 사설 인증기관인 경우 주소창에서 아래와 같이 경고한다.      3. 전자서명  전자서명이란 서명자를 확인하고 해당 서명자가 전자문서에 서명을 하였음을 나타내는데 이용하기 위해 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보를 말한다.   전자서명의 기본 원리 역시 공개키 기반 암호화 알고리즘이다.    즉, private key로 암호화된 내용은 public key로만 풀수있기 때문에 정확히 어떤 사람이 서명을 했다라가는거을 증명할 수 있는 것이다.   공개키 기반 암호화 원리를 이용한 전자서명은 아래와 같이 동작한다.      원본 문서 내용을 잘 알려진 Hash 함수(ex- MD5, SHA1)를 이용해 해시값을 추출한다.   해시값을 서명자의 Private key로 암호화 한다.   암호화한 해시값은 원본 문서 끝에 첨부해서 수신자에게 전달한다.   수신자는 전달받은 이후 먼저 문서 끝에 첨부된 해시값을 분리하여 원본 문서만 추출한다.   추출한 문서를 송신자가 적용한것과 같은 Hash 함수를 이용해 해시값을 추출한다.   아까 분리했던 암호화된 해시값을 송신자의 Public key로 복호화 한다.   복호화된 해시값과 내가 원본에서 만든 해시값을 비교한다.   두 값이 동일하면 서명이 올바른 것이라고 판단한다.   4. SSL의 SHA1 인증서 문제  SHA1 알고리즘의 경우 컴퓨팅 성능의 발달로 문제가 되어 더이상 안전하다고 보기 어렵게 되었다.   따라서 각 브라우저는 SHA1 인증서를 더이상 지원하지 않기로 하였고, 각 사이트들 역시 SHA1 알고리즘으로 만들어진 인증서를 SHA2 알고리즘의 인증서로 변경해야 한다.   여기서 SHA1 인증서라 함은 인증서의 전자서명이 SHA1 해시함수로 만들어진 인증서인 것이다.       [참고 문서]          참고 사이트 1     SHA1 인증서 경고 관련     관련 기사     참고 블로그     오픈튜토리얼     전자서명-위키피디아       ","categories": ["보안"],
        "tags": [],
        "url": "http://localhost:4000/security/ssl_and_certification",
        "teaser": null
      },{
        "title": "Session과 Cookie",
        "excerpt":"HTTP 프로토콜은 Connectless, Stateless의 특징이 있다.    즉, 연결을 유지하지 않고 이로인해 상태 정보를 가질 수 없다는 특징이다.   이러한 HTTP 프로토콜의 특성은 장점이자 단점이 되는데 단점을 커버하고자 쿠키와 세션이 사용된다.   1. Cookie   1.1. Cookie     쿠키는 상태 관리를 위해 사용되는 작은 파일로 상태를 저장하는 위치는 Client(브라우저)이다.   쿠키는 key-value 형태의 데이터들로 이름, 값, 만료날짜 등의 정보가 있다.   쿠키 크기는 4kb로 제한된다.   하나의 도메인당 20개까지 제한된다.   모든 도메인을 통틀어 300개로 제한된다. 만약 이 범위를 넘어서면 오래된 쿠키부터 지운다.   1.2. Cookie 원리  로그인이 유지되는 것도 쿠키를 이용한 것이다.      브라우저를 통해 웹페이지에 접속한다.   서버는 쿠키를 설정해 Client(브라우저)에게 응답한다. (Response Header에 Set-Cookie 속성을 사용)   브라우저는 쿠키를 메모리에 저장한다.   이후 웹페이지 접속 시 Request에 쿠키를 함께 전송한다.   서버는 Client로 부터 전달된 쿠키를 통해 상태 관리를 할 수 있게된다.   1.3. Coockie 사용 예     쇼핑몰 장바구니   해당 사이트의 사용자 언어 설정 및 기타 정보   팝업 “오늘 더 이상 이 창을 보지 않습니다.”   로그인 정보 (세션을 사용하여)   2. Session  로그인과 같은 보안상 중요한 작업은 세션을 통해 이뤄진다.   2.1. Session     세션은 Client-Server 간 연결이 유지되고 있는 상태를 말한다.   Client가 Request를 보내면 서버는 유일한 ID를 생성하여 이 값을 반환하는데 이 값이 세션이다.   2.2. Session 원리     브라우저가 웹페이지에 접속한다.   서버는 세션 ID를 만들고, 그 값을 내부적으로 관리한다.   생성한 세션ID는 쿠키를 이용해 리턴한다. (쿠키 이름은 JSESSIONID)   브라우저는 재접속시 이 쿠키(JSESSIONID)를 이용해 세션 ID를 서버에 전달한다.   서버는 세션ID를 통해 유일한 Client를 구분할 수 있게된다.   2.3. Session의 장단점     세션을 통해 서버는 접속한 Client를 유일하게 구별할 수 있고, 클라이언트를 구별해야 하는 정보를 서버에서 관리할 수 있게 된다.   정보 저장이 서버에서 이뤄지므로 쿠키만 사용하는것보다 보안에 안전하다. (쿠키는 클라이언트가 관리하는것. 세션은 서버에서 관리하는것)   세션에 따라서 부가 정보를 서버가 관리하므로 서버 부하가 커진다. (쿠키보다 느리다.)   쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해 sessionId만 저장하고 실제로 이걸로 처리하는 작업은 서버에서 하기 때문에 보안에 더 안전하다.       [참고 문서]          참고 블로그        ","categories": ["보안"],
        "tags": [],
        "url": "http://localhost:4000/security/session_and_cookie",
        "teaser": null
      },{
        "title": "Token 기반 인증",
        "excerpt":"   Cookie와 Session에 대해서는 Session과 Cookie 를 참고할 것.    1. 전통적인 인증 방식  전통적인 인증 방식은 쿠키와 세션을 사용한다.      1.1. 서버 기반 인증의 문제점      A. 세션  사용자가 로그인을 할때 서버는 SessionID를 생성하는데 이 값을 계속 관리해야 하는 문제가 있다.   B. 확장성  세션을 사용하면 서버 분산 확장이 복잡해진다.    서로 다른서버에서 세션에 대해서 인증을 할 수 있어야 하기 때문이다.   C. CORS(Cross-Origin Resource Sharing)  세션을 관리할때 주로 쿠키를 사용한다.    쿠키는 단일 도메인 및 서브도메인에서만 작동하도록 되어 있다. 이 때문에 쿠키를 여러 도메인에서 사관리하는 것이 번거롭다.   D. 모바일 환경에 적합하지 않다.  기존에 HTTP 통신의 Client는 브라우저가 거의 유일했으나 현재는 다양한 모바일 환경이 있다.    이런 환경에서 인증을 위한 쿠키, 세션을 다루는 방법은 구현의 복잡도를 야기한다.   2. Token 기반 인증 방식  세션을 발급하는 것이 아니라 Token을 발급한다.         클라이언트는 ID/PW를 전송하여 서버에 인증을 요청한다.   서버는 계정정보를 검증하고 유효한 경우 signed Token을 발급한다.   (signed Token이란 정상적으로 발급된 토큰임을 인증하는 signature를 가지고 있다는 뜻이다.)   클라이언트는 Token을 가지고 있으면서 추후 서버 요청 시 Token을 함께 전달한다.   서버는 Token을 검증하고 요청에 응답한다.      Token에는 사용자 식별 정보가 포함되어 있다. 따라서 서버는 토큰을 통해 어떤 사용자인지 식별할 수 있다.    2.1. Token 기반 인증의 장점   A. stateless 하다.  토큰은 서버에서 별도로 관리하지 않는다. 따라서 세션을 사용함으로써 발생하는 서버 확장의 문제가 없다.   B. Client에 독립적이고 여러 도메인에서 사용할 수 있다.  토큰은 세션처럼 쿠키를 통해 전달하는게 아니라 Request Header를 통해 전달된다. 따라서 HTTP request를 만들 수 있다면 누구든 요청을 보낼 수 있다.    또한 쿠키를 사용하지 않아 CORS 문제가 없다.   C. 보안  쿠키를 사용하지 않아 이로 인해 발생하는 취약점이 사라진다.   D. 확장성  Token 기반 인증은 단순 내 서버에 인증하는 역할 뿐 아니라 인증의 사용 범위를 확장시킬 수 있다.    대표적인게 oAuth 이다.   2.2. JWT  JSON Web Token으로 Token 규격에 대한 표준 format 이다.       [참고 문서]          참고 블로그     참고 블로그     참고 블로그     JWT 관련     JWT 관련        ","categories": ["보안"],
        "tags": [],
        "url": "http://localhost:4000/%EB%B3%B4%EC%95%88/Token-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D/",
        "teaser": null
      },{
        "title": "oAuth 2.0",
        "excerpt":"oAuth는 인증 및 권한부여를 관리하는 범용 프레임워크로 사용자가 Facebook이나 트위터 같은 외부 서비스의 일정 기능을 사용할 수 있게 한다.    1. oAuth 역사  oAuth의 시작은 2006년 트위터 개발자와 소셜북마크 서비스 Gnolia 개발자가 인증 방식을 논의하면서 시작되었다. 개발자들은 그때까지 API 접근 위임에 대한 표준이 없다는것을 알고 oAuth 제안서를 만든다. 이후 이 활동은 지지를 받았고 2007년 oAuth 1.0 초안이 발표된다.    이후 oAuth 1.0은  보안문제 일부를 수정하여 2009년 oAuth 1.0 Revision A(oAuth 1.0a) 으로 업그레이드 된다.   2008년에는 oAuth 표준화를 위해 IETF 회합에서 논의가 진행되었고 이는 큰 지지를 받아 2010년 oAuth 1.0 프로토콜 표준안이 RFC5849로 발표되었다. (base가 되는 버전은 oAuth 1.0a 이다.)   oAuth 1.0은 웹이 아닌 앱에서 사용하기 힘들다는 단점이 있다. 또한 절차가 복잡하여 구현 라이브러리를 만들기 어렵다.    현재 최신버전인 oAuth 2.0은 이런 단점을 개선한 것이다.   참고로 oAuth 2.0은 이전버전과 호환이 되지 않는다.    1.0은 만들어지고 어느정도 시간이지난 후 IETF 표준이 된 반면 oAuth 2.0은 초기부터 IETF 표준 프로세스 안에서 만들어졌다.   2. 인증과 권한부여  oAuth는 Open Authorization의 약자로 “공개 권한 부여”의 의미이다.    oAuth 자체는 인증과 권한부여라는 두가지 기능을 다 하는데 주 목적은 데이터에 접근할 수 있는 권한을 부여하는 것이다.   예를 들어 내 앱에서 사용자의 페이스북 게시물을 읽어서 보여주고 싶다.        우선 내 앱은 페이스북 개발자센터에 내 앱을 등록하여 게시물을 읽을 수 있는 기능을 사용할 것이라고 명시할 것이다.   사용자는 내 앱을 사용할때 페이스북 로그인을 할 것이다.   로그인을 하면 내 앱에서는 페이스북에 게시물을 읽을 수 있도록 허락해달라고 요청할 것이다.   이 요청에 따라 페이스북 페이지가 뜨면서 이 앱이 게시물을 읽도록 허용할 것이냐고 사용자에게 묻는다.   확인을 누르면 내 앱에서 사용자의 게시물이 보인다.   여기서 권한부여란 3,4번 과정이다.   즉, 내 앱이 페이스북 게시물을 읽을 수 있도록 권한을 요청하고 이를 페이스북에서 허락하는 과정이다.   3. protocol flow와 용어  oAuth 2.0의 권한 허가 절차는 아래와 같다.      3.1. 용어   3.1.1. Client  사용자를 말하는게 아니라 권한을 사용할 서비스를 의미한다.    예를 들어 페이스북 게시물을 읽어서 보여줄 앱을 말한다.   3.1.2. Resource Owner  리소스를 소유한 사람. 실제 사용자를 의미한다.(또는 이를 위임받은 서버)    예를 들어 어떤 앱이 페이스북 게시물을 보여줄때 실제 게시물의 소유자는 앱을 사용하는 사용자이다.   3.1.3. Authorization Server  인증 서버로 일반적인 로그인 서버와 다르다.(같을 수도 있고 다를수도 있음)   flow 상에서 인증서버가 하는 역할은 “사용자에게는 허가를 받았는데 이 허가를 기반으로 이 서비스에서 특정 기능을 사용할 수 있도록 권한을 달라”고 하는 것이다.   인증이 되면 Access Token 을 부여받는다.   3.1.4. Resource Server  데이터가 존재하는 서버이다.    인증 이후 인증서버로 부터 받은 Access Token을 통해 데이터에 접근할 수 있다.   3.2. Flow     Client가 Resoure Owner 에게 권한을 요청한다. 이 때 권한 요청은 소유자에게 직접 할 수도 있고, 권한서버를 통해 간접적으로 할 수도 있다.   Resource Owner가 권한을 허가하면 Client는 권한 증서(Authorization Grant)를 받는다.   증서를 받은 Client는 Authorization Server에 이를 보낸다.   Authorization Server는 전달받은 증서의 유효성을 검증하고 유효하다면 Access Token을 발급한다.   Access Token을 발급받은 Client는 실제 데이터를 불러올 수 있는데 Resource Server에 데이터를 요청할때 Access Token을 함께 전달한다.   Resource Server는 Token의 유효성을 검사하고 유효하다면 요청을 처리해준다.   4. Access Token과 Refresh Token  Access Token은 정상적으로 인증이 됬을때 Client에게 발급된다.    이 Token은 보호된 자원에 접근할때 권한 확인용으로 사용되는데 기존 아이디나 비밀번호등 인증에 필요한 형태가 토큰 하나로 표현됨으로써 리소스 서버입장에서 간편하다.   Access Token은 발급됬을때 유효기간이 정해진다. 만약 유효기간이 지나면 새로운 Access Token을 발급받아야 하는데 이 때 Refresh Token이 활용된다.   권한서버는 Access Token을 발급할때 Refresh Token도 함께 발급한다.    Access Token의 기한이 지나면 Refresh Token을 통해 권한 서버에 다시 요청을 하게 되고, 권한 서버는 이를 통해 Access Token을 갱신해준다.   Refresh token을 따로 두는것은 Token 기반 인증의 안정성 때문이다.    일단 Access Token이 탈취되면 유효기간동안 제제없이 인증이 허가된다. 이 때문에 Access Token의 유효기간은 짧게 두고, 유효기간이 지난 후 다시 Token을 갱신할 수 있는 Refresh Token을 따로 두는 것이다.   5. Authorization Grant의 4가지 형태  이 Client(앱)가 다른 서비스의 일정 기능을 사용할 것이라고 Resource Owner(서비스의 실제 사용자)에게 허가를 받는데 이 허가를 받는 방식이 크게 4가지가 있다.   참고로 oAuth 2.0은 아래 4가지 외에 추가적인 인증방식을 적용할 수 있다고 열어두었다.   5.1. Authorization Code  Client가 Resource Owner에게 직접 권한을 요청하는게 아니라 Resource Owner가 Authorization Server에게 인증을 받음으로써 권한을 요청하고 허가하는 형태이다.   이 때 Authorization Server가 하는 역할은 로그인 인증서버의 역할을 하게 된다.   일반적으로 구글, 페이스북들 모두 이런 방식을 사용한다. 이 때문에 구글, 페이스북 로그인을 하라고 요청 받는 것이다.   이 방식을 사용하면 로그인 후 Authorization Code를 발급받고 이 코드를 다시 Authorization Server에게 전달하게 된다.   Authorization Server는 2가지 역할을 하게 되는데, 서버 구현에 따라 이 둘을 분리할 수도 있을 것이다.   5.2. Implicit  Implicit는 Authorization Code와 비슷한데 중간 한단계를 축소한 것이다.    위에서 Authorization Server는 처음에는 로그인을 했고 두번째는 권한 허가 역할을 했다. 이런 과정을 하나로 합쳐 로그인 후 Authorization Code를 리턴하는게 아니라 바로 Access Token을 리턴해 주는 것이다.   과정이 줄어들어 편해지는 대신 보안성이 낮아진다.        어떤 보안이 낮아지는지는 모르겠음…    5.3. Resource Owner Password Credentials  Access Token을 발급받기 위한 권한증서 자체가 ID/PW 이다.    이 때의 문제는 ID/PW를 Client(앱)에 직접 입력해야 한다는 점이다.   Client를 신뢰할 수 있다면 괜찮으나 신뢰할 수 없다면 이런 ID/PW 정보를 직접 입력받는다는게 보안에 문제가 된다.   5.4. Client Credentials  Client 인증 방식으로 위 3가지 형태와 다른 형태이다.    이는 Resource Owner가 사용자가 아니라 Client 자체인 경우이다.     예를 들어 구글 지도 서비스를 사용하고 싶다고 할때 사용자 인증을 받는게 아니라 앱 자체만 등록하여 사용하는것과 같다.   6. oAuth를 이용해 내 서버에서 인증 사용하는 방법     페이스북 로그인  (oAuth)   결과로 Access Token 받음   내 서버에 Access Token 전달   내 서버에서 페이스북 서버를 통해 Access Token이 유효한지 확인하고 회원 기본정보를 조회.   이 기본정보로 내 서버에 회원 가입 시킴.   내 서버에서 사용하기 위한 Token 발급하여 Client에 응답.   Client에서 서버 사용할때는 내 서버가 발급한 Token 사용.       [참고 문서]          위키피디아     네이버 D2     참고 블로그 1     참고 블로그 2     ","categories": ["보안"],
        "tags": [],
        "url": "http://localhost:4000/%EB%B3%B4%EC%95%88/oAuth2.0/",
        "teaser": null
      },{
        "title": "암호화 알고리즘의 분류",
        "excerpt":"0. Intro  암호화 알고리즘은 크게 대칭형와 비대칭형 2가지로 나뉘는데 이는 암호화에 사용하는 Key와 복호화에 사용하는 Key가 같은지 다른지를 기준으로 분류된다.    통상적으로 대칭형 암호는 비밀키 암호에 사용되며 비대칭형 암호는 공개키 암호에 사용된다. 따라서 각각  대칭키(비밀키) 암호화 방식과 비대칭키(공개키) 암호화 방식 으로 불리기도 한다.   대칭형 암호화 방식은 또 블럭 암호화와 스트림 암호화로 분류될 수 있다.   블럭 암호화는 비트 수(단위, 또는 블럭)를 암호화 하는 방식이고 스트림 암호화는 연속적인 데이터를 암호화하는 방식이다.   또 다른 분류방법으로 양방향 암호화와 단방향 암호화가 있다. 양방향 암호화가 일반적으로 암호화 복호화라면 단방향 암호화는 복호화가 불가능한 것을 말한다. 즉, 암호문을 다시 평문으로 복호화 할 수 없는 것이다.   정리하면 아래와 같다.                  분류방식       이름       또 다른 이름                       Key에 따라       대칭형 암호화       대칭키 암호화, 비밀키 암호화                         비대칭형 암호화       비대칭키 암호화, 공개키 암호화                 대칭형 암호화의 경우 구현 방식에 따라       블록 암호화                                 스트림 암호화                         암호화 방향에 따라       양방향 암호화                                 단방향 암호화                   1. 대칭형(대칭키, 비밀키) 암호화 방식  암호화에 사용되는 Key와 복호화에 사용되는 Key가 동일한 경우이다.    Key가 동일하기 때문에 대칭형 암호화에는 비밀키 암호화 방식이 사용된다.   현재 가장 보편적으로 쓰이는 암호화 방식은 현 미국 표준 방식인 AES 알고리즘이다. 128~256비트 Key를 적용할 수 있어 보안이 뛰어나고 공개된 알고리즘이라 누구나 사용할 수 있다.     이전에는 DES(Data Encryption Standard) 알고리즘이 주로 사용되었으나 너무 오래되어 취약점이 발견되었고 이를 대체하기 위해 등장한 것이 AES(Advanced Encryption Standard, AES) 이다.   1.1. 대칭형 암호화 알고리즘  DES, AES 외에도 RC4, Twofish, Serpent, Blowfish, CAST5, 3DES, IDEA 등의 암호화 알고리즘이 존재하며 국내에서 개발된 SEED와 ARIA라는 알고리즘도 있다.   1.2. 대칭형 암호화 방식의 문제점  대칭형 암호는 좋은 방식이지만 결정적으로 ‘키 배송’에 대한 문제가 발생한다. 어떻해서든 보내는 곳 입장에서는 받는곳에게 암호 Key를 전달해야 하는데 만약 이 Key가 유출되면 아무리 뛰어난 알고리즘을 사용했더라도 무용지물이 된다.   평문을 안전하게 전달하기 위해 만든것이 암호문인데 정작 Key를 안전하게 전달할 방법이 없는것이 문제이고 이를 해결하기 위한 발상의 전환으로 나온것이 다음의 비대칭형 암호화 방식이다.   2. 비대칭형(비대칭키, 공개키) 암호화 방식  암호화에 사용되는 Key와 복호화에 사용되는 Key가 서로 다른 경우이다.     암호화를 하면 하나의 키 쌍이 생기고 이 두 개의 키는 수학적으로 밀접한 관계를 가지고 있다.    두 개의 키를 각각 키 A, 키 B라고 했을 때 키 A로 암호화한 암호문은 키 B로만 복호화할 수 있고 키 B로 암호화한 암호문은 키 A로만 복호화할 수 있다.    따라서 이 중 하나의 키만 비밀로 보호하고(private key) 다른 하나의 키는 공중에게 공개해도 관계가 없다(public key).   이렇게 둘 중 하나의 키는 반드시 공개되어야 통상적인 사용이 가능하므로 공개키 암호라고도 불린다.   상호간에 공개키를 교환하고 상대방의 공개키로 암호화를 해서 데이터를 교환한다. 교환된 데이터를 복호화하는데는 자신의 개인키로 가능하기 때문에 키 배송 문제가 발생하지 않는다.   2.1. 비대칭형 암호화 알고리즘  비대칭형 암호에는 Diffie-Hellman 키 교환, DSS, ElGamal, ECC, RSA 등이 있다.   2.2. 비대칭형 암호화 방식의 문제와 SSL  키 배송 문제는 해결되었지만 비대칭형 암호화 방식은 대칭형 방식에 비해 현저하게 느리다는 문제점이 있다.   따라서 현실적으로는 대칭형과 비대칭형 방식을 혼합하여 사용한다.    즉, 비대칭형 암호화 방식을 이용해서 대칭형 암호의 키를 배송하고 이후 실제 암호문은 대칭형 암호를 사용하는 방식으로 사용되는 것이다.    참고로 이게 바로 표준 보안 방식인 SSL이다.   웹사이트에 접속하는 케이스로 flow를 정리하면 아래와 같다.      암호문을 주고받을 상대(서버)에게 접속 요청을 한다.   상대는 자신의 공개키를 나(브라우저)에게 보낸다.   나는 암호화할때 사용할 대칭키를 상대의 공개키로 암호화해서 보낸다.   상대는 내가 보낸 암호문을 자신의 개인키로 풀어서 대칭키를 알아낸다.   이제 대칭키 방식을 통해 암호문을 주고받는다.   그런데 이 방식에도 취약점이 있는데 바로 중간자 공격(MITM : Man In The Middle Attack)이다.    해커가 중간 통신을 가로채어 수신자에게는 송신자인척하고 송신자에게는 수신자인척 하여 양쪽의 공개키와 실제 암호화에 사용되는 대칭키를 모두 얻어내는 기법이다.   이런 문제때문에 verysign과 같은 제 3의 인증기관이 생겼다. 즉, 내가 접속한 사이트가 진짜인지 가짜인지를 구분하는 용도인 것이다.        전체 과정에 대한 자세한 내용은 SSL(Secure Socket Layer)과 인증서 참고    3. 단방향 암호화  평문을 암호문으로 암호화하는 것은 가능하지만 암호문을 평문으로 복호화하는 것은 불가능한 암호화 기법. 기본적으로 동일한 평문은 동일한 암호문으로 암호화되지만 이를 바탕으로 평문을 복원할 수는 없다.   단방향 암호화는 주로 패스워드를 저장할때 사용된다. 즉, 암호화된 암호문을 비교해서 동일한 암호인지는 확인할 수 있지만 실제 패스워드가 무엇인지는 모르는 것이다.   또 다른 사용처로는 원본 메세지가 손상되었는지를 확인하는데 있다. 주로 파일 무결성을 검사할때 사용한다.   3.1. 단방향 암호화 알고리즘  주로 해시 알고리즘을 사용하며 대표적인 해시 알고리즘으로 MD4(Message Digest 4), MD5(Message Digest 5), SHA(Secure Hash Algorithm) 등이 있다.       [참고 문서]          나무위키     참고 블로그       ","categories": ["보안"],
        "tags": ["암호화","SSL"],
        "url": "http://localhost:4000/security/encryption_algorithm",
        "teaser": null
      },{
        "title": "GitHub pages와 테마에 대해서 (1)",
        "excerpt":"GitHub에서 제공하는 GitHub Pages 기능을 이용하면 간단한 사이트를 만들 수 있다.    이렇게 만들어진 사이트는 https://{my-github-id}.github.io 형태의 사이트가 된다.     Github pages 공식 자료    여기서는 Jekyll 을 이용한 블로그 생성 과정에 대한 History를 기록한다.    모든 포스팅이 그렇지만 개인 공부에 대한 History를 남기고 다음에 같은 작업을 다시 할 일이 있을때 금방 기억에서 꺼내기 위한 용도라 아주 자세한 설명은 기록하지 않는다.   1. GitHub pages  간단하게 Github pages가 제공하는 기능을 알아두면 이해가 쉽다.   어떤 홈페이지를 만들려면 서버가 필요하다. 직접 내 컴퓨터를 서버로 쓰지 않는한 보통은 호스팅(서버의 일부 또는 전체를 임대받는것) 서비스 업체에서 호스팅을 받게 되고, 임대 받은 공간에 내 홈페이지를 구축한다.   Github pages를 이용하면 Github repository 자체를 호스팅 공간으로 사용할 수 있다.   즉, 홈페이지 소스코드(html, css, javascript, etc…) 를 repository에 올려두면 Github에서 선택적으로 이들을 빌드 후 웹사이트로 게시해주는 서비스이다.      참고로 Github page는 정적 사이트만을 지원하여 PHP, Ruby, Python과 같은 server side programming language는 지원하지 않는다.    그럼 우선 사이트를 만들어야 하는데 Jekyll 이란 서비스는 손쉽게 이런 사이트를 만들수 있는 도구이다.     게다가 Github pages는 기본적으로 Jekyll 빌드를 지원한다. (그래서 Github에서 Jekyll 사용을 권장함.)   이러한 지원 덕에 우리는 Jeykll을 이용하여 사이트를 만드는 설정만 Repository에 올려두면 Github에서 알아서 빌드하여 사이트로 만들어 보여주게 되는 것이다.   2. Jekyll 이란?  Jekyll은 GitHub 설립자인 Tom Preston-Werner가 루비로 작성한 정적 사이트 Generator 이다.     Jekyll을 이용하면 내가 만든 텍스트 파일들을 손쉽게 정적 웹사이트 또는 블로그로 만들 수 있다.   Jekyll을 통해 블로그를 만들면 아래의 장점이 있다.           별도로 관리할 요소가 없다. (정적 사이트 생성인만큼 단순하다는 뜻)   DB 도 없고, 로그인 기능도 없다.            Markdown, Liquid, Html&amp;CCS 파일을 넣으면 바로 사이트가 만들어 진다.            고유주소, 카테고리, 페이지, 포스트, 레이아웃등의 기능이 기본적으로 포함되어 있어 블로그 만들기에 최적화되어 있다.            잘만들어진 테마를 이용하면 특별한 개발 지식 없이 몇가지 설정만으로 그럴싸한 블로그를 만들 수 있다.            GitHub Repository에 commit 하는것만으로도 빌드 및 배포를 할 수 있다.   (이건 Github가 Jeykll 빌드를 지원하기 때문이다.)            GitHub를 통해 호스팅할 수 있고, 호스팅 비용이 따로 없다.          참고로 Private Repository를 만들어 배포할 경우에는 Private Repository 사용에 대한 비용이 부과될 수 있어서 public 으로 만들어야 한다. 그리고 Jeykll은 정적 사이트 생성기인만큼 빌드 이후에 사이트를 구성하는 코드들이 생성된다. 만약 다른 호스팅을 사용하고 싶다면 빌드된 결과를 호스팅 서버에 올리면 될 것이다. (Jeykll 자체가 Github 전용 기능은 아니라는 뜻)    3. 개인적으로 GitPage + Jekyll 을 이용하게 된 계기  예전에 블로그를 해보려 몇번 시도를 해보았으나 꾸준히 유지보수 하는 단계까지는 가본적이 없다.    블로그를 만들어보려 한 목적은 단순히 내 개인 공부에 대한 History 유지였기 때문에 가능한 가볍게 운영할 수 있는 환경을 필요로 했었다.     일단 내가 필수로 원한 환경은 아래와 같다.      무료 호스팅이 가능할 것   수정, 배포 단계가 단순할 것   Markdown 문서 작성이 가능할것 (매우중요)   포스팅 문서에 대한 유실 유려가 없고, 내가 가지고 있는 원본과 포스팅되는 문서의 차이가 없을것. (매우중요)   몇년전 이런 환경을 만들려고 Django+Python을 배워 직접 블로그 사이트를 만들어본적이 있으나.. 그 사이 회사 일하면서 거의 다 까먹어 버렸다….   그러던중 시간 나는김에 GitHub.io 로 나오는 블로그들이 어떻게 만들어지는지 찾아보게 됬는데 내가 원하던 환경이 딱 맞게 갖춰져 있어 다시 한번 만들어보게 되었다. 일단 내가 원했던 환경과 비교하면                  조건       GitPage                       무료 호스팅       GitHub에 Repository 하나 생성하면 된다.                 수정, 배포 단계 단순       여러 테마를 이용하면 금방 사이트를 만들 수 있었고, 정적 사이트다보니 구조가 단순하여 수정이 크게 어렵지 않았다. 배포의 경우 Repository에 commit 하면 알아서 빌드 및 배포가 된다. 물론 CI 서버 설정도 할 수 있다.                 Markdown 문서 작성 가능       Markdown 포맷으로 자료 정리하는것을 매우 선호하고, 몇년간 그렇게 자료를 정리해왔었다.                 문서 유실 우려가 없고, 원본과의 포스팅되는 문서의 차이가 없을 것       평소 Markdown으로 정리해둔 자료를 그대로 포스팅하고 싶었고, 정리한 자료와 블로그에 포스팅하는 문서간의 차이가 거의 없었으면 했다. 또한 별도 백업 없이 문서 유실 우려가 없었으면 했다. GitPage는 이 조건을 100% 만족했다. Git 으로 관리되는 블로그라 우선 내 컴퓨터에 항상 원본이 있고, 뭐 GitHub가 망할일도 없을테니..              일반적인 블로그는 블로그에 있는 에디터를 통해서 포스팅을 하게된다. 포스팅된 내용은 블로그의 DB에 저장이 될 것이다. 이 자체로 내 컴퓨터의 원본과 포스팅되는 글의 데이터에 sync가 맞지 않게 되버린다. 내가 원한건 로컬에서 작성한 문서가 그대로 포스팅할 수 있는 문서가 되었으면 좋겠다는 것이었는데 gitpage가 이를 만족한다.    하지만 단점도 있었다.   일단.. 무료로 사용하기 위해 public repository를 사용하다보니 블로그 코드 원본이 모든 사람에게 공개가 되버린다.     어차피 정적 사이트이고, 공개용 포스트 내용이긴 하지만 원본 그 자체를 모두 받아갈 수 있는 상황은 아무래도 좀 껄끄러울 수 밖에 없다.      약간 귀찮긴하지만 원본 코드를 repository에 올리는게 아니라 로컬에서 jeykll 빌드 후 빌드된 코드를 올리는 방법을 사용하면 된다.! 이건 다음 포스팅에 다룬다.    4. Minimal Mistakes Theme  블로그 만드는데 사용한 Jeykll 테마이다. (테마 공식블로그, 테마 github)    이 테마를 선택한 이유는 사실 별 다른건 없고, 검색했을때 먼저 나왔는데 보기에 깔끔하고 지원하는 레이아웃도 꽤 많은것 같아보였으며, 활발하게 유지관리가 되고 있어 선택하게되었다.     만들다보니 느낀것은 이후에 내가 다른 테마를 적용하고 싶을 경우에도 큰 어려움을 없을 것 같았다.   ","categories": ["블로깅"],
        "tags": [],
        "url": "http://localhost:4000/%EB%B8%94%EB%A1%9C%EA%B9%85/1.-GitHub-pages-%EC%99%80-%ED%85%8C%EB%A7%88/",
        "teaser": null
      },{
        "title": "GitHub pages로 블로그 만들기 (2)",
        "excerpt":"1. 저장소(Repository) 생성 및 설정  Git repository를 이용하는 것인만큼 Git에 새로운 Repository를 만들어야 한다.    주의할 점은 이 때 Repository 이름에 따라서 블로그의 도메인 주소가 바뀐다.    https://id.github.io 형태로 만들고 싶다면 Repository name은 id.github.io 형태로 만들어야 한다. 만약 다른 이름(예를 들어 ProjectName) 으로 만들었다면 도메인은 id.github.io/ProjectName 이 된다.   그리고 생성할때는 Public 으로 만들어야 한다. (Private으로 만들려면 유료 요금제 필요)        위에서 나오는 경고는 이미 같은 이름의 Repository가 존재해서 나오는 것.    2. 원하는 Jekyll 테마 선택하기  https://github.com/topics/jekyll-theme, 또는 http://jekyllthemes.org/  를 참고하여 내가 원하는 테마를 선택하면 된다.     난 이중 minimal-mistakes 테마 를 선택하였다.   3. 블로그 설치     https://github.com/mmistakes/minimal-mistakes#installation  참고    minimal-mistakes 테마의 경우 3가지 설치방법을 제공한다.      Gem 기반 방법   Remote theme 방법   minimal-mistakes repository를 fork 하거나 직접 다운로드하여 모든 파일을 내 프로젝트에 넣는 방법   설치 방법과 별개로 공통적으로 블로그 설정을 위한 _config.yml 파일의 수정이 필요하다.   이곳에서 사이트 제목, 작성자 정보, 기타 설정을 변경할 수 있는데, 설정이 많으므로 자세한 내용은 공식 가이드 를 참고하면 된다.   설치 방법과 관련된 _config.yml 파일 수정은 아래에서 다룬다.   3.1. Gem 기반 방법 (minimal-mistakes 테마는 github 지원 x)     Gem에 대해서는  포스팅을 참고할 것.      Gem은 Ruby 프로젝트의 라이브러리이다.    minimal-mistakes 테마는 gem 으로도 배포가 되어 있어서 이를 통해 블로그를 간단히 구성할 수 있는 방법을 제공하였다.   Gem 기반으로 설치하는 방법의 경우 공식 사이트 설명 내용을 읽어보면 좀 더 이해에 도움이 된다.   간단히 설명하면 jeykyll 의 테마 gem에는 assets, _layouts, _includes, _sass 디렉토리의 파일들이 포함되어 있다고 한다. 테마에 필요한 파일을 가지고 있다보니 내가 블로그를 구축할때는 이 파일들이 없어도 되는 장점이 있다. (아니면 위에서 열거한 저런 테마 관련 파일들을 직접 가지고 있어야 함.)   라이브러리 형태인 gem으로 배포되다보니 테마가 업데이트 되는것을 반영하는것이 간단하고, 다른 테마로 바꾸는 것도 쉽다.     3.1.1. 설치 과정  local에서 테스트해본 경우 아래와 같이 할 수 있었다.           minimal-mistakes 테마 repository를 내 컴퓨터에 다운받는다.            내가 만들 블로그 폴더를 생성하고,  다운받은 minimal-mistakes 파일에서 일부 가져온다.                      _posts는 내가 포스팅할 내용들이 담기는 폴더로 처음에는 empty 폴더로 두면 된다.                 _config.yml 파일 수정    theme 주석을 푼다. remote_theme은 주석 처리를 유지한다.        theme                             : \"minimal-mistakes-jekyll\"  # remote_theme             : \"mmistakes/minimal-mistakes\"                Gemfile 파일 수정          source \"https://rubygems.org\"  gem \"minimal-mistakes-jekyll\"                콘솔에서 bundle 명령 실행을 통해 필요한 gem 을 설치한다.    실행되면 Gemfile.lock 파일이 생성된다.            콘솔에서 bundle exec jekyll serve 로 블로그 실행    빌드 과정에서 _site 폴더가 만들어지면서 블로그 파일들이 자동으로 생성된다.                      _posts 폴더는 테스트를 위해 넣어둔것.                 http://localhost:4000/ 로 확인하기       3.1.2. 주의 사항  minimal-mistakes 테마의 경우 gem 기반 방식은 github에서 지원하지 않았다.(이것때문에 삽질을…)    테마 README 파일에는 되는것처럼 되어 있었는데 이건 jeykll이 github 만을 위한것은 아니기 때문에 명시한 것인듯하다.   이렇게 구성하고 내 repository에 commit한 경우 이메일로 아래 빌드 warning 메일이 날라왔다.   You are attempting to use a Jekyll theme, “minimal-mistakes-jekyll”, which is not supported by GitHub Pages. Please visit https://pages.github.com/themes/ for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see https://docs.github.com/github/working-with-github-pages/adding-a-theme-to-your-github-pages-site-using-jekyll.   지원 가능한 테마의 경우 https://pages.github.com/themes/ 에서 확인할 수 있었는데 수가 많지 않았다.   3.2. Remote theme 방법 (minimal-mistakes 테마는 github 지원 O)  Remote theme 방식은 Gem 기반 방식과 유사하게 직접 테마 파일을 가지지 않는 방법이다. Github pages 에서 minimal-mistakes 테마의 Remote theme 방식을 지원하므로 이 방법을 사용할 수 있다.   3.2.1. 설치 과정           minimal-mistakes 테마 repository를 내 컴퓨터에 다운받는다.            내가 만들 블로그 폴더를 생성하고,  다운받은 minimal-mistakes 파일에서 일부 가져온다.   (Gem 기반 방식과 동일하게 _config.yml, Gemfile, index.html 을 가져온다.)            _config.yml 파일 수정    remote_theme 주석을 푼다. theme은 주석 처리를 유지한다.        # theme             : \"minimal-mistakes-jekyll\"  remote_theme   : \"mmistakes/minimal-mistakes\"           plugins 에 jekyll-include-cache 가 있는지 확인한다.        plugins:     ....     - jekyll-include-cache                Gemfile을 아래와 같이 수정한다.          source \"https://rubygems.org\"  gem \"github-pages\", group: :jekyll_plugins gem \"jekyll-include-cache\"                 콘솔에서 bundle 명령 실행을 통해 필요한 gem 을 설치한다.    실행되면 Gemfile.lock 파일이 생성된다.            콘솔에서 bundle exec jekyll serve 로 블로그 실행    빌드 과정에서 _site 폴더가 만들어지면서 블로그 파일들이 자동으로 생성된다.                      생성되는 파일은 gem 기반 방식과 동일했다.                 http://localhost:4000/ 로 확인하기       3.2.2. Github page에 올리는 방법  Remote theme 방식을 지원하기 때문에 현재 파일들을 그대로 내 repository에 commit, push 하면 된다.    약간의 빌드시간 후 https://id.github.io 로 접속해보면 로컬에서 봤던 페이지 그대로 보이는것을 알 수 있다.   3.3. minimal-mistakes 소스 전체 받아서 하는 방법   3.3.1. 설치 과정           minimal-mistakes 테마 repository 전체를 내 Repository에 복사한다.    두가지 방법이 있을것이다.         A. minimal-mistakes repository를 fork한 후 이름바꿔서 쓰기      B. minimal-mistakes 소스를 다운로드 받고, 새로 생성한 내 repository에 push 하기            전체 소스를 내 컴퓨터에 가져온다.     fork한 경우 fork한 내 repository를 가져오면 될 것이고, 다운로드 후 내 repository에 push한 경우 이미 로컬에 테마의 모든 파일이 있을 것이다.            필요없는 파일 삭제하기.     minimal-mistakes 테마 repository에는 샘플용으로 들어있는 불필요한 파일 및 repository의 README 파일 등과 같은것이 있으므로 이들은 삭제해야 한다.        .editorconfig  .gitattributes  .github  /docs  /test  CHANGELOG.md  README.md  minimal-mistakes-jekyll.gemspec  screenshot-layouts.png  screenshot.png                _config.yml 파일 수정    theme, remote_theme 주석을 모두 유지한다.        # theme             : \"minimal-mistakes-jekyll\"  # remote_theme   : \"mmistakes/minimal-mistakes\"                콘솔에서 bundle 명령 실행을 통해 필요한 gem 을 설치한다.              콘솔에서 bundle exec jekyll serve 로 블로그 실행              http://localhost:4000/ 로 확인하기       3.3.2. Github page에 올리는 방법  수정한 모든 파일들을 그대로 내 repository에 commit, push 하면 된다.    약간의 빌드시간 후 https://id.github.io 로 접속해보면 로컬에서 봤던 페이지 그대로 보이는것을 알 수 있다.   4. 포스팅하기     minimal-mistakes 공식 가이드 Jeykll 공식 가이드    포스팅을 하고 싶은 경우 _post 디렉토리 밑에 markdown으로 포스팅 내용 작성 후 repository에 commit, push 하면 된다.   단, 이 때 파일명에 대해서 아래 규칙을 지켜줘야 한다.    YEAR-MONTH-DAY-title.MARKUP    ex)     2011-12-31-new-years-eve-is-awesome.md    2012-09-12-how-to-write-a-blog.md   그리고 포스팅하는 글 본문의 첫 시작을 YAML front Matter 형식으로 기술하면 포스팅되는 글에 대한 설정을 할 수 있다.   아래는 예이다. 자세한 설명은 Jekyll 가이드를 참고한다.   --- layout: single categories:    - 내 카테고리 tags:   - 태그1   - 태그2 title:  \"안드로이드에 대해서\" toc: true  ---  ## 안드로이드에 대해서  - 프레임워크와 라이브러리 차이를 설명할 수 있다.  - `new Activity()` 코드가 왜 없는지에 대해 설명할 수 있다.  - Lifecycle을 누가 호출하는지에 대해서 설명할 수 있다.   특정 설정이 매번 필요하다면 공통적인 부분에 대해서 _config.yml 파일에서 default 설정을 할 수 있다.   defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true   위 처럼  single 레이아웃에 대해서 default 설정을 해 둘 수 있다. default 설정을 하되 특정 포스트에서는 변경하고 싶다면 동일한 속성을 override 할 수 있다.        [참고 문서]     https://flik.tistory.com/3 https://www.ruby-lang.org/ko/libraries/ https://www.railsguidebook.com/contents/walkthrough/gemfile.html https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/ https://jekyllrb.com/docs   ","categories": ["블로깅"],
        "tags": [],
        "url": "http://localhost:4000/%EB%B8%94%EB%A1%9C%EA%B9%85/2.-GitHub-pages-%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "GitHub pages 구축 후 설정 (3)",
        "excerpt":"블로그 구성을 위해 했던 History 관리차 기록합니다.   1. 페이지 정의하기  404 에러 페이지나, 내 소개 페이지처럼 일반적인 포스팅이 아닌 특정 페이지를 만들 수 있다.    이들은 _pages 디렉토리에 정의한다.   난 404 에러 페이지, category archive, tag archive, year archive, 검색 등은 minimal-mistakes 에 정의된것을 그대로 사용하였다.    샘플들을 보면 알겠지만 이 역시 YAML front matter 형태로 정의가 되어 있다.   기본적으로 있는 page 외에 난 내가 정의한 카테고리별 포스팅 내용들만 따로 보여주는 페이지를 만들고 싶어서 아래 같은 android-archive.md 를 정의하였다. (각 카테고리별로 하나씩 추가)   --- title: \"안드로이드\" permalink: /categories/android/ layout: category author_profile: true taxonomy: \"안드로이드\" sidebar:   nav: \"docs\" ---   이렇게 정의한 페이지는 https://id.github.io/categories/android 로 접근할 수 있다.   2. 네비게이션 메뉴 설정  상단 메뉴 외에 좌측 프로필 영역 아래에 카테고리별 이동하는 링크를 두고 싶어 아래처럼 구성하였다.     카테고리별 포스팅 링크는 바로 위에서 정의한 페이지들이다.   # main links main:   - title: \"Category\"     url: /categories/   - title: \"Tag\"     url: /tags/   - title: \"Years\"     url: /year-archive/  docs:   - title: Category     children:       - title: \"안드로이드\"         url: /categories/android       - title: \"자바\"         url: /categories/java       - title: \"디자인패턴\"         url: /categories/designpattern       - title: \"보안\"         url: /categories/security       - title: \"개발 etc\"         url: /categories/basic      ","categories": ["블로깅"],
        "tags": [],
        "url": "http://localhost:4000/%EB%B8%94%EB%A1%9C%EA%B9%85/3.-GitHub-pages-%EA%B5%AC%EC%B6%95-%ED%9B%84-%EC%84%A4%EC%A0%95/",
        "teaser": null
      }]
