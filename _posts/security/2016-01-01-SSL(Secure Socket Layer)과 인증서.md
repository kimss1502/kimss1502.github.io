---
layout: single
categories: 
  - 보안
title: "SSL(Secure Socket Layer)과 인증서"
toc: true
---

> SSL에 대해서는 [암호화 알고리즘]({% post_url security/2016-01-01-암호화 알고리즘 %}) 를 참고할 것.

 간단히 SSL(Secure Socket Layer) 프로토콜은 대칭형 암호화와 비대칭형 암호화 방식을 혼합하여 사용한 것으로 Netscape사에서 웹서버와 브라우저 사이 데이터를 주고받을때의 보안을 위해 만들었다. <br/>

 SSL은 중간자 공격(MITM : Man In The Middle Attack)에 취약한데 이 때문에 verysign과 같은 제 3의 인증기관이 생겼다. 즉, 내가 접속한 사이트가 진짜인지 가짜인지를 구분하는 용도인 것이다.
  
 이런 인증기관을 Certificate Authority(CA)라 부른다. 이 때 인증을 위한 인증서를 SSL 인증서라 부른다.

## 1. SSL 인증서 기반 암호화 통신
 전체 과정은 아래와 같다.
 
 1. 인터넷 사이트는 자신의 정보와 공개키를 인증 기관에 제출한다.
 2. 인증 기관은 검증을 거친 후 해당 사이트 정보와 공개키를 인증기관의 개인키로 암호화한다. (**이것이 해당 사이트의 SSL 인증서이다.**)
 3. 인증기관은 웹 브라우저에게 자신의 공개키를 제공하고 브라우저는 검증된 인증기관의 공개키를 브라우저 내에 미리 탑재한다. (정확히는 공개키가 들어있는 CA 인증서.)
 4. 사용자가 웹브라우저로 사이트에 접속하면 사이트는 인증기관이 만들어준 자신의 인증서를 웹브라우저에게 보낸다.
 5. 웹브라우저는 인증 기관의 공개키로 인증서를 해독한다.(유명 인증기관의 공개키는 브라우저에 이미 탑재되있음. 참고로 이 때 인증서의 유효성을 검증하는데 전자서명이 사용되고, 전자서명을 위한 해시 알고리즘 문제가 바로 SHA-1 인증서 문제이다. )
 6. 해독된 인증서를 통해 사이트를 검증하고, 해당 사이트의 공개키를 얻는다.
 7. 이렇게 얻은 사이트의 공개키로 대칭키를 암호화해서 보낸다.
 8. 사이트는 자신의 개인키로 암호문을 해독하여 요청자의 대칭키를 얻는다.
 9. 이제 서로 대칭키를 알고있기때문에 대칭키 암호 방식으로 데이터를 주고받을 수 있다.

SSL Handshaking 과정을 이미지로 보면 아래와 같다.
 
 ![인증서 기반 통신](https://kimss1502.github.io/assets/images/ssl_connect.png)

 
## 2. 인증서(Certificate)
 인증서는 접속하고 있는 웹사이트가 신뢰할 수 있는 사이트라는 것을 인증하는 역할을 한다. <br/>
 인증서의 상세내용은 대개 아래와 같다.
 
 1. 서비스 정보 (인증서를 발급한 CA, 서비스 도메인, 유효기간 등)
 2. 서버측의 공개키 (공개키 내용, 공개키 암호화 방식)
 3. 인증서 유효성을 검증하기 위한 해쉬(Hash)

SSL 인증서의 기본 구조는 "당신이 인증서 서명한 사람을 신뢰한다면, 서면된 인증서도 신뢰할 수 있다" 라는 것이다. 또한 인증서는 Tree 구조를 이루고 있고 인증서가 다른 인증서를 서명한다. <br/>

 Tree 구조이기 때문에 최상위 인증서가 존재하는데 최상위 인증서를 발행한 기관을 `Root Certification Authority(Root CA)` 라고 부른다. <br/>
 유명한 인증기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 웹브라우저에 기본 설치되어있다. 그럼 Root CA의 인증서는 누가 서명을 했을까? 모든 Root CA 인증서는 자체 서명(self signed) 되어 있다.
 
 브라우저 회사는 자신들의 판단에 의해 CA를 선택하여 목록을 브라우저에 미리 탑재하는데 만약 해당 인증기관이 아닌 사설 인증기관인 경우 주소창에서 아래와 같이 경고한다.
 
 ![사설 ca 경고](https://kimss1502.github.io/assets/images/ca_warning.png)
 
## 3. 전자서명
 전자서명이란 서명자를 확인하고 해당 서명자가 전자문서에 서명을 하였음을 나타내는데 이용하기 위해 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보를 말한다.
 
 전자서명의 기본 원리 역시 `공개키 기반 암호화 알고리즘`이다. <br/>
 즉, private key로 암호화된 내용은 public key로만 풀수있기 때문에 정확히 어떤 사람이 서명을 했다라가는거을 증명할 수 있는 것이다.
 
 공개키 기반 암호화 원리를 이용한 전자서명은 아래와 같이 동작한다.
 
 1. 원본 문서 내용을 잘 알려진 Hash 함수(ex- MD5, SHA1)를 이용해 해시값을 추출한다.
 2. 해시값을 서명자의 Private key로 암호화 한다.
 3. 암호화한 해시값은 원본 문서 끝에 첨부해서 수신자에게 전달한다.
 4. 수신자는 전달받은 이후 먼저 문서 끝에 첨부된 해시값을 분리하여 원본 문서만 추출한다.
 5. 추출한 문서를 송신자가 적용한것과 같은 Hash 함수를 이용해 해시값을 추출한다.
 6. 아까 분리했던 암호화된 해시값을 송신자의 Public key로 복호화 한다.
 7. 복호화된 해시값과 내가 원본에서 만든 해시값을 비교한다.
 8. 두 값이 동일하면 서명이 올바른 것이라고 판단한다.
 

## 4. SSL의 SHA1 인증서 문제
 SHA1 알고리즘의 경우 컴퓨팅 성능의 발달로 문제가 되어 더이상 안전하다고 보기 어렵게 되었다. 
 따라서 각 브라우저는 SHA1 인증서를 더이상 지원하지 않기로 하였고, 각 사이트들 역시 SHA1 알고리즘으로 만들어진 인증서를 SHA2 알고리즘의 인증서로 변경해야 한다.

 여기서 SHA1 인증서라 함은 인증서의 전자서명이 SHA1 해시함수로 만들어진 인증서인 것이다.
 
---
> **[참고 문서]**
>
> 1. [참고 사이트 1](https://wiki.kldp.org/HOWTO/html/SSL-Certificates-HOWTO/x70.html)
> 2. [SHA1 인증서 경고 관련](http://ohgyun.com/565)
> 3. [관련 기사](http://www.zdnet.co.kr/news/news_view.asp?artice_id=20151026111654)
> 4. [참고 블로그](http://yoonsj.tistory.com/12)
> 5. [오픈튜토리얼](https://opentutorials.org/course/228/4894)
> 6. [전자서명-위키피디아](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85)